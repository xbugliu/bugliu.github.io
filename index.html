
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>书写|记下人生痕迹</title>
  <meta name="author" content="ToWriting">

          
        <meta name="description" content="记录人生痕迹|分享技术心得 -- ToWriting.com. 一个立志独立思维的程序员的博客网站. 这里会记录下自己工作, 生活和回忆; 同时会分享编程等相关技术知识; 所有文章皆为原创或翻译.">
        <meta name="keywords" content="阅读,思考,书写,程序员,C++">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://towriting.com">
  <link href="/favicon.ico" rel="icon">

  <link href="/assets/bootstrap/css/spacelab.min.css" rel="stylesheet" type="text/css">
  <link href="/assets/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css">
  <link href="/assets/bootstrap/css/custom.css" rel="stylesheet" type="text/css">
  <link href="/assets/font-awesome/css/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="/stylesheets/screen.css" rel="stylesheet" type="text/css">
  <link href="/stylesheets/github.css" rel="stylesheet" type="text/css">
  
  <link href="/atom.xml" rel="alternate" title="书写|记下人生痕迹" type="application/atom+xml">
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42601840-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="no-sidebar"   data-spy="scroll">

  <div class="container">
    <header class="jumbotron subhead" id="overview">
      
<div class="subscribe">
  <table>
    <tr>
      <td><span>订阅: &nbsp;</span></td>
      
      
      <td><a href="/atom.xml" class="btn"><i class="icon-cog"></i> By RSS</a></td>
      
      
    </tr>
  </table>
</div>

<h1 class="title">ToWriting</h1>


      <div class="navbar">
  <div class="navbar-inner">
    <div class="container" style="width: auto;">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <div class="nav-collapse">
                <ul class="nav">
          <li><a href="/">Home</a></li>
          <li><a href="/blog/archives">Archives</a></li>
          <li><a href="/about">About</a></li>
        </ul>

        
          <form action="http://google.com/search" method="get" class="navbar-search pull-left">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:towriting.com" />
              <input type="text" name="q" results="0" placeholder="Search" class="search-query span2" />
            </fieldset>
          </form>
        
        
      </div><!-- /.nav-collapse -->
    </div>
  </div><!-- /navbar-inner -->
</div>

    </header>
    <div id="main">
      <div id="content">
        
<div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/06/from-the-user-perspective/">驳‘做产品必须站在用户的角度考虑’</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-06T00:00:00+08:00" pubdate data-updated="true">2013-11-06</time>
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>“要站在用户的角度考虑”是互联网软件的从业者几乎听的耳朵磨出茧子的一句话。站在用户的角度考虑才能做出好的产品，似乎是整个行业的共识，但对于这句话我大抵是不赞成的。</p></blockquote>

<h2>只为用户体验</h2>

<p>”站在用户的角度考虑“，首要的目的大概是为了用户体验，但极致的用户体验是否是成就“好产品”的必要条件？</p>

<p>何为好产品？按体验划分的好产品，在我看来大概有两种：</p>

<p>第一种重实用，轻体验。这种产品拥有用户<strong>不可或缺的功能</strong>，并且这个功能有可能“只此一家，别无分店”。这时，这款产品，就有资格“叫嚣”：想用我，就按我的规则来。西方的一些传统软件，功能强大或独特，但界面交互工程感很强，普通人上手困难，<strong>用户可能不多</strong>，但一旦上手，爱不释手。这方面的代表：传统的Linux。</p>

<p>第二种重体验，包装功能。以体验制胜，傻瓜式是其特色，人人可上手，可省心的满足用户基本要求，<strong>拥有大量用户</strong>，这种好产品有“讨好”之嫌。这方面的代表：360安全卫士。</p>

<p>一个产品，成为好产品，和体验并无必然联系，功能是关键，<strong>体验只是锦上添花</strong>。要知道，360安全卫士，不仅体验好，各种功能也是人们亟需的。微信很成功，张小龙也曾在不同场合说过，微信的火是满足了用户的刚需。你会更在意Google的页面还是搜索内容呢？</p>

<p>这是无法弯曲的事实：用户肯定是因为某个功能才使用某款产品的。所以对于用户个体来说，功能是决定产品好坏的最重要标准。</p>

<p><strong>过分强调用户体验，只说明功能平庸！</strong></p>

<h2>锦上添花不容易</h2>

<p>姑且不谈，从逻辑上讲，站在用户的角度考虑，<strong>必然站在创新的反面</strong>，因为创新之物，用户何来想法。</p>

<p>就是想靠“用户的角度”把产品的体验提高一点，也并不容易，因为&#8221;人心难测&#8221;。</p>

<p><strong>1. 你不了解用户</strong>
你无法知道谁会使用你的产品。有限方式的用户调研不保证代表用户答案，这方面的例子是：美国《文摘周刊》1936年进行的总统竞选民意调查的失误。</p>

<p><strong>2. 用户不了解自己</strong>
人有太多的人知缺陷，使其很难告诉你他自己真正的答案，因为他自己也不知道。这方面经典的认知缺陷是选择性认知、问题框架影响答案。</p>

<p>所以，费劲心机得来的“用户角度”也可能有偏差，更何况产品经理脱口而出的”站在用户的角度考虑“呢？</p>

<h2>产品经理的大旗</h2>

<p>常见，若干人围着一个产品经理，讨论一个产品的设计，大家你一言，我一语提出自己对产品的设计看法，最终皆被该产品经理驳回：站在用户的角度考虑, balabala。</p>

<p>难道说这句话时，该产品经理没有意识到刚才与你讨论的这些人不也是用户吗？</p>

<p>产品经理祭出“用户角度”的大旗，大凡三种情况：</p>

<ol>
<li>真正设身处地或调研出的”用户角度“，至少他内心认为是这样。</li>
<li>为了一己私利，压制别人。像文革中的红卫兵，指责别人是走资派。</li>
<li>为了凸显自己的水平与专业性，信口胡诌。</li>
</ol>


<p>相信后两种还是少数，但也客观存在这种面目可憎的家伙。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/01/safe-bool-idiom/">从Safe Bool惯用法到explicit标识符</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-01T22:52:00+08:00" pubdate data-updated="true">2013-11-01</time>
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>C++是一个学语法都能让人入迷的奇葩语言，有各种的奇技淫巧。比如这里的许多的惯用法：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms">More C++ Idioms</a>，虽凝聚了C++程序员的聪明才智，但都是特定时期的产物，
相信都会被冲到C++语言演化长河的河滩上，仅供后人瞻仰（或者是C++本身）。让我们从Safe bool idiom说起。</p></blockquote>

<h2>Safe bool idiom</h2>

<p>什么是safe bool idiom？就是为自定义类型（class）提供检测真假的能力，而又不会带来副作用。</p>

<h3>为类(Class)提供检测真假的能力</h3>

<p>方法有二，第一种简单直白，提供一个返回bool类型的函数，比如下面的isValid成员函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CData</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">IsValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CData</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>   <span class="c1">//dosomething</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是直观而不易出错的。但多多少少有些强迫症的人会说，如果能像检测内置bool类型一样检测data对象不是更好的保证了代码的语法一致性？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CData</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>   <span class="c1">//dosomething</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时他又急于向人们展示，&#8221;我会使用操作符重载哦“。于是第二种方法出来了，重载bool类型转化操作符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CData</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CData</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>   <span class="c1">//dosomething</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>漂亮的外表后面的东西可能是有毒的，比如毒蘑菇、巫婆的毒苹果和传说中的红颜祸水们。软件开发也概莫能外，这个漂亮的解决方案后面有问题。</p>

<h3>bool操作符的副作用</h3>

<p>假使有一个简单的指针外敷类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">CPtr</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">T</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>   <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CPtr</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">CPtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>   <span class="n">p2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>   <span class="c1">//天知道会怎样</span>
</span><span class='line'>   <span class="c1">//something </span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有人不小心拿两个不同类型的类对象来比较，不幸的是编译器并没有报错，因为17行隐式调用了operator==(bool,bool)，后面的结果真真天知道。
这可如何是好？C++社区里最不缺人才，很快有人想出解决方案：</p>

<h3>Safe bool实现</h3>

<p>Safe Bool正式的提出是这里：<a href="http://www.artima.com/cppsource/safebool.html">The Safe Bool Idiom</a>，方法就是写一个类型转化操作符，这个操作符返回一个可以进行 <strong>if</strong> 判断的特有类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Testable</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">ok_</span><span class="p">;</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">Testable</span><span class="o">::*</span><span class="n">bool_type</span><span class="p">)()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">this_type_does_not_support_comparisons</span><span class="p">()</span> <span class="k">const</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">explicit</span> <span class="n">Testable</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="o">:</span><span class="n">ok_</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">operator</span> <span class="n">bool_type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">ok_</span><span class="o">==</span><span class="kc">true</span> <span class="o">?</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">Testable</span><span class="o">::</span><span class="n">this_type_does_not_support_comparisons</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TestableOther</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">ok_</span><span class="p">;</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">TestableOther</span><span class="o">::*</span><span class="n">bool_type</span><span class="p">)()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">this_type_does_not_support_comparisons</span><span class="p">()</span> <span class="k">const</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">explicit</span> <span class="n">TestableOther</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="o">:</span><span class="n">ok_</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">operator</span> <span class="n">bool_type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">ok_</span><span class="o">==</span><span class="kc">true</span> <span class="o">?</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">Testable</span><span class="o">::</span><span class="n">this_type_does_not_support_comparisons</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">Testable</span> <span class="n">testable</span><span class="p">;</span>
</span><span class='line'>  <span class="n">TestableOther</span> <span class="n">testableother</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">testable</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">//something</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">testable</span> <span class="o">==</span> <span class="n">testableother</span><span class="p">)</span> <span class="c1">//编译错误</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码，利用的是bool_type是函数指针类型，所以可以进行 <strong>if</strong> 判断，且不同类的bool_type是不同的，直接比较会编译错误。
这就是safe bool Idiom，详细的代码可以参看这里：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/">More C++ Idioms/Safe bool</a>。
但我认为这个方案是顾此失彼，会引发新的问题，比如类中重载operator int操作符怎么办？</p>

<h2>C++11的做法</h2>

<p>C++11的基因支持safe bool，方法就是使用<a href="http://en.cppreference.com/w/cpp/language/explicit">explicit</a>修饰operator：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Testable</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">Testable</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>      <span class="p">{</span> <span class="cm">/*do something*/</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*do something*/</span> <span class="p">}</span>  <span class="c1">// 编译错误</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>explicit</strong> 在C++11以前是只能用于修饰构造函数，但在C++11中可以用来修饰操作符，上面代码中的operator bool（）加上<strong>explicit</strong>表式其无法隐式转化为bool。
这个解决方案，干净漂亮，无副作用。</p>

<h2>总结</h2>

<p>C++11前后的两种Safe Bool的解决方案比较，优劣立现。站在实用的角度上，C++11出现后，C++中好多“高端技术”已经不需要学习，比如StackOver上列出的这些：<a href="http://stackoverflow.com/questions/9299101/what-c-idioms-are-deprecated-in-c11">what C++ idioms are deprecated in C++11</a>。这些东西就像毛笔字一样，可以仅供专家与爱好者把玩了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/21/openshift-tips/">Openshift小技巧-热部署</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-21T22:24:00+08:00" pubdate data-updated="true">2013-10-21</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近试着用Openshift搭建了一个Octopress程序，搭建成功后，发现每次部署时，都会引起站点临时无法访问，这是自己使用Github的pages时没遇到的事情，用Google快速搜索下，原来要用热部署（hot deploy)实现不重启openshift程序部署文件，官方是支持的，方法很简单：</p>

<ol>
<li>切换到你的Openshift程序根目录</li>
<li>创建文件hot_deploy到指定目录：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>touch .openshift/markers/hot_deploy
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/30/the-myth-of-the-rockstar-programmer/">神级程序员的神话</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-30T12:20:00+08:00" pubdate data-updated="true">2013-09-30</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>神级程序员<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的神话不过就是个，神话！它是由一些可悲的原因形成的神话：</p>

<ul>
<li>给普通人设置难以实现的预期</li>
<li>宣扬虚无的神级程序员打压团队</li>
<li>告诉某人是神级的并使其相信这一说法</li>
</ul>


<p>现实总是正态分布的。大量的程序员是普通水平的，一些大牛已属异类，神级程序员只是传说中有（其实一些也很烂）。</p>

<blockquote><p>落后的项目增加人手,只会导致进度更加落后</p><footer><strong>Brooks&#8217;s law</strong> <cite><a href='http://en.wikipedia.org/wiki/Brooks%27s_law'>维基百科</a></cite></footer></blockquote>


<h2>神级程序员只是个神话</h2>

<p>人们总是津津乐道神级程序员可以做10个普通开发者的工作。天方夜谭！10个孕妇不会只用一个月生出小孩，10个“神级”程序员也无法代替100个普通程序员。</p>

<ul>
<li>助理工程师 &ndash; 简单的问题复杂的解决方案</li>
<li>工程师 &ndash; 简单的问题简单的解决方案</li>
<li>高级工程师 &ndash; 复杂的问题简单的解决方案</li>
<li>神级工程师 &ndash; 消灭复杂的问题于无形</li>
</ul>


<p>我算是神级的吗？我自信自己是一个高级程序员，也小有名气。过去的20年我参加了很多成功的项目，但我从不是坊间最聪明的人。</p>

<blockquote><p>高级 + 耀眼 != 神级</p></blockquote>

<p>按我的理解：</p>

<blockquote><p>高级 + 思想 == 神级</p></blockquote>

<p>这和有没有名气并没有任何关系。不能因为某某人写博客、书或者善于演讲就说他是个好开发。</p>

<p>神级程序员关心代码行数吗？不，好的开发关注的是解决问题。他们解决问题而不是抱怨问题。</p>

<h2>神级的团队是现实存在的</h2>

<p>事实上，团队想法和经验的某些特质成就了神级团队，这肯定是你关心的。深思与实效的组织架构加上激情积极好学的开发者必能有所成就。假如你坚持叫某些人“大神”，他可能是团队的老师或指导者。</p>

<p>John Galloway曾说过：</p>

<blockquote><p>“三思而后行”+“代码追求良质”是成就好团队的良方</p></blockquote>

<p>建造一只聪明个性的团队。创建<strong>神级团队</strong>。</p>

<p><strong>翻译自</strong>：<a href="http://www.hanselman.com/blog/TheMythOfTheRockstarProgrammer.aspx">The Myth of the Rockstar Programmer</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>神级程序员(Rockstar Programmer)是指技术能力很强、经验丰富还必须要有以一敌十的工作效能的程序员。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/23/edward-chands/">C++手爱德华</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-23T22:25:00+08:00" pubdate data-updated="true">2013-09-23</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="pull-right" src="/images/posts/edward-chands/Edwardscissorhandsposter.png" title="" ></p>

<blockquote><p>我一直在寻找一种可以类比使用C++编程时心情的东西，直到我想起1900年Tim Burton的电影，剪刀手爱德华。</p></blockquote>

<p>在这部电影中，可怜的家伙（Johnny Depp)想温柔的拥抱Winona Ryder但是他笨拙的剪刀手对他们俩都会造成伤害。他的脸上留下了很多伤疤。</p>

<p>拥有一对剪刀手并不总是坏事。爱德华有许多才能，比如，它可以给狗剪除漂亮的发式。</p>

<p>当参加完一些C++会议后，我总会有一些想法，最近参加的是Going Native 2013。去年可喜的是大多会议围绕着闪亮的C++11最新标准。但今年更多的关于实际检查。不要误会，这里有太多的漂亮的小狗发式可以展现（我是说C++代码可以简洁优雅）但是会议的主题总是关于如何避免出错及出错后的补救。</p>

<h2>恐怖小窝</h2>

<p>这里有太多的关于<strong>C++禁忌</strong>的讲座使我意识到这可能不是初级程序员的问题，这明显是C++语言自身的错。所以你仅仅学习了语言的基本元素后就使用它，你会遍体鳞伤的。</p>

<p>C++对此有借口：向后兼容 &mdash; 特别是兼容C语言。你应该认为C作为C++的子集应该像人们不应该每天使用汇编一样，除非你是个汇编程序员。假如你对你的C++工具箱视而不见，你看到的总是裸指针、for循环等丑陋的东西。</p>

<p>一个人所共知的禁忌是不要使用malloc动态分配内存，不要使用free释放内存。malloc接受一个size并返回一个void*，你必须把它转换成其它有用的类型。很难实现一个比这更糟糕的内存分配API。这有一段真的很糟的代码（但一般是运行正确的，假如不可能出现空指针解引用的话）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Pod</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span> <span class="n">counters</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="n">Pod</span> <span class="o">*</span> <span class="n">pod</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pod</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="k">sizeof</span> <span class="n">Pod</span><span class="p">);</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">n</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">free</span> <span class="p">(</span><span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">);</span>
</span><span class='line'><span class="n">free</span> <span class="p">(</span><span class="n">pod</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我希望人们不会写出这样的代码，但我确信现实世界的好多程序的代码中有这样的结构。</p>

<p>C++通过替换malloc和free为new和delete&#8221;解决&#8221;了多余的强转和易出错的size计算。正确的C++代码应该这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Pod</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span> <span class="n">counters</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="n">Pod</span> <span class="o">*</span> <span class="n">pod</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Pod</span><span class="p">;</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="p">[]</span> <span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
</span><span class='line'><span class="k">delete</span> <span class="n">pod</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>顺便说一下，空指针引用的问题同样被解决了，因为如果系统内存耗尽，new总是会抛出异常。但这里在第二个new的地方还是有几率发生内存泄漏，所以这是现实中正确的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Snd</span> <span class="p">{</span> <span class="c1">// Sophisticated New Data</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Snd</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">_count</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">_counters</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="p">{}</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Snd</span> <span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">_counters</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span> <span class="n">_counters</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Snd</span> <span class="o">*</span> <span class="n">snd</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Snd</span> <span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">snd</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们做完了吗？才没呢！这段代码不是异常安全的。</p>

<p>C++的基本准则是避免裸指针、避免数组、避免delete。所以医治malloc的良药new也是不应使用的，它会返回危险的指针。</p>

<p>我们都知道（满脸的伤疤可以证明）尽一切可能使用STL容器和智能指针。也应该按值传递参数。不，等一下。按值传递参数因为多余的拷贝会增加性能损耗。使用shared_ptr或shared_ptr的容器怎么样？但这会增加引用计数的滥用。这里有新的解决方案：移动语义和右值引用。</p>

<p>我能举出无数类似的例子。看到规律了没？一个问题的解决方案可能会引入新的问题。不仅C子集需要避免使用。每个新的语言特性或库组建都会带来新的缺陷。当你听完Scott Meyers讲过后，你会发现一个新的特性怎么设计的这么烂（猜一下Scott Meyers论证的最新的缺陷是什么？是移动语义）。</p>

<h2>C++的哲学</h2>

<p>Bjarne Stroustrup一直强调向后兼容对C++来说多么重要。它是C++哲学的根基。它是决定那些代码是合法的依据。然而兼容性给语言演化代理了极大的拖累。如果自然界和C++一样是向后兼容的，人们还会有尾巴、腮、脚蹼、触角 &mdash; 在进化的过程中它们都有过作用。</p>

<p>C++变成了极度复杂的语言。同一件事情有无数种实现方式，但大部分都走向错误、危险、难维护。问题是代码可以编译甚至运行。错误或者缺陷会在后来被发现，甚至是产品发布以后。</p>

<p>你可能会说这是编程语言的自然特性。如果你真这样想，那要好好看看Haskell了。你的第一反应是：用这种极度严苛的语言我不知怎样实现第一件事（阶乘、斐波那契等）。这完全不同于C++。你不会意识到，运气好的话，需要十年你才能发现C++的“真谛”。能否想到，越好的C++程序员，他的代码越具有“函数性”。请教任何一个C++大神，它会回答你：避免可变的（mutation)，避免边际效应，避免继承和派生。但是你将需要严厉的准则和可以控制你同事的能力，因为C++太宽容了。</p>

<p>Haskell一点也不宽容，它不会让你或者你的同事写出不安全的代码的。是的，一开始你可能因为想要用haskell实现C++几分钟可以完成的事情而抓狂。假如你走运，为Sean Parent<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>或类似严格的程序员共事，他将review你的代码，并指出你不要用C++编码了。或者你自己继续在黑暗的日子里，数着自己伤害自己的伤口个数。</p>

<h2>资源管理</h2>

<p>我以资源管理的例子开始这篇文章（严格说是内存管理），因为这是我的个人爱好。从90年代起我就开始写关于资源管理的东西和宣传它。不过失败的是20年后资源管理技术还是鲜为人知。Bjarne Stroustrup有责任花费一半的演讲时间给高级C++程序员讲解资源管理的知识。你也可能会责备初级程序员们没能领悟资源管理是C++编程的根基。但问题是语言并没有指出我一开始写的那段代码有什么纰漏。事实上学习正确的技术就好像学习新的语言。</p>

<p>为何如此艰难？因为C++中最重要的资源管理是内存管理。事实上需要反复强调的是垃圾收集解决不了资源管理的问题：这里有文件句柄，内核对象，打开的数据库等等。这都是重要的资源，但重要性被繁复的内存管理比下去了。为什么不支持垃圾收集，不是因为找不到一种高效的实现方式，因为C++是排斥垃圾收集的。编译器和运行时总要做最坏的打算：不仅一个指针可能是另一个的别名而且内存地址可以保存成整型甚至它的低字节用作位域（所以C++只考虑保守的垃圾收集）。</p>

<p>一个错误的常识是引用计数（shared pointer中使用）比垃圾收集更好。这有个<a href="http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf">研究</a>显示它们是异曲同工的。你应该知道delete一个shared pointer可能会引发任意时间的程序暂停，这和垃圾收集的性能损耗是一样的。这不仅仅是因为一个靠谱的引用计数算法必须处理好环（cycles），并且每次引用计数到0，对象可以达到的指针都需要遍历。用shared pointer创建的数据结构可能花费很长的时间去释放，除了极简单的情况，你无法知道什么时候shared指针要清零了。</p>

<p>在单线程环境下小心的资源管理和使用shared_ptr还是很好的防御方式。但多线程下，麻烦来了。每一次增加减少计数都需要加锁！锁一般由原子变量实现，而不是互斥量。别傻了：使用原子变量消耗很大，这带给我C++的最大问题。</p>

<h2>并发和并行（Concurrency and Parallelism）</h2>

<p>早在8年以前，herb Sutter就发表了著名的声明：<a href="http://www.gotw.ca/publications/concurrency-ddj.htm">免费的午餐结束了</a>！并发并不是发明在2005年。Posix线程1995年就定义了。微软在Windows95引入线程，在NT中支持了多处理器。然而并发是C++11中才有的知识。</p>

<p>C++11算是“白手起家”并发。它必须定义内存模型：多线程写内存时，什么时候和以什么顺序使其对其它线程可见。基于实用的考虑，C++的内存模型是从java中拷贝来的（去掉了一些有争议的数据竞争时的保证）。一句话就是，如果没有数据竞争C++程序是按次序的。</p>

<p>C++11定义了关于线程创建和管理的一些元素，这些同步元素都是被dijkstra和hoare在1960年定义的，比如互斥量（mutexes）和条件变量。有人可能会争辩这些是否是同步的好组件，但这没关系因为都知道他们不是可组装的（composable)。STM（Software Transactional Memory）是可组装的抽象，但这很难在命令式语言中高效及正确的实现。标准委员会有个STM学习小组，所以STM还是有机会成为标准的一部分的。但是因为C++对边界效应不做任何控制，所以它会很难正确应用的。</p>

<p>还有一些误导和混淆是尝试去提供基于任务的并行，使用的是async tasks和非组装的futures（慎重考虑后都会在C++14中不推荐使用）。线程局部变量的标准化也使基于任务的并发很难实现。锁和条件变量也是线程相关的，而不是任务相关的。未来几年标准委员会的当务之急就是这些了：基于任务的并行, communication通道代替futures , 任务取消, 可能还有longer term, data-driven 并行, 包括支持GPU。一个微软PPL和英特尔TBB的衍生可能会被加进标准库（希望不是微软的AMP）。</p>

<p>预测推断所有这些可以在2015年标准化和实现。假如预测成真，我还是不相信人们会用C++实现并行编程。C++是为单线程编程设计的，支持并行编程需要革命而不是改革。四个字：数据竞争，指令型语言没有对此提供保护，可能除了D语言。</p>

<p>在C++中，数据默认是线程共享的、默认是可变的；函数默认是有边界效应的。所有这些指针和引用为数据竞争提供了富饶的土壤。数据结构和函数在竞争上的先天不足使类型系统无法反射。在C++中，假如你有个对象的const引用，但不能保证另一个线程中不会修改它。更糟的是，一个const对象里面的引用默认是可变的。</p>

<p>D语言至少有深度const和不可变的概念（没有线程可以修改一个不可变的数据结构）。D语言朝着并发的另一个改良是可以定义纯函数（pure functions)。在D语言中，可变对象默认不是进程共享的。这是正确的方向，虽然增加了共享对象的运行开销。更重要的想法是，线程不是一个并发编程的好的抽象，所以这种改进在轻量级的任务序列中就不那么有效了。</p>

<p>但是C++对这些都不支持，并且看起来永远都支持不了。</p>

<p>当然，你可能认出了这些并发和并行的特征都是函数式语言具有的，特别是不可变和纯函数。别嫌我烦：Haskell是并发编程上执牛耳者，包括GPU编程。这是为什么我在布道C++技巧数载后轻易转向了haskell。每一个认真对待并发和并行的程序员都应该好好学习haskell看一下它是如何处理这一切的。这里有一本Simon Marlow写的不错的书：<a href="http://www.amazon.cn/gp/product/1449335942/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1449335942&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="">Parallel and Concurrent Programming in Haskell</a>，读完它你或者开始在C++中使用函数式编程技术，或者认识到并发编程和指令式编程的分歧而转投Haskell。</p>

<h2>结论</h2>

<p>我认为C++语言和其哲学是和并发编程的需求冲突的。这种冲突导致并发编程在主流软件开发中缓慢前行。因为这过时的编程范式，微处理器、vector units和GPU的巨大能力被业界浪费了。</p>

<p>翻译自：<a href="http://bartoszmilewski.com/2013/09/19/edward-chands/">Edward C++Hands</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Adobe公司的首席科学家和移动数字图像组的架构师<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>

  



      </div>
    </div>
    <footer class="footer"><p>
  Copyright &copy; 2013 - ToWriting -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span> -
  <span class="credit">Theme by <a href="https://github.com/barmstrong/octopress-bootstrap">Armstrong</a></span> -
  <span class="credit">本站内容采用<a rel="license" href="http://creativecommons.org/licenses/by/3.0/cn/">知识共享署名 3.0 中国大陆许可协议</a>进行许可</span>
</p>
</footer>
    







<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="/assets/bootstrap/js/bootstrap.min.js"></script>



  </div>
</body>
</html>
