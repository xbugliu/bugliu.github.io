---
layout: post
title: "C++11系列-什么是C++11"
date: 2013-08-01 20:32
comments: true
categories: C++ C++11
keywords: C++11
description: 介绍了什么是C++11
---
##什么是C++0x?
C++0x是C++最新标准标准化过程中的曾用名，在这一系列文章中我们将介绍最新标准添加的一系列新的语言特性。在2011年9月份，C++0x正式由官方发布并命名C++11，现在很多编译器已经支持了部分C++11特性。

C++11包括大量的新特性：主要特征像[lambda][1]表达式和移动语义，实用的类型推导关键字auto，更简单的容器遍历方法，和大量使模板更容易使用的改进。这一系列教程将包含所以以上特性。
##你该关注C++11吗？

很明显，C++11为C++带来了大量的新特性。C++11将修复大量缺陷和降低代码拖沓，比如lambda表达式的支持将使代码更简洁。像移动语义这种特性会提高语言内核的基础效率，使你可以写出更快的代码。对模板系统的优化可以使你更容易写出泛型的代码。

新的标准库同时也会包含新的特性，包括对多线程的支持和优化智能指针，后者将给那些还没用类似于[boost::shared_ptr][2]的人提供更简单的内存管理方法。

我已经开始使用新的C++11特性，并且非常喜欢：新的auto关键字，对模板">>"写法的支持，lambda表达式和新的函数定义语法。

##C++11是如何开发出来的？
C++11的出现，首先要感谢C++标准委员会的辛勤工作，一群来自学术界和工业界的专家，他们的多次会晤攻克难题，终于设计出了一种跨平台，被多种编译器支持，可以生成高效易维护代码的语言。而C++11新标准，就像对灵活强大的C++的一次不可思议的扩展。

##C++11包括什么？
####更易用的语言
使用过C++11后，我发现它提供了大量的基础方法使C++变成了一种更易使用的语言。这不是说它变成了简单的语言--这里有大量的新特性--提供了大量的方法使编程更容易。让我们看一个例子，auto关键字。在C++11中，假如编译器可以从变量的初始化中得到它的类型，那么你不必要指定类型。比如，你可以这样写：
```cpp
int x = 3;
auto y = x;
```
编译器可以推导出y的类型是int。当然，这不是一个证明auto有用的一个闪亮的例子。当使用模板特别是STL时auto很好用。为什么这么说，想象使用一个迭代器(iterator):
```cpp
map<string, string> address_book;
address_book["Alex"] = "webmaster@towriting.com";
//add a bunch of people to address_book
```
现在你想遍历address_book中的元素，要这样做，你需要一个迭代器：
```cpp
map<string, string>::iterator iter = address_book.begin();
```
这是一个恐怖的长类型声明，当你已经知道这个类型的时候。这样是不是简洁多了：
```cpp
auto iter = address_book.begin();
```
代码变得更简单明了，我觉得可读性也更高了，因为模板语法使这一行其它内容变模糊了。这是我特别喜欢的一个特性，我发现它消除了许多头疼和难以追踪的编译错误，节省了时间而没有丢掉表达式的意思。
####区间迭代（range-based for loop)
下面迭代器的例子是C++11提供的一种处理迭代的更好方法，有些人叫做区间迭代（基本上所有的现代语言都支持）。这个例子足够证明这种语法是多么优雅：
```cpp
vector<int> vec;
vec.push_back(10);
vec.push_back(20);

for (int &i: vec)
{
    cout<<i;
}
```
你需要做的就是给出一个变量和要迭代的区间。但是如果你想迭代一个map怎么办？你怎么设置map中值的类型？你知道vector值的类型是int。但map的值类型是pair，通过.first和.second给你提供键和值。但是用auto，你根本无需关心确切类型，你可以简单的写成：
```cpp
for (auto address_entry: address_book)
{
    cout<<address_entry.first<<" "<address_entry.second<<endl;
}
```
这将打印出：
```bash
Alex webmaster@towriting.com
```
这是一个不错的C++11新特性组合用法吧？
####>>(right angle brackets)
我这里还有更易用的优化--在以前的C++标准中，假如你写一个含有其他模板类型的模板：
```cpp
vector<vector<int> > vector_of_int_vectors;
```
你必须在结束的两个'>'之间添加空格。这不仅烦人，而且当你写成>>而没有空格时，你将得到困惑和误导的编译错误信息。产生这种行为的原因是C++词法分析的最大匹配原则（[maximal munch rule][3])。一个好消息是从今往后，你再也不用担心了：
```cpp
vector<vector<int>> vector_of_int_vectors;
```
对，这确实是个小东西，不过却是人工代码克服机器工具的胜利。另外，这样写就不那么丑了。
####多线程
这是第一次，C++11将包含一种内存模型和对应的多线程库，这意味着你将可以编写符合标准的多线程代码。新标准将提供所有的通用线程方法，比如线程、线程局部存储和原子操作。它也提供了一系列有趣的特性：futures和promises。futures和promises的主要思想是，你可以编写代码表示，“这个对象，一个future代码还没计算完的结果"，它将可以在后台计算结果。当这个值需要的时候，你向future发请求，假如这个值准备好了，那就可以得到它，要不然继续等待。

我将在后续的文章中深入探讨多线程。
####还有好多其他的东西
C++11特性的数量是客观的。你可以阅读维基百科里的[C++11][4]页面，而我计划在这一系列文章中深入探索这些特性，包括：

* [如何用auto、decltype和新的函数语法编写更好的代码][10]
* Lambda表达式
* 区间迭代
* 静态表达式
* 右值引用和移动语义
* nullptr和强类型的枚举

###C++11的编译器支持
当然，如果无法使用再好的语言特性又有什么用，好消息是大量的编译器已经开始支持C++11。Apache基金会整理了一个列表，列出了C++11的语言特性和编译器的支持情况：[支持C++11的编译器][5]。假如你对GCC感兴趣，这里有[GCC4.7支持C++11][6]。

有些编译器，比如GCC，不会默认支持这些新特性--例如，为了支持C++11特性，编译时必须指定 -std=c++0x。当然这也是很有用的，你可以在你的项目中选择编译器和语言集。

下一篇：[如何用auto、decltype和新的函数语法编写更好的代码][10]


译者：[toWriting.com][9]；翻译自：[What is C++0x? - Cprogramming.com][8]


  [1]:http://en.cppreference.com/w/cpp/language/lambda
  [2]:http://www.boost.org/doc/libs/1_46_1/libs/smart_ptr/shared_ptr.htm
  [3]:http://en.wikipedia.org/wiki/Maximal_munch
  [4]:http://en.wikipedia.org/wiki/C%2B%2B0x
  [5]:http://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport
  [6]:http://gcc.gnu.org/gcc-4.7/cxx0x_status.html
  [8]:http://www.cprogramming.com/c++11/what-is-c++0x.html
  [9]:http://toWriting.com
  [10]:/blog/2013/08/08/improved-type-inference-in-cpp11/
