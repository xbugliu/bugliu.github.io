<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2014-11-15T20:17:06+00:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    
    <title type="html"><![CDATA[读《摩托车修理店的未来工作哲学》]]></title>
    <link href="http://towriting.com/blog/2014/10/26/shop-class-as-soulcraft-notes/"/>
    
    <updated>2014-10-26T20:50:12+00:00</updated>
    <id>http://towriting.com/blog/2014/10/26/shop-class-as-soulcraft-notes</id>
    
    <content type="html"><![CDATA[<p><a href='http://www.amazon.cn/gp/product/B00KF0MTR2/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00KF0MTR2&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>&lt;摩托车修理店的未来工作哲学></a>是一本大抵关于工作的书。</p>

<h3>薪水的意义</h3>

<p>记得刚毕业的头一年月薪虽少，但内心竟极不安：我每天干的这点事情配这些钱吗？ 到现在又换过两次工作，薪水比刚毕业高了不少，起初还是惶恐自己干的活不配拿这份工资，但随着时间的推移，慢慢麻木不再深思这件事情，将原因归结为人力市场经济的供求关系。现在看到此书中观点，自己可以心安理得的拿这份薪水了：对个体而言，薪水是一种把人限制在一个地方、一定时间做自己并不是特别享受的事情的补偿。</p>

<p>平素里讲的对某工作感兴趣都是相对而言，如果对工作的享受可以达到玩游戏、K歌、美食的程度那一定是自欺欺人。对工作如此兴致的话，想必不要工资也会全心投入，因为平时可以给你带来如此享受的东西都是要钱的。</p>

<p>站在公司的角度看，用薪水吸引人，也是无奈之举。来人是冲着薪水来的，并不是工作本身。</p>

<h3>快乐的工作</h3>

<p>选择程序员的工作无疑是幸福的。程序员号称是当代唯一的手工艺者，互联网公司的办公环境也相对自由，不必忍受像富士康等流水线工作中十年从事一个标准动作的枯燥。</p>

<p>程序员可以快乐工作的条件很简单，有代码可写、在不被打扰的工作环境里思考着软件的结构和编码。回想自己这几年来的3份工作，第一份工作上班并没有太多的事情可做，或者是布置的东西太虚，导致自己内心也空虚，终日惶惶。第二份工作，流程清晰，需求明确，类似于流水线操作不大会出问题。现在的工作，不断有有新挑战，安心下来写代码会很幸福，无奈流程待拨乱反正，每天被打断N次、往返于各种会议与讨论之中。</p>

<p>所以，程序员快乐的编码不容易。</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[互联网公司“24小时待命”的陋习]]></title>
    <link href="http://towriting.com/blog/2014/08/31/24-hour-stand-by/"/>
    
    <updated>2014-08-31T11:47:45+00:00</updated>
    <id>http://towriting.com/blog/2014/08/31/24-hour-stand-by</id>
    
    <content type="html"><![CDATA[<p>24小时待命可能有些夸张，但它确实是以一种不成文的规定存在于一部分互联网公司。记得去年培训时，来自深圳总部的培训老师，自豪的说TX许多部门里员工都是24小时待命，随时应对解决问题。听一些其它公司的朋友讲，他们也有非上班时间被叫回公司的现象。所以24小时待命在一些地方可能形成了习俗。习俗很可怕，哪怕明知是错误的人们也无力反抗，比如裹脚。</p>

<h3>有时真的需要24小时待命</h3>

<p>在一些<code>小而美</code>的团队，早期面对众多的对手，必须有快速的执行力，才可以抢占先机，可以说24小时待命是小团队早期阶段不会死掉的必备条件。</p>

<p>还有一种情况下，相关人员必须随叫随到，就是线上产品出现了严重问题，这是必须要立即处理的，出现了这种问题，相信大家每个人都会很着急，会主动赶回去的。这主要涉及运维和相关开发。</p>

<h3>头痛医脚的昏招</h3>

<p>但除了这两种情况，我看不出这种随意拉员工到公司的习惯有什么好处，相反会极大的侵害员工的积极性。如果在一个非创业期的团队经常出现周末随意拉员工回去加班的情况，那一定是<strong>产品和项目管理出现了严重问题</strong>。拉员工回去对于解决问题，治标不治本，相反还让人产生反感，让人有种疲于奔命之感。</p>

<p>除此之外还有一种情况容易滋生24小时待命文化:老板的淫威。这是我熟识的一个朋友身上发生的事，他经常在坐了一个小时公交快到家门口的时候，被老板叫回去开临时会议，而且一开就到半夜12点了。后来朋友离开了那家公司，想必他不愿意再过那种随叫随到的生活，毕竟家里还有娇妻幼子。</p>

<p>我现在也有些反感，周六早上被拉进微信群讨论产品问题，为什么不周五讨论？如果是紧急问题，我会立马回去处理的，但往往事情并不是那么紧急，往往是因为老板的不经意一句话，产品人员热情的跟进了，于是我们开发人员就到了公司加班。</p>

<h3>陋习的危害</h3>

<p>对于这种24小时待命的习俗，是没有人敢于站出来反对的，因为稍有质疑就会被扣上<code>不积极</code>、<code>没有责任心</code>的帽子，以后在公司就别想混了。所以对于这种东西，大家往往<strong>道路以目</strong>。长久下去，必会影响公司的发展，挫败团队的斗志。</p>

<p>仔细想一下，24小时待命和<code>不积极</code>、<code>没有责任心</code>责任心并没有必然关系，岗位不同，责任不同，就我们开发而言，责任心应该体现在按时保质的完成开发任务（协助处理一些突发事故）。QA的主要责任感是按时完成测试，如果一个团队推行24小时待命，那什么东西是非得半夜过来测的？</p>

<p>相反我觉得员工对&#8221;24小时待命&#8221;文化的逆来顺受是一种逃避和不负责任的做法。没人去深层次的分析和解决产生临时拉人加班的原因，只会使团队滑向更深的深渊。</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[C++14-大餐后的甜点]]></title>
    <link href="http://towriting.com/blog/2014/08/25/cpp-14-dessert/"/>
    
    <updated>2014-08-25T23:15:41+00:00</updated>
    <id>http://towriting.com/blog/2014/08/25/cpp-14-dessert</id>
    
    <content type="html"><![CDATA[<p>这次C++标准委员会快速的通过了最新的C++标准:C++14，要知道C++11可是一再跳票后的产物。此次快速的发布的缘由可能和C++14的改动较小有关，C++之父Bjarne Stroustrup也说，相比与C++11来说，C++14的改动是<a href="http://electronicdesign.com/dev-tools/bjarne-stroustrup-talks-about-c14">谨小甚微的</a>。相信C++14不会给我们带来像C++11那样的震撼，所以我们只能期待下一个版本C++17了。</p>

<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-14-dessert/wg21-timeline.png"></p>

<p>但Bjarne还说了，C++永远是心向开发者的，C++14将给开发者大开方面之门。关于C++14更详细的细节可以看维基百科:<a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14</a>,这里讲下自己感兴趣的特性：</p>

<h3>语言改变</h3>

<p><strong>范型lambda</strong></p>

<p>在C++11下，如果你想要打印出一个数的平方，可能需要这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">square_int</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'><span class="k">auto</span> <span class="n">square_double</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">square_int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">square_int</span><span class="p">(</span><span class="mf">10.1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了保持函数的局部性，我们才选择的lambda，但C++11的lambda却导致多个类型时代码膨胀且重复，此时我们需要回过头来借助全局的模板了。</p>

<p>但C++14可以完美的解决上面的问题，因为C++14中lambda的参数可以用auto代替具体的类型：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">square_int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">square_int</span><span class="p">(</span><span class="mf">10.1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>auto返回类型</strong></p>

<p>C++11支持auto关键字，用于变量的自动类型推导。但由于时间限制，C++标准委员会并没有让auto也支持函数的返回值类型自动推导，现在C++14支持了。这将会在返回类内部类型的成员函数书写上减少好多工作量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Wiget</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">Status</span><span class="p">{</span><span class="n">show</span><span class="p">,</span> <span class="n">hide</span><span class="p">}</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">getStatus</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">auto</span> <span class="n">Wiget</span><span class="o">::</span><span class="n">getStatus</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">show</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>编译器支持</h3>

<p>曾经被标准折磨的死去活来的编译器如今越挫越勇。标准出来的快，编译器支持的更快。CLang（3.4）半年前就宣布已完全支持C++14(draft)特性（语言和库）。本人电脑上的GCC4.9.1也已部分支持C++14特性。但公司的开发环境要支持C++14可就难了。</p>

<p>参考：</p>

<p><a href="https://isocpp.org/std/status">https://isocpp.org/std/status</a></p>

<p><a href="http://cpprocks.com/c1114-compiler-and-library-shootout/">http://cpprocks.com/c1114-compiler-and-library-shootout/</a></p>

<p><a href="http://cpprocks.com/an-overview-of-c14-language-features/">http://cpprocks.com/an-overview-of-c14-language-features/</a></p>

<p><a href="http://llvm.org/releases/3.4/tools/clang/docs/ReleaseNotes.html">http://llvm.org/releases/3.4/tools/clang/docs/ReleaseNotes.html</a></p>

<p><a href="https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/">https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/</a></p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[实现无锁算法的常见陷阱]]></title>
    <link href="http://towriting.com/blog/2014/08/18/common-pitfalls-in-writing-lock-free-algorithms/"/>
    
    <updated>2014-08-18T23:34:52+00:00</updated>
    <id>http://towriting.com/blog/2014/08/18/common-pitfalls-in-writing-lock-free-algorithms</id>
    
    <content type="html"><![CDATA[<h2>翻译自：<a href="http://blog.memsql.com/common-pitfalls-in-writing-lock-free-algorithms/">Common Pitfalls in Writing Lock-Free Algorithms</a></h2>

<p>通常，只要两个操作之间的步骤是有穷的，一个多线程算法就认为可以实现为无锁(lock-free)。理论上无锁算法也早已被证明，看起来实现一个无锁算法也很简单。但其实不然，每一步都隐藏着陷阱：并发的线程可以修改共享的对象，甚至在执行一个操作时线程可以突然暂停或中止，而这是另一个线程当作好像若无其事。</p>

<p>线程同步是多线程程序设计的核心，传统的做法上就是代码临界区上加锁。锁可以防止多个线程同一时间进入临界区代码。在高度并发的程序里，锁可能成为严重的性能瓶颈。无锁编程的目标是不用锁也能解决并发问题。无锁编程一般依赖的是原子操作，比如“compare-and-swap”<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>原子的执行下面的操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="mi">1</span> <span class="kt">bool</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="n">Value</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">Value</span> <span class="n">oldVal</span><span class="p">,</span> <span class="n">Value</span> <span class="n">newVal</span><span class="p">){</span>
</span><span class='line'><span class="mi">2</span>     <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span> <span class="o">==</span> <span class="n">oldVal</span><span class="p">){</span>
</span><span class='line'><span class="mi">3</span>         <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">newVal</span><span class="p">;</span>
</span><span class='line'><span class="mi">4</span>         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="mi">5</span>     <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'><span class="mi">6</span>         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'><span class="mi">7</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">8</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用无锁算法的最大缺陷是：</p>

<ul>
<li>无锁算法并不总是可实现的</li>
<li>无锁算法的代码很难写</li>
<li>写出正确的无锁算法代码更是难如登天</li>
</ul>


<p>为了证明以上三点，我们来看一个错误实现的一个无锁栈(lock-free stack)，可能大部分人第一次都会写出这样保护这些错误无锁栈。这个无锁栈算法主要是使用一个链表(linked-list)来存放节点，并用<code>CompareAndSwap</code>来修改链表的表头。 Push一个元素时，我们首先创建一个节点保存数据，并将这个节点设为栈顶，并使用<code>CompareAndSwap</code>将原栈顶指向新的元素。<code>CompareAndSwap</code>操作保证只有我们的新节点指向老的栈顶节点，才会替换老的栈顶（因为多线程可能改变老的栈顶）。当Pop一个元素时，我们快照当前的栈顶节点，然后替换当前的栈顶节点到下一个节点。我们再一次使用<code>CompareAndSwap</code>保证替换的节点等于快照的节点。</p>

<p>C++代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'> <span class="mi">1</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Entry</span><span class="o">&gt;</span>
</span><span class='line'> <span class="mi">2</span> <span class="k">class</span> <span class="nc">LockFreeStack</span><span class="p">{</span>
</span><span class='line'> <span class="mi">3</span>     <span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
</span><span class='line'> <span class="mi">4</span>         <span class="n">Entry</span><span class="o">*</span> <span class="n">entry</span><span class="p">;</span>
</span><span class='line'> <span class="mi">5</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span><span class='line'> <span class="mi">6</span>     <span class="p">};</span>
</span><span class='line'> <span class="mi">7</span>
</span><span class='line'> <span class="mi">8</span>     <span class="n">Node</span><span class="o">*</span> <span class="n">m_head</span><span class="p">;</span>
</span><span class='line'> <span class="mi">9</span>
</span><span class='line'><span class="mi">10</span>     <span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">Entry</span><span class="o">*</span> <span class="n">e</span><span class="p">){</span>
</span><span class='line'><span class="mi">11</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span>
</span><span class='line'><span class="mi">12</span>         <span class="n">n</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
</span><span class='line'><span class="mi">13</span>         <span class="k">do</span><span class="p">{</span>
</span><span class='line'><span class="mi">14</span>             <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">15</span>         <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_head</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
</span><span class='line'><span class="mi">16</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">17</span>
</span><span class='line'><span class="mi">18</span>     <span class="n">Entry</span><span class="o">*</span> <span class="nf">Pop</span><span class="p">(){</span>
</span><span class='line'><span class="mi">19</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">old_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">20</span>         <span class="n">Entry</span><span class="o">*</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="mi">21</span>         <span class="k">do</span><span class="p">{</span>
</span><span class='line'><span class="mi">22</span>             <span class="n">old_head</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">23</span>             <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span><span class='line'><span class="mi">24</span>                 <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="mi">25</span>             <span class="p">}</span>
</span><span class='line'><span class="mi">26</span>         <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_head</span><span class="p">,</span> <span class="n">old_head</span><span class="p">,</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
</span><span class='line'><span class="mi">27</span>
</span><span class='line'><span class="mi">28</span>         <span class="n">result</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
</span><span class='line'><span class="mi">29</span>         <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">30</span>         <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="mi">31</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">32</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>遗憾的是，这个无锁栈充满的错误：</p>

<h3>Segfault</h3>

<p>Push操作分配内存保存节点信息，Pop操作释放这些内存。然而，线程T1在顺序执行22行和26行之间的时间里，另一个线程T2可能已经释放了这个节点，然后程序Crash了。</p>

<h3>Corruption</h3>

<p>仅仅对比新值与老值是否相等，<code>CompareAndSwap</code>方法并不能保证是否值发生了变化。假如快照在22行的值，被修改了，然后又被恢复了，然后<code>CompareAndSwap</code>会成功。这就是著名的<strong>ABA问题</strong>。假如栈中前两个节点是A和C，如果以下面的序列操作：</p>

<ul>
<li>线程1执行Pop，并在22行读到了m_head(<strong>A</strong>)，在26行读到了old_head->next(<strong>C</strong>)，然后突然阻塞在执行在<code>CompareAndSwap</code>之前。</li>
<li>线程2执行pop，删掉节点<strong>A</strong>。</li>
<li>线程2调用push，push了一个新节点<strong>B</strong>。</li>
<li>线程2又调用一次push，这次push的新节点正好占用了原来节点<strong>A</strong>的内存。</li>
<li>线程1被唤醒，调用<code>CompareAndSwap</code>。</li>
</ul>


<p>然后26行的<code>CompareAndSwap</code>会成功，虽然m_head已经被改变3次了，因为它只检测old_head是否等于m_head。这是有问题的，因为新的栈顶本应指向<strong>B</strong>，然而却指向了<strong>C</strong>。</p>

<h3>Not lock-free</h3>

<p>C++标准并不保证new和delete是lock-free的。一个无锁的数据结构去调用非无锁的库函数不是什么好主意，所以我们需要一个无锁的内存分配子。</p>

<h3>Data races</h3>

<p>当一个线程向内存中写入数据，而另一个线程同时从相同的内存读数据时，所产生的结果是未定义的，除非使用std::atomic。读和写操作都必须是原子的。在C++11以前一个通用的方法是使用<strong>volatile</strong>关键字来生命原子变量，然而这个关键字有很大的<a href="http://software.intel.com/en-us/blogs/2007/11/30/volatile-almost-useless-for-multi-threaded-programming">缺陷</a>。</p>

<p>在我们的例子中，多个线程读栈顶指针可能会引起竞争，push和pop操作都有可能，因为其它线程可能在修改他。</p>

<h3>Memory reordering</h3>

<p>印象中，代码会按照我们指定的顺序执行，最少也会满足”<a href="http://en.wikipedia.org/wiki/Happened-before">happens before</a>“关系。不幸的是，不管理论还是实际上，下面代码的执行可能出现x,y都是0的结果。:</p>

<p><img class="pull-right" src="http://towriting.com/images/posts/common-pitfalls-in-writing-lock-free-algorithms/memory-reordering.png"></p>

<p>C++11以前标准对于多线程是讳莫如深的，所以编译器的优化是着眼于单线程的。上面的代码，交换执行顺序，并不会影响单线程中程序的语义。所以可能会产生这种结果。</p>

<h2>如何写正确的lock-free栈</h2>

<p>上面大部分问题都有多种解决方案，这里我会把自己工作中使用的方法描述出来。</p>

<h3>Segfault</h3>

<p>解引用节点之前，必须确保该节点没有被删掉。每一个线程都有一个全局可见的&#8221;hazard pointer&#8221;。当访问一个节点之前，会先设置Hazard pointer执行这个节点。只要设置过Hazard pointer就可以保证这个节点此时还是栈顶节点。如果其它线程此时移除这个栈顶节点，要检测没有Hazard pointer指向这个节点才能清除节点的内存。</p>

<h3>Corruption</h3>

<p>解决ABA问题的一个方法是确保栈顶不会有同样的值两次。我们使用“tagged pointers”来确保栈头值的唯一。一个“tagged pointers”包含一个指针和64位计数器。每当栈顶变化，计数器加一。</p>

<h3>Not lock-free</h3>

<h3>Data races</h3>

<p>我们目前使用的是boost::atomic。现在我们使用gcc4.6也已经支持std::atomic，但实现的效率没有boost高。在gcc4.6中，所有需要原子操作的地方都被应用了memory barriers，即使本不必使用的地方。</p>

<h3>Memory reordering</h3>

<p>C++11为原子操作提供了一种新的内存模型和内存序语义，以解决乱序的问题。CompareAndSwap需要顺序一致性(sequentially consistent)的语义保证。顺序一致性意味着所有的线程以一种一致的次序执行操作。事实证明hazard pointers也一样需要顺序一致性保证内存语义。
如果不使用内存一致性，下面这种情况下会有问题：</p>

<ul>
<li>线程1准备Pop操作，读取了栈顶节点</li>
<li>线程1将当前节点写到hazard pointer中</li>
<li>线程1再次读取栈顶指针</li>
<li>线程2将栈顶指针移走，并传递到垃圾收集线程</li>
<li>垃圾收集器扫描所有的hazard pointer节点，因为没有顺序一致性，可能看不到线程1的hazard pointer已经指向了这个节点</li>
<li>垃圾收集器删除了这个节点</li>
<li>线程1解引用这个节点，然后程序Crash</li>
</ul>


<p>而如果有顺序一致性应用到hazard pointer的赋值和节点的修改，竞争就不会发生了。因为任意两个操作，所有线程看到的顺序都是一样的。如果线程2先移除这个节点，那么线程1第二次读时会看到一个不同的节点，也就不会去解引用它。假如线程1先将节点写到hazard pointer中，则垃圾收集器肯定可以看到这个值而不会去删除它。</p>

<h2>性能</h2>

<p>到现在我们解决了所有的问题。让我们看一下性能。测试使用的是一台8核Intel&reg; Xeon&reg; 处理器。每个线程的工作是随机的执行数量几乎相等的Push和Pop操作。每个线程不加限制的执行机器可以处理的操作。</p>

<p><img class="pull-right" src="http://towriting.com/images/posts/common-pitfalls-in-writing-lock-free-algorithms/chart.svg"></p>

<p>我们修改栈顶的次数越多，CompareAndSwap失败的次数也会越多。一个简单有效的减少失败的方法是失败后Sleep一下，这可以调节Stack可以高效的处理数据。下面是每次失败后Sleep(250)的数据：</p>

<p><img class="pull-right" src="http://towriting.com/images/posts/common-pitfalls-in-writing-lock-free-algorithms/chart1.svg"></p>

<p>太好了，增加Sleep后栈的吞吐量增加了7倍。并且Sleep减少的处理器的消耗。让我们看一下处理器的使用情况：</p>

<p>加锁的栈：</p>

<p><img class="pull-right" src="http://towriting.com/images/posts/common-pitfalls-in-writing-lock-free-algorithms/htop_mutex.png"></p>

<p>无锁的栈，不加Sleep:</p>

<p><img class="pull-right" src="http://towriting.com/images/posts/common-pitfalls-in-writing-lock-free-algorithms/htop_lockfree.png"></p>

<p>无锁的栈，Sleep(250):</p>

<p><img class="pull-right" src="http://towriting.com/images/posts/common-pitfalls-in-writing-lock-free-algorithms/htop_usleep.png"></p>

<p>看起来无锁更好？等等，锁一样可以达到好的性能，我们不用std::mutex，我们使用Sleep(250)的自旋锁：
<img class="pull-right" src="http://towriting.com/images/posts/common-pitfalls-in-writing-lock-free-algorithms/chart2.svg"></p>

<h2>结果</h2>

<p>大量数据时，额外的线程会降低吞吐量。Sleep可以降低操作冲突，增加吞吐量的同时减小处理器消耗。3个线程以上的性能没有变化。单线程是性能最佳的。</p>

<h2>结论</h2>

<p>无锁不会阻碍进度，但也并不会提高效率。当你想在你的项目中使用无锁算法时，切记要衡量值不值的-性能还有复杂度。</p>

<h2>代码</h2>

<p>加锁的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'> <span class="mi">1</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span>
</span><span class='line'> <span class="mi">2</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stack</span><span class="o">&gt;</span>
</span><span class='line'> <span class="mi">3</span>
</span><span class='line'> <span class="mi">4</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span><span class='line'> <span class="mi">5</span> <span class="k">class</span> <span class="nc">LockedStack</span><span class="p">{</span>
</span><span class='line'> <span class="mi">6</span> <span class="k">public</span><span class="o">:</span>
</span><span class='line'> <span class="mi">7</span>     <span class="kt">void</span> <span class="n">Push</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">entry</span><span class="p">){</span>
</span><span class='line'> <span class="mi">8</span>         <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
</span><span class='line'> <span class="mi">9</span>         <span class="n">m_stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
</span><span class='line'><span class="mi">10</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">11</span>
</span><span class='line'><span class="mi">12</span>     <span class="c1">// For compatability with the LockFreeStack interface,</span>
</span><span class='line'><span class="mi">13</span>     <span class="c1">// add an unused int parameter.</span>
</span><span class='line'><span class="mi">14</span>     <span class="c1">//</span>
</span><span class='line'><span class="mi">15</span>     <span class="n">T</span><span class="o">*</span> <span class="n">Pop</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
</span><span class='line'><span class="mi">16</span>         <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
</span><span class='line'><span class="mi">17</span>         <span class="nf">if</span><span class="p">(</span><span class="n">m_stack</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span><span class='line'><span class="mi">18</span>             <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'><span class="mi">19</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">20</span>         <span class="n">T</span><span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">m_stack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span><span class='line'><span class="mi">21</span>         <span class="n">m_stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'><span class="mi">22</span>         <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="mi">23</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">24</span>
</span><span class='line'><span class="mi">25</span> <span class="k">private</span><span class="o">:</span>
</span><span class='line'><span class="mi">26</span>     <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">m_stack</span><span class="p">;</span>
</span><span class='line'><span class="mi">27</span>     <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_mutex</span><span class="p">;</span>
</span><span class='line'><span class="mi">28</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lock-Free的：
(垃圾收集相关的代码没贴出来）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'> <span class="mi">1</span> <span class="k">class</span> <span class="nc">LockFreeStack</span><span class="p">{</span>
</span><span class='line'> <span class="mi">2</span> <span class="k">public</span><span class="o">:</span>
</span><span class='line'> <span class="mi">3</span>     <span class="c1">// The elements we wish to store should inherit Node</span>
</span><span class='line'> <span class="mi">4</span>     <span class="c1">//</span>
</span><span class='line'> <span class="mi">5</span>     <span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
</span><span class='line'> <span class="mi">6</span>         <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">next</span><span class="p">;</span>
</span><span class='line'> <span class="mi">7</span>     <span class="p">};</span>
</span><span class='line'> <span class="mi">8</span>
</span><span class='line'> <span class="mi">9</span>     <span class="c1">// Unfortunately, there is no platform independent way to</span>
</span><span class='line'><span class="mi">10</span>     <span class="c1">// define this class.  The following definition works in</span>
</span><span class='line'><span class="mi">11</span>     <span class="c1">// gcc on x86_64 architectures</span>
</span><span class='line'><span class="mi">12</span>     <span class="c1">//</span>
</span><span class='line'><span class="mi">13</span>     <span class="k">class</span> <span class="nc">TaggedPointer</span><span class="p">{</span>
</span><span class='line'><span class="mi">14</span>     <span class="k">public</span><span class="o">:</span>
</span><span class='line'><span class="mi">15</span>         <span class="n">TaggedPointer</span><span class="p">()</span><span class="o">:</span> <span class="n">m_node</span><span class="p">(</span><span class="n">nullptr</span><span class="p">),</span> <span class="n">m_counter</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="mi">16</span>
</span><span class='line'><span class="mi">17</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">GetNode</span><span class="p">(){</span>
</span><span class='line'><span class="mi">18</span>             <span class="k">return</span> <span class="n">m_node</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class='line'><span class="mi">19</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">20</span>
</span><span class='line'><span class="mi">21</span>         <span class="kt">uint64_t</span> <span class="n">GetCounter</span><span class="p">(){</span>
</span><span class='line'><span class="mi">22</span>             <span class="k">return</span> <span class="n">m_counter</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class='line'><span class="mi">23</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">24</span>
</span><span class='line'><span class="mi">25</span>         <span class="kt">bool</span> <span class="n">CompareAndSwap</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">oldNode</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">oldCounter</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">newCounter</span><span class="p">){</span>
</span><span class='line'><span class="mi">26</span>             <span class="kt">bool</span> <span class="n">cas_result</span><span class="p">;</span>
</span><span class='line'><span class="mi">27</span>             <span class="n">__asm__</span> <span class="n">__volatile__</span>
</span><span class='line'><span class="mi">28</span>             <span class="p">(</span>
</span><span class='line'><span class="mi">29</span>                 <span class="s">&quot;lock;&quot;</span>           <span class="c1">// This makes the following instruction atomic (it is non-blocking)</span>
</span><span class='line'><span class="mi">30</span>                 <span class="s">&quot;cmpxchg16b %0;&quot;</span>  <span class="c1">// cmpxchg16b sets ZF on success</span>
</span><span class='line'><span class="mi">31</span>                 <span class="s">&quot;setz       %3;&quot;</span>  <span class="c1">// if ZF set, set cas_result to 1</span>
</span><span class='line'><span class="mi">32</span>
</span><span class='line'><span class="mi">33</span>                 <span class="o">:</span> <span class="s">&quot;+m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="s">&quot;+a&quot;</span> <span class="p">(</span><span class="n">oldNode</span><span class="p">),</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">oldCounter</span><span class="p">),</span> <span class="s">&quot;=q&quot;</span> <span class="p">(</span><span class="n">cas_result</span><span class="p">)</span>
</span><span class='line'><span class="mi">34</span>                 <span class="o">:</span> <span class="s">&quot;b&quot;</span> <span class="p">(</span><span class="n">newNode</span><span class="p">),</span> <span class="s">&quot;c&quot;</span> <span class="p">(</span><span class="n">newCounter</span><span class="p">)</span>
</span><span class='line'><span class="mi">35</span>                 <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span>
</span><span class='line'><span class="mi">36</span>             <span class="p">);</span>
</span><span class='line'><span class="mi">37</span>             <span class="k">return</span> <span class="n">cas_result</span><span class="p">;</span>
</span><span class='line'><span class="mi">38</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">39</span>     <span class="k">private</span><span class="o">:</span>
</span><span class='line'><span class="mi">40</span>         <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">m_node</span><span class="p">;</span>
</span><span class='line'><span class="mi">41</span>         <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">m_counter</span><span class="p">;</span>
</span><span class='line'><span class="mi">42</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">43</span>     <span class="c1">// 16-byte alignment is required for double-width</span>
</span><span class='line'><span class="mi">44</span>     <span class="c1">// compare and swap</span>
</span><span class='line'><span class="mi">45</span>     <span class="c1">//</span>
</span><span class='line'><span class="mi">46</span>     <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
</span><span class='line'><span class="mi">47</span>
</span><span class='line'><span class="mi">48</span>     <span class="kt">bool</span> <span class="nf">TryPushStack</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">entry</span><span class="p">){</span>
</span><span class='line'><span class="mi">49</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
</span><span class='line'><span class="mi">50</span>         <span class="kt">uint64_t</span> <span class="n">oldCounter</span><span class="p">;</span>
</span><span class='line'><span class="mi">51</span>
</span><span class='line'><span class="mi">52</span>         <span class="n">oldHead</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetNode</span><span class="p">();</span>
</span><span class='line'><span class="mi">53</span>         <span class="n">oldCounter</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetCounter</span><span class="p">();</span>
</span><span class='line'><span class="mi">54</span>         <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'><span class="mi">55</span>         <span class="k">return</span> <span class="n">m_head</span><span class="p">.</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">oldCounter</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">oldCounter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="mi">56</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">57</span>
</span><span class='line'><span class="mi">58</span>     <span class="kt">bool</span> <span class="nf">TryPopStack</span><span class="p">(</span><span class="n">Node</span><span class="o">*&amp;</span> <span class="n">oldHead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threadId</span><span class="p">){</span>
</span><span class='line'><span class="mi">59</span>         <span class="n">oldHead</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetNode</span><span class="p">();</span>
</span><span class='line'><span class="mi">60</span>         <span class="kt">uint64_t</span> <span class="n">oldCounter</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetCounter</span><span class="p">();</span>
</span><span class='line'><span class="mi">61</span>         <span class="k">if</span><span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">){</span>
</span><span class='line'><span class="mi">62</span>             <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="mi">63</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">64</span>         <span class="n">m_hazard</span><span class="p">[</span><span class="n">threadId</span><span class="o">*</span><span class="mi">8</span><span class="p">].</span><span class="n">store</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
</span><span class='line'><span class="mi">65</span>         <span class="k">if</span><span class="p">(</span><span class="n">m_head</span><span class="p">.</span><span class="n">GetNode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">oldHead</span><span class="p">){</span>
</span><span class='line'><span class="mi">66</span>             <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'><span class="mi">67</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">68</span>         <span class="k">return</span> <span class="n">m_head</span><span class="p">.</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">oldCounter</span><span class="p">,</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">),</span> <span class="n">oldCounter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="mi">69</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">70</span>
</span><span class='line'><span class="mi">71</span>     <span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">entry</span><span class="p">){</span>
</span><span class='line'><span class="mi">72</span>         <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span><span class='line'><span class="mi">73</span>             <span class="k">if</span><span class="p">(</span><span class="n">TryPushStack</span><span class="p">(</span><span class="n">entry</span><span class="p">)){</span>
</span><span class='line'><span class="mi">74</span>                 <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="mi">75</span>             <span class="p">}</span>
</span><span class='line'><span class="mi">76</span>             <span class="n">usleep</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
</span><span class='line'><span class="mi">77</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">78</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">79</span>
</span><span class='line'><span class="mi">80</span>     <span class="n">Node</span><span class="o">*</span> <span class="nf">Pop</span><span class="p">(</span><span class="kt">int</span> <span class="n">threadId</span><span class="p">){</span>
</span><span class='line'><span class="mi">81</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'><span class="mi">82</span>         <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span><span class='line'><span class="mi">83</span>             <span class="k">if</span><span class="p">(</span><span class="n">TryPopStack</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">threadId</span><span class="p">)){</span>
</span><span class='line'><span class="mi">84</span>                 <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'><span class="mi">85</span>             <span class="p">}</span>
</span><span class='line'><span class="mi">86</span>             <span class="n">usleep</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
</span><span class='line'><span class="mi">87</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">88</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">89</span>
</span><span class='line'><span class="mi">90</span> <span class="k">private</span><span class="o">:</span>
</span><span class='line'><span class="mi">91</span>     <span class="n">TaggedPointer</span> <span class="n">m_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">92</span>     <span class="c1">// Hazard pointers are separated into different cache lines to avoid contention</span>
</span><span class='line'><span class="mi">93</span>     <span class="c1">//</span>
</span><span class='line'><span class="mi">94</span>     <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">m_hazard</span><span class="p">[</span><span class="n">MAX_THREADS</span><span class="o">*</span><span class="mi">8</span><span class="p">];</span>
</span><span class='line'><span class="mi">95</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>硬件相关，Windows已提供函数InterlockedCompareExchange<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[读《寻找家园》]]></title>
    <link href="http://towriting.com/blog/2014/07/21/review-xzjy/"/>
    
    <updated>2014-07-21T23:51:23+00:00</updated>
    <id>http://towriting.com/blog/2014/07/21/review-xzjy</id>
    
    <content type="html"><![CDATA[<p>诚然，这是一本文辞优美的自传集。自以为博学杂收，但此前竟从未听说过高尔泰，概和主流媒介打压有关。80后的我，有幸避过了那段岁月，所以对于书中，高先生凄苦的人生，只能报以同情，很难产生共鸣。高先生悲惨的际遇和余华《活着》中的福贵的一生很像，波诡云谲的时代，至亲“莫名其妙”的离去，种种不公平待遇，最后还活着，随波逐流。</p>

<p>但逆水的鱼，这是天生的命运。高先生最终去了标榜自由平等的米国，广阔天地，但难以大有作为，老来无依，故国不堪回首，所以整理出这<a href='http://www.amazon.cn/gp/product/B00K0E4NFO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00K0E4NFO&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>寻找家园</a>来。</p>

<p>读此书，看高尔泰传奇一生，随便拈来一件小事都是我们当代常人一生难逢的际遇，而且即使选中了你我，也并非你我可以承受。反观我们的生活，钢筋水泥的城市，一成不变的工作，三两个不勾心斗角的同事，做着不着调的工作，两点一线，直至老去，有幸的留下荒冢一堆，无运的骨灰都不是自己的！</p>

<p>都市中渺小的我，搞不清高尔泰追求的自由为何物，自由和活着孰重孰轻。年轻的高尔泰似乎没有追求自由的能力，只能任命运摆弄，想着往上爬的，却成了别人的梯子，80年代后，环境宽松，如果懂的迎合，以他的名望和学识，想必日子不会艰难，也不会老来流落米国。</p>

<p>在我看来，自由是，不妨碍他人的前提下，随意做自己想做的事情。所以活着是自由的前提，“不自由，毋宁死”，死了不还是得不到自由！如果高尔泰可以顺从，是否可以摆脱暴力的关照，安心做自己喜欢的事情呢，这不就实现了他的自由了吗？</p>

<p>这种想法有些小人之心度君子之腹了，高尔泰是不会仰人鼻息的!</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[关于重构的一些想法]]></title>
    <link href="http://towriting.com/blog/2014/07/08/evil-refactor/"/>
    
    <updated>2014-07-08T00:26:25+00:00</updated>
    <id>http://towriting.com/blog/2014/07/08/evil-refactor</id>
    
    <content type="html"><![CDATA[<p>很早之前听说过这样一个故事：</p>

<blockquote><p>一个漂亮的女子与马戏团的小丑坠入爱河，并迅速结婚。小丑十分珍惜得来的幸福，努力挣钱，瞒着女子做了整容手术，为了给女子惊喜。整容后的小丑出现在女子眼前时，女子提出离婚，因为他喜欢的是原来长的并不帅的小丑。</p></blockquote>

<p>一个项目重构的动机(目的)无外乎两种：1. 给用户带来更好的体验、2. 项目代码失控（难以维护、添加新特性）。重构必然导致变化，用户接受现在的产品，重构后的版本并不一定喜欢。至于极端，哪怕重构后的版本比老版本好的多，也会有用户高声喊：给我老版本。这和小丑的故事一样了，哪怕整容帅的像郭德纲一样，女子照样甩一甩衣袖走了。</p>

<p>现实生活中的重构往往是程序员自己发起的，Martin Fowler都有一本书起名为《重构》，并被许多程序员奉为圭臬。程序员的初衷是好的，但往往会低估重构的难度，项目越大耦合越多，往往牵一发而动全身，当老板跑过来问你进度时，你只能回以尴尬的笑，因为进度会进入无法掌控的地步。最近自己差点陷入这种进退维谷的境地，还好项目比较小，最后算是挺了过来。</p>

<p>但大的项目移筋动骨的重构就真的很难成功了。记得在核新软件的时候，项目庞大臃肿，添加新功能困难，软件的开发与执行效率都很低。记得一段时间内，大家重构的呼声很高，不过最后不了了之，因为工程浩大、重构后的兼容性、重构后软件多长时间可以稳定、重构后版本的测试等等需要考虑的各种问题已不单单是几个开发可以掌控的了的。而同时产品的需求还是不会减少，因为产品根本不关心软件的技术架构、可靠性、可维护性等等。</p>

<p>产品不关心重构是正常的。确实，一个可以正常运行，用户没有太多投诉、谨慎的编码也不会出太大问题的项目为什么要重构呢？假如某地发现了一个煤矿，第一批人来开采，一年时间采掉了50%的煤; 第二批人来了，煤已不那么好采，必须小心谨慎的对待，因为矿难不断，不过还好花了两年时间采到了30%的煤; 第三批人来了，矿上留下的全是前人留下的坑，无处落脚，须将前面的坑填掉，才能保证采得到煤，先花费了三年填坑，最后又花了一年时间采到了10%的煤。软件开发也一样，软件的生命期有限，是否需要花费人力将软件重构的完美值得商榷，可能重构完成之日，为项目终结之时，留下完美的架构与设计又有何用呢？</p>

<p>既然程序员呼吁重构的理由是，项目代码难以维护，那为什么不从一开始写出易维护的代码？</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Linux下开启TRIM]]></title>
    <link href="http://towriting.com/blog/2014/06/28/archlinux-trim/"/>
    
    <updated>2014-06-28T21:55:12+00:00</updated>
    <id>http://towriting.com/blog/2014/06/28/archlinux-trim</id>
    
    <content type="html"><![CDATA[<p>新买得一块SSD，听说开启TRIM才能更好的发挥SSD的性能，Linux并没有默认开启TRIM，但开启还是比较简单。</p>

<p>首先要检测SSD是否支持TRIM:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo hdparm -I /dev/sda <span class="p">|</span> grep <span class="s2">&quot;TRIM supported&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果支持则会出现：&#8221;Data Set Management TRIM supported&#8221;</p>

<p>如果SSD支持TRIM, 则可以开启TRIM了, 这里介绍常用的两种方法。</p>

<h3>方法1：修改<a href="http://en.wikipedia.org/wiki/Fstab">fstab</a>, 添加discard属性</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo vim /etc/fstab
</span></code></pre></td></tr></table></div></figure>


<p>下面是我机器上fstab的配置</p>

<blockquote><p>UUID=27dd31b4-8aa4-4043-b921-540a312c056c       /               ext4            rw,relatime,data=ordered,<strong>discard</strong>        0 1</p>

<p>UUID=42f79958-0776-4b2f-8aa3-db827bf257b6       /home           ext4            rw,relatime,data=ordered,<strong>discard</strong>        0 2</p></blockquote>

<h3>方法2：使用fstrim定期执行trim任务</h3>

<p>以我用的archlinux为例，首先安装并运行<a href="http://en.wikipedia.org/wiki/Cron">cron</a>服务：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo pacman -S cronie
</span><span class='line'>sudo systemctl start cronie
</span><span class='line'>sudo systemctl <span class="nb">enable </span>cronie
</span></code></pre></td></tr></table></div></figure>


<p>然后创建一个任务配置:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo gedit /etc/cron.daily/trim
</span></code></pre></td></tr></table></div></figure>


<p>并将下面的内容拷贝到里面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'><span class="nv">LOG</span><span class="o">=</span>/var/log/trim.log
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;*** $(date -R) ***&quot;</span> &gt;&gt; <span class="nv">$LOG</span>
</span><span class='line'>fstrim -v / &gt;&gt; <span class="nv">$LOG</span>
</span><span class='line'>fstrim -v /home &gt;&gt; <span class="nv">$LOG</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考：</p>

<ol>
<li><p><a href="http://www.webupd8.org/2013/01/enable-trim-on-ssd-solid-state-drives.html">http://www.webupd8.org/2013/01/enable-trim-on-ssd-solid-state-drives.html</a></p></li>
<li><p><a href="https://wiki.archlinux.org/index.php/Solid_State_Drives">https://wiki.archlinux.org/index.php/Solid_State_Drives</a></p></li>
</ol>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Dock项目个人总结]]></title>
    <link href="http://towriting.com/blog/2014/05/03/dock-project-experience/"/>
    
    <updated>2014-05-03T22:55:00+00:00</updated>
    <id>http://towriting.com/blog/2014/05/03/dock-project-experience</id>
    
    <content type="html"><![CDATA[<p>Dock说白了是电脑桌面上常驻的一个工作区，Dock的目的是占领用户的桌面，况且我们追赶的团队和追赶我们的团队都已做出Dock，所以应用宝必须也要做。关于应用宝Dock的具体进度、功能与界面不做介绍，现在从开发的角度讲一讲Dock项目两个月来的一点体会。</p>

<p>自己的角色：负责逻辑部分接口和整体框架的设计，及相关功能开发。</p>

<h3>可圈可点之处：</h3>

<hr />

<p><strong>1. 逻辑与界面完全分离</strong></p>

<p>Dock项目应该是，我们团队第一次在多人协作下，采用了界面与逻辑分离的开发方案。这样的好处是：降低了耦合，使开发简单化（做UI的无需关心逻辑，反之依然）。当然这样做必然会增加一些工作量，尤其是后来界面和逻辑分属不同进程，逻辑的接口必须做IPC转发。</p>

<p>逻辑与界面分离的方案，最重要的是定义好接口。</p>

<p><strong>2. 最小完备接口</strong></p>

<p>最小完备接口是我一贯主张的一种接口风格，因为一旦增加冗余的接口，并被客户端代码使用，那就很难移除了，势必造成接口膨胀。项目期间，主管提出接口要提前考虑、功能要丰富的建议，不过自己还是坚持了自己想法。因为加一个接口容易，去掉一个就难了，好比韩愈曾说的，从善如登、从恶如崩。</p>

<h3>败笔之处</h3>

<hr />

<p><strong>1. 任务分配粗略</strong></p>

<p>需求接下来，四个人开始做，一开始定下两个人做界面另两个做逻辑，但没有细化具体的产品细节、开发难度耗时等，也没有分配具体谁做什么事情，只是口头上大概分了一下。这极易导致任务分配不均和任务遗漏的现象。好的方法应该是，细化任务并明确责任，公诸于众。但团队积习如此，非朝夕可改。</p>

<p><strong>2. 线程的滥用</strong></p>

<p>线程滥用当然指逻辑部分。从进入应用宝团队初期，就发现代码中线程滥用，好似每天不开几个线程吃不下饭一般。所以最初Dock的逻辑代码的主框架考虑到了这点，以使后面添加具体业务时无需创建线程。但后期，需求的演变和功能的要求迫使不得不又增加了几个线程，其实有些线程是非必须的。而这些不必要的线程，往往会滋生一批Bug。</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[读《苏东坡传》]]></title>
    <link href="http://towriting.com/blog/2014/04/27/the-gay-genius-review/"/>
    
    <updated>2014-04-27T21:52:00+00:00</updated>
    <id>http://towriting.com/blog/2014/04/27/the-gay-genius-review</id>
    
    <content type="html"><![CDATA[<p>昨天在kindle上读完了<a href='http://www.amazon.cn/gp/product/B00D7X84MS/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00D7X84MS&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>苏东坡传</a>，本以为千年前人物的传记，必简短：年代久远，事迹佚失，有甚可写。谁知此书篇幅不小，断断续续一月才读完，书中夹杂着大量苏东坡的文学作品：诗词和书信等，吾久不读古文，美感失，只好略过。</p>

<p>苏东坡留下了大量的文字，百姓也口口相传着他的轶事，细心严谨的林语堂以此推敲出苏东坡的一生。苏东坡漫长的一生虽坎坷精彩，但也不过如其词云：<strong>大江东去浪淘尽千古风流人物</strong>，读完苏东坡的一生，印象最深的却是如下两个细节：</p>

<h2>&ldquo;太快建立的友情不会长久&rdquo;</h2>

<p>这是苏东坡的妻子王弗在其结交章惇的时候给与他的忠告。当时，苏东坡少年成名，意气风发，想必并不会将这句话放在心里，不久与章惇成为不错的朋友，后来这个朋友让他吃进苦头。历史上章惇到底人品如何，无从得知，不过《苏东坡传》中后来章惇加入“王安石党&#8221;，与苏东坡形同水火，后来章惇得势，打压元祐党人，将苏东坡发配海南，恨不得搞死他。当时他们都年近花甲，想不通为何有如此大的仇怨，何况当时苏东坡丝毫无法威胁到他。</p>

<p>想到这里，突然觉得年轻时的苏东坡可能刺痛过章惇某些敏感的神经。章惇的出身不雅，是个私生子，所以儿时可能受尽奚落，致性格外强内卑。而苏东坡虽性格温婉，但年少轻狂，难免会有些许恃才傲物得罪于人而不自知。凡此种种，最终导致了自己颠沛，起伏的一生。不过人生的不幸，确成就了文坛上的一朵奇葩。</p>

<p>再回头看王弗这就话：太快建立的友情不会长久，是否可以反应她和苏东坡的爱情：太快建立的爱情不会长久。他和苏东坡一见钟情的概率不是很大，因为这桩婚姻是包办的。但一路走来，他们的感情是真挚的，有词为证：</p>

<blockquote><p>十年生死两茫茫。不思量。自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。
夜来幽梦忽还乡。小轩窗。正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。</p></blockquote>

<p>话说这是鄙人高中最喜欢的词。</p>

<h2>人至将死</h2>

<p>另一个给我印象很深的细节是，东坡晚年被贬惠州，想要在住所种植一棵树。他对帮他移植树的人说：树不要太大，太大不容易活；也不要太小，太小自己等不及树长大。读这段时，自己内心戚然，无助感犹然而生。东坡也在很早之前已抒发过此种感慨：</p>

<blockquote><p>寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。</p></blockquote>

<p>须臾的人生，意义何在，聪明如苏东坡都想不通，你我又怎能明了！</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[谁在用C++ STL？]]></title>
    <link href="http://towriting.com/blog/2014/04/18/who-use-stl/"/>
    
    <updated>2014-04-18T23:39:00+00:00</updated>
    <id>http://towriting.com/blog/2014/04/18/who-use-stl</id>
    
    <content type="html"><![CDATA[<p>C++用了四年了，这两天才把<a href='http://www.amazon.cn/gp/product/B00DGLU91K/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00DGLU91K&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Effective STL</a>看了一遍。此书作为C++经典书系Effective三部曲之一，知名度与所受褒扬远不及另两本，个中缘由是否因为STL地位不济。所以今日以自己鄙陋的经历来谈一谈当前STL在C++程序员中的地位和使用状况。</p>

<p>大家知道STL中三大法宝：容器、迭代器和算法。我所经历的公司/团队STL的使用情况：</p>

<hr />

<table border="1">
<tr><th>序号</th><th>团队规模</th><th>项目规模</th><th>容器</th><th>迭代器</th><th>高级迭代器</th><th>算法</th><th>高级算法</th><th>funtional</th></tr>
<tr><th>1</th><td>5人以下,平均2年经验</td><td>10万以下</td><td>基本没有</td><td>基本没有</td><td>基本没有</td><td>基本没有</td><td>无</td><td>无</td></tr>
<tr><th>2</th><td>10人,平均2年经验</td><td>100万</td><td>较多</td><td>较多</td><td>较少</td><td>较少</td><td>极少</td><td>几无</td></tr>
<tr><th>3</th><td>10人,平均4年经验</td><td>100万</td><td>较多</td><td>较多</td><td>较少</td><td>极少</td><td>较少</td><td>有</td></tr>
</table>


<p>（注：表中迭代器是指通过begin和end获取interator，而高级迭代器指back_inserter等迭代器生成器和内置迭代器;算法指sort,foreach, 高级算法指算法带if的形式）</p>

<hr />

<p><strong>看来，STL并不受大家欢迎，至少在我所呆过的团队里是这样的，为何如此？</strong></p>

<h3>洪水猛兽 （守旧）</h3>

<p>容器（最简单的vector）几乎是大部分C++程序员最开始接触的STL组件，我也不例外。那是10年自己刚毕业那会儿，在一家公司实习，实现一个简单的图像显示和处理的Demo程序。里面图像数据最初是存储在原始的数组（char [])中。那一阵子在狂啃《C++ Primer》，里面提到C++程序员不应该使用这些原生的数组，应该用vector代替，于是自己将程序中的char []替换成了vector<char>。而后发现一些图像算法执行慢了好多，遂请教mentor，mentor是名校的doctor，不编程久已，他并没用过STL，但提出不要用STL，不要追时髦、偷懒，老老实实的写“C”代码就好了。</p>

<p>舔着第一次用STL的伤口，念着mentor的教诲，在这家公司的第一年里自己后来好像就不再关注和使用STL。同期的C++ Programmer共四人，一个工作1年，另两个更久些，那时我们在“不赶时髦”上很团结，大家愉快的使用着VC6，且都不使用STL。</p>

<p>这就是某些老式小型软件公司一些C++程序员对待STL的态度：排斥守旧，其中缘由高校的计算机教育脱不了干系。</p>

<p>当然有个人和特殊业务场景也会排斥STL：<a href="http://www.zhihu.com/question/20201972">为何某些公司不容许使用C++ STL</a>。</p>

<h3>玄之又玄 （畏惧）</h3>

<p>C++本来有有很多不易掌握的细节。而STL同样如此，简单强大，但有微妙的陷阱。就拿Effective STL来说，条款1：慎重的选择容器类型中，就有大量自己不曾掌握模棱两可的点：</p>

<ul>
<li>string的swap会导致迭代器失效</li>
<li>容器的内部可能有引用计数</li>
<li>插入、删除操作的回滚能力</li>
</ul>


<p>当然有些细节无需掌握，但就我接触到的C++程序员大都使用STL的最简单用法: 使用vector和map存储一些数据，而对稍微高级点的STL用法麻木无知或畏惧使用：</p>

<ol>
<li>各种容器的区别，如何使用容器兼容C接口</li>
<li>for_each等函数存在的意义，如何写出函数式风格的代码</li>
<li>类的成员函数和同名全局函数的区别，比如set::find与std::find，map::remove与std::remove等等</li>
<li>xxx_if函数的使用，如何写predicate</li>
<li>function&lt;>, bind函数的使用</li>
<li>一些惯用法，比如erase-remove</li>
</ol>


<p>以上是我认为一个合格的C++开发应掌握的STL技巧。而掌握这些技巧，却是需要一段时间的练习，是否这一原因导致了一部分人对STL的无爱？因为即使不掌握这些技巧，功能是同样可以完成的。</p>

<h3>曲高和寡 （风气)</h3>

<p>语言的出现提高了人们交流的效率，设计模式的出现提高了软件人员的交流效率，但前提是交流的双方都懂才行。STL同样如此，我之蜜糖彼之砒霜，在一个不了解STL的团队中大量使用STL尤其是一些稍微“高级另类”的用法，难免遭人排斥。而且别人很难看懂你写的代码，指责你的代码难于维护，这并不是谁的错，这是一个道不同不幸与某的问题。</p>

<p>在一个不用、不了解STL的团队，喜爱STL之人会克制使用STL！</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[入职一周年记]]></title>
    <link href="http://towriting.com/blog/2014/04/08/tencent-anniversary/"/>
    
    <updated>2014-04-08T23:38:00+00:00</updated>
    <id>http://towriting.com/blog/2014/04/08/tencent-anniversary</id>
    
    <content type="html"><![CDATA[<p>现在是2014年4月8日，23点45分，一刻钟后，今天将永不存在。一个小时前，才离开公司，相信现在公司还有同事在吧。今早收到了系统发来的祝贺入职周年的邮件，这一天真的来了，回头看自己竟然咬牙坚持下来了。</p>

<h3>背靠大树好乘凉？</h3>

<p>首先，腾讯确实是一个很好的平台，能作为腾讯的员工还是值得自豪的。公司很正规，这自不必说，各种软硬件环境也都不错，平时联调程序也有机会接触到一些技术水平不错的程序员，公司也基本可以做到重视个人的价值，能者多劳，多劳多得。但现在的部门，偏居杭州，保留了原创业公司团队“拼命”的作风。一年来团队忙的头昏脑胀，产品却并无喜人起色：产品跟着KPI走、偏离了产品本质；需求繁重、时间仓促；技术债越积越多，软件越跑越慢；感觉当前的团队像陷入沼泽的野兽，用力挣扎无奈越陷越深。</p>

<p>个人在这种环境下，心理肯定是矛盾的。团队中大概现在有三类人：其一是，团队早期的成员，产品像他们自己的孩子，孩子病了，他们很清楚，宁可自己吃苦也要给孩子治病（方法正确与否还在其次）；第二种人是，希望产品能做好，但并不太有信心，能做好本职工作，大部分人是这种人；第三种是<a href="http://baike.baidu.com/view/1561482.htm">坏苹果</a>，尤其现在团队的处境下更会放大其危害性。</p>

<h3>千万不要做坏苹果</h3>

<p>自己是第二种人吧。主观上感觉团队中出现了一些烂苹果的味道，至于究竟其行为能否归为烂苹果就见仁见智了。反正其作为真的不符合自己的工作价值观。极个别人：你跟他讲DRY，他给你四处拷贝代码；你跟他说代码可读性好，他给你疯狂用宏；你指出他的Bug，他缩头不理你；到头来代码没写几行，Bug倒永垂不朽的留下! 郭德纲形容同行的话真是不假：</p>

<blockquote><p>&ldquo;你和他讲文化，他和你讲孔子；你和他讲孔子，他和你讲老子；你和他讲老子，他给你装孙子&#8221;。</p></blockquote>

<p>而整个团队呢？技术氛围几无，遇事推诿，任务分配不合理，凭责任心干活！坏苹果会传染，白沙在涅与之俱黑，真的害怕自己也会变得这样。换个角度看，只是别人的行为规范与己迥异而已，没准自己在他人眼中是奇葩呢。子曰:非礼勿视,非礼勿听,非礼勿言,非礼勿动，践行何其难也。</p>

<p>但团队中还是有好多“良心”人物值得自己学习，不管是从技术、还是豁达、还是专业态度上。导师、正副组长都是自己学习的榜样。</p>

<h3>我们为什么要加班？</h3>

<p>有人将加班视为洪水猛兽，但这些人都是大牛，大牛有选择自己工作环境的自由。对于大部分人中国程序员来说，加班是约定俗成。但加班溯源自哪里真的不好说，可能是早期的软件从业者，是真正的喜欢这个行业，喜欢的时候加班也是甜的，所以他们会下班后继续沉浸在自己喜欢的工作中，所以无形中引领了加班之风。个人不反对加班，但仅限于特定时期、特殊情况下的加班加点，讨厌长期因不合理的项目进度安排导致的加班，而过去的一年真的是这样。</p>

<p><strong>工作量 ÷ 工期 > 8 == 加班</strong></p>

<p>工作量和工期都由产品包办制定，需求时间评估前，deadline早已定死，开发时间评估形同虚设，不是量体裁衣却是削足适履。想起<a href="http://www.ituring.com.cn/article/42974">Mac君</a>讲的故事：</p>

<pre><code>乔布斯兴冲冲的从外面冲进来，对沃兹说，『兄弟，咱们得做个XX，你是最佳人选，只要你能做出来，咱就发达了』

善良的沃兹：『没问题，我喜欢这挑战』~~

『唔，我们需要在4天内完成』

『我艹，你没事吧，怎么可能？至少需要两周』

乔布斯不说话含情脉脉的望着沃兹：『You can do it！』

『好吧，十天』
『……』
『好吧，五天』
『……』

『好吧，就4天』

乔布斯吹着口哨走了，沃兹留下来干了4天4夜。
</code></pre>

<p>故事的结尾是，沃兹漂亮的完成了任务。但天才不世出，现实世界真实的结局可能并不如此。</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[读：人生元编程]]></title>
    <link href="http://towriting.com/blog/2014/02/23/mac-shuo-review/"/>
    
    <updated>2014-02-23T22:52:00+00:00</updated>
    <id>http://towriting.com/blog/2014/02/23/mac-shuo-review</id>
    
    <content type="html"><![CDATA[<p><a href='http://www.amazon.cn/gp/product/B00ID5UV30/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ID5UV30&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>人生元编程</a>这本书最近很火，所以昨天花了半天的时间在Kindle上翻看了一遍。最近自媒体将网文整理成集出书的很多，这一本也是，作者池建强，自称Mac君。去年就断断续续的跟过Mac君在其<a href="http://macshuo.com/">博客</a>上帖的文章，印象最深的是其能将IT界大佬的故事娓娓道来，颇有吴军之风，更兼Mac君是根正苗红的程序员，所以文章读来倍感亲切，处处体现了其对程序员个体的勉励。</p>

<p>但《人生元编程》书读来的快感并不比直接从Mac君博客上扒拉文章高多少，且大篇幅的Mac技巧、系统配置的内容，有充页数之嫌，直接会被我等俗气的Windows程序员pass。但一本书能找到哪怕一处能启发自己的点足矣，何况此书还是有很多地方还是闪耀着智慧的光泽的：</p>

<ul>
<li>如果你能够把技术文章写好，慢慢就能写出人文类的文字，慢慢你就会发现自己已经站在科技与人文的十字路口了</li>
<li>只有多核或多个CPU才可能发生并行，如果单核单CPU只能发生并发行为</li>
<li>不停的反驳别人不会证明自己的聪明和独立思考，正确的讨论技巧和解决问题才是王道</li>
<li>曾经有位古人说过，如果你手里有一把锤子，所有东西看上去都像钉子。还有一位今人说过，如果你有一个钉子，就会满大街找锤子！</li>
<li>技术岗所受到的待遇普遍是低于相同层级的管理岗位的，</li>
<li>如果我需要别人的意见和建议，那就把自己放空，暂时扔掉偏见和预判，</li>
<li>旅行就是从一个自己待烦了的地方，跑到一个别人待烦了的地方</li>
<li>很多人羡慕创业公司的人获得的财富，他们只不过是把你20年平稳的打工生涯压缩成4年艰苦卓绝的创业</li>
<li>但费力之事自有其好处，人生总要做一些艰难费力的事情，读书也是一样。 写到这儿很多读者要问了，这和</li>
<li>但费力之事自有其好处，人生总要做一些艰难费力的事情</li>
<li>真正强大的Shell是深藏不露的zsh，</li>
</ul>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[春节杂记]]></title>
    <link href="http://towriting.com/blog/2014/02/20/spring/"/>
    
    <updated>2014-02-20T22:00:00+00:00</updated>
    <id>http://towriting.com/blog/2014/02/20/spring</id>
    
    <content type="html"><![CDATA[<p>今天正月二十一，按我们老家旧时的习俗，二月二&#8221;龙抬头&#8221;以后，才算过完年。今年过年在家里待了12天，算来不短，一年的忙碌终换来了多出的几日闲暇。年前被评为优秀员工算是出乎自己意料的一件春节期间的乐事。但在家中的这一小段时光，却没什么值得记录的，在村里依旧是整天玩一种叫做牌九的赌博游戏，自己很乏味，但儿时的伙伴热衷于此，只能舍乐陪他们了。然后其它的无非是，会会旧时朋友同学，一年中平日难得交流，且行业迥异，话题颇少，只能以酒代话，醉醺醺的归家了。</p>

<p>这个春节，和往年一样，主要任务是见一见常年不联系的人们，然后散了，依旧联系很少。今年越发感觉自己和每个人的关系都远了：父母、亲戚、儿时伙伴、高中同学。与父母交流最多的就是母亲总会问我：想吃什么、多吃点等等。至亲叔伯姑姑一大堆，但自己常年在外，甚少联系，感觉越来越不亲了，如今奶奶年事已高，等她走后，想必这些至亲会愈发疏远了，包括儿时躺一个被窝的堂弟，现在每月除了给我要点Q币外，没什么聊的了。儿时伙伴，都没怎么上过大学，大多早已成家，现在有些在家中打工，有些在外面做生意，这些年我在外面，能想像到他们的生活，但他们可能不知道我到底怎么过的，儿时的伙伴，一生的朋友，彼此很亲，但话题也越来越少了。高中同学，大都在外打拼，都很艰辛，不过几个要好的，也会是一辈子的哥们。</p>

<p>兄长回国教书，今年本该回家过年，但却意外上火车几小时前有事无法回来了，加上去年没见面，如果等今年春节再见，就三年了才见一次面了。人生有几个三年。这个影响我少年时期最深的人，和父母一样亲的人，也渐行渐远了。初八回杭，与父母同行至德州，父母去安徽看望哥嫂，这一天下起了大学，自己的高铁晚点三个小时，初九凌晨才到杭州了。然后雨雪不断，直到今天天才放晴了。</p>

<p>感觉整个春节的基调是灰的，唯一的亮点是，自己尝试着购得一<a href='http://www.amazon.cn/gp/product/B00CWPIDHI/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00CWPIDHI&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>KPW2</a>，并且在春节期间，窝在家里里屋的床上翻看了三本书，自己的阅读习惯应该是被改变了，且是好的改变，这算是一慰藉吧！！</p>

<p>还有一事想起，今年群发短信明显减少，收到的短信也算是“私人定制”的，还意外的收到了苟哥一条酸溜溜的祝福。同事们会在微信群里发红包。当然更要好的同学会通话联系，我远在非洲的高中好友，总会在佳节想起我。</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[2013年（下半年）个人总结]]></title>
    <link href="http://towriting.com/blog/2014/01/01/2013-review/"/>
    
    <updated>2014-01-01T21:55:00+00:00</updated>
    <id>http://towriting.com/blog/2014/01/01/2013-review</id>
    
    <content type="html"><![CDATA[<blockquote><p>人没有进步，和死鱼有什么区别！</p></blockquote>

<p>今天是西元2014年的第一天，最近一周内，网上随意浏览时各种关于个人或者行业的年度总结不时映入眼帘。当然行业大佬、业界明星的总结与底层的程序员是不可能相同的，无论从视角、信息含量、高度等维度来比较。前者会高屋建瓴的描绘行业发展态势、自己（公司）为何做出某个举动、某个举动的结果、未来行业的走向等等；而后者更多的关注于：今年学习了哪些技术、换了几份工作、攒了多少钱等等。所以程序员的个人总结，仅仅是个人总结。</p>

<h2>总结的目的：Summary Or Review</h2>

<p>就在准备写这个总结时，本想给新的Markdown文件来个规范的命名，最初我以为是<code>Summary</code>但以Summary + 2013为关键字Google并不能得到看起来像“年度总结”的东西，去HackerNews瞎翻一通，终于看到了一个哥们的2013年度总结:<a href="http://nathanbarry.com/2013-review/">TWO YEARS AFTER QUITTING MY JOB: 2013 IN REVIEW</a>，<code>Review</code>做总结的翻译再合适不过了。在我看来Review有两层意思，其一是字面意思：<strong>回看</strong>，单从这一层意思看，Summary亦可胜任。另一层，IT行业的同学自可意会，通不过<code>Review</code>的代码需要<strong>回退</strong>(当然人生无法回退）。所以<strong>总结的意义在于：发现问题</strong>。</p>

<h2>下半年做了什么</h2>

<p>上半年的流水帐已交待在<a href="http://towriting.com/blog/2013/09/15/summary/">上半年总结</a>中。下半年工作基本上算是上一阶段的自然延续，代码得到了组长的认可，开始参与手机管家开发。11月开始了应用宝Mini版开发，应用宝Mini版是今年压力最大的开发任务：工期短、框架不熟悉、任务重。回过头来看，大家竟然按时完成了。应用宝完整版的开发自己并没有参与，而被安排做另一个新项目的开发，开发的产品会成为后续应用宝版本的“核心”。前期主要由我一个人开发，由组长Review接口，到目前系统的框架和基本功能已完成，此项目不爽的是用VS2005开发，对于熟悉C++11的人来说，VS2010与VS2005的差别自是判若云泥。</p>

<p>其它的就算是翻译了技术文章数篇吧。</p>

<h2>下半年学了些什么</h2>

<p>技术方面下半年，很惭愧的讲并没有自己满意的进步或新的输入。新的技术输入可能算是Ruby语言的学习，不过第一轮学习计划：阅读Ruby编程语言和Ruby元编程，才完成40%。再就是工作中接触到了COM，知道了一些COM相关的开发流程。C++方面的深入貌似裹足不前了，这半年来没有在某个大面比如并发或模板上专门提高，只是随意的在某些细枝末节上深入而已。工具上可能算是对一些软件更熟练使用了，比如这篇<a href="http://towriting.com/blog/2013/11/17/effective-tools/">记录</a>的，虽提高了工作效率，但都不太值得一提。</p>

<h2>Review出的问题</h2>

<p>1 自己是工作的机器吗</p>

<p>13年工作较以往强度增大了很多，加班也已经达到了一般人难以想象的程度，有的月仅休息3天，平时一般都是22：00后下班。在这样的工作状态和个人习惯的双重影响下，13年自己除了工作貌似并没有做任何有意义的事情，还好有2次旅游，一次越南、一次江西。
朋友交流团队活动也很少，所以13年自己好像成了工作的机器。</p>

<p>2 阅读亮起了黄灯</p>

<p>自己一直自认为算是个“好读书”的人，但从自己的<a href="http://towriting.com/blog/2013/07/20/the-books-i-have-read/">读书记录</a>来看，13年的阅读量下降了不少，平均才每月一本，而且很多还拖沓着没有读完，说工作太忙只是给自己找借口，其实周六周日还是有时间的，而周六日的时间好像都耗费在无意义的上网和看视频上。时间是个很奇怪的东西，当半夜下班拖着疲倦的身体，倒想到了时间的宝贵，会很珍惜的带着困意阅读一会儿。而周六日大把的时间，觉得肯定不缺阅读的时间，直至周日晚上才发现还没有翻过书。
新的一年一定纠正周末懒散的坏习惯。</p>

<p>3 社交能力的丧失</p>

<p>13年，大部分时间实在公司，休息时也窝在住处。除工作外没有认识任何人，没有参加过任何体育运动，孑然一身，逐渐丧失交际能力。2014要走出去！！！</p>

<h2>2014要做什么</h2>

<h4>Must do</h4>

<ul>
<li>改正上面的问题：1、2</li>
<li>3月前学习Ruby,前半年开发一款WebAPP</li>
</ul>


<h4>Can do</h4>

<ul>
<li>改正上面的问题：3</li>
<li>考个驾照</li>
</ul>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[为什么要学Ruby]]></title>
    <link href="http://towriting.com/blog/2013/12/26/learn-ruby/"/>
    
    <updated>2013-12-26T21:15:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/26/learn-ruby</id>
    
    <content type="html"><![CDATA[<p>  最早是在09年知道Ruby的，大概是知道Python的同时。当然这里的知道是仅限于名字上的。那是上大学，偏机械的专业，某些同学到今天可都是不会装系统的。而和这些不懂电脑的同学大谈各种计算机知识、编程语言的特点，是我一大爱好：脚本语言是一种易学的语言，要不然为何叫”脚本“，是因为用脚都可以学会；脚本语言里面有三P：Python，Php, Perl，都是极好的，当然还有一个Ruby，不过是日本人发明的，你如果不爱国的话，倒可以学一学&hellip;</p>

<p>  最早的关于Ruby的记忆，就是和同学的这些对话了。毕业后，狂补C++的知识，不惜一切的想要提高C++的技术水平，听闻C++程序员必须要辅修一门脚本语言，于是Perl，Python，Ruby三门语言在我脑中角逐，最后Python胜出，于是啃了两三本Python的书籍，断断续续写了一些脚本，逢人就推荐Python，&#8221;life is short, use Python!&ldquo;, Python是个极佳的工具语言，Python的学习反向促进了对C++的领悟，Lambda的概念是从Python中学到的，当然后来自己又追逐Lambda的源头Haskell，就不多说了。</p>

<p>  而自己为什么又要开始学Ruby了呢？不爱国了吗？当然开玩笑了，互联网的世界那里有国别之分，而且我们谋生用的技术那些是国产呢？</p>

<p>  从Ruby很火可以推断Ruby应该是个不错的语言，除却这个原因和学习本身就是一个快乐的过程外，以下是自己主观上想要学习Ruby的原因：</p>

<h3>C++学习之痒</h3>

<p>当然C++现在处于并且将长期处于自己技术方向的中心。都说C++语法都让人着迷，然自己好像陷入C++的汪洋大海中了，看到这些<a href="http://towriting.com/blog/2013/12/12/cpp-blogs/">大牛的博文</a>，始觉自己对C++了解的太少了。短暂的休息是为了下一次冲锋，C++的深入，先放一放。</p>

<h3>美丽新世界</h3>

<p><a href="http://en.wikipedia.org/wiki/Andy_Hunt_(author)">Andrew Hunt</a>的经典名著<a href='http://www.amazon.cn/gp/product/B004GV08CY/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004GV08CY&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>程序员修炼之道</a>中提到，程序员每年要学习一门语言。一些教授所言的“语言不重要，所有语言都是相通的“这种观点经不起推敲。人为什么要学习外语，无外乎两种原因：了解语言背后的思维习惯和掌握语言背后的信息价值。编程语言和自然语言一样的，学习一门新的编程语言，可以接触到新的思维习惯和语言先天的优势（语法糖、框架、库、社区等）。</p>

<h3>劳动是必需品</h3>

<p>中学时，记得关于共产主义的描述有一条是：<code>劳动已不仅是谋生的手段，而且成了生活的第一需要</code>，设想一下，到那时休5做2，想要加班都会被领导批评，要层层审批才能通过。那时的劳动定是快乐的，可这种乌托邦的社会，你我未必可以赶的上，我们如何爱上我们的工作？</p>

<p><code>Ruby, 让你爱上你的工作</code>。这是某些人打出的Ruby的口号，我特别想证明这个口号是对的，或是错的。</p>

<h3>现实的考量</h3>

<p>Ruby在国内算是小众的语言，但如果要转Ruby的话，能否找到工作，刚才在Indeed上搜索Ruby:948条,Python:4,474条;Haskell:7条；机会确实不太多，再看Ruby的趋势，左侧全球的Ruby热度减退，但右侧国内Ruby热度13年井喷，所以不久以后Ruby还是可以学以致工作的。</p>

<script type="text/javascript" src="//www.google.com/trends/embed.js?hl=en-US&q=/m/06ff5&cmpt=q&content=1&cid=TIMESERIES_GRAPH_0&export=5&w=400&h=330"></script>




<script type="text/javascript" src="//www.google.com/trends/embed.js?hl=en-US&q=Ruby&geo=CN&cmpt=geo&content=1&cid=TIMESERIES_GRAPH_0&export=5&w=350&h=330"></script>


<h3>为了自由</h3>

<p>当然并没有人强暴我的心理或肉体，我指的自由是，可以做一个自由职业者。这当然这是3、5年后的目标，而靠C++实现这个目标貌似不容易，如今是Web与APP的天下了，ROR，貌似是一个适宜自由职业者开发web产品的框架。</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[《C++标准库第二版 上册》笔记]]></title>
    <link href="http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1/"/>
    
    <updated>2013-12-18T23:27:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1</id>
    
    <content type="html"><![CDATA[<p>p63 a pair&lt;> using a type that has only a nonconstant copy constructor will no longer compile.</p>

<p>p64 std::piecewise_construct is passed as the first argument is class Foo forced to use a constructor that takes the elements of the tuple rather than a tuple as a whole.</p>

<p>p65 The make_pair() function template enables you to create a value pair without writing the types explicitly.</p>

<p>p67 pair used in functions that return two values.</p>

<p>p68 tuples extend the concept of pairs to an arbitrary number.we can access elements with the get&lt;>() function template.</p>

<p>p70 A tuple type can be a reference. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="n">tuple</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&amp;&gt;</span> <span class="n">t</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>For element access, you must know the index of element at complier time.It is also a complier error if you pass a invalid index.
Make_tuple can create tuple without special the type of element.
By using references with make_tuple(), you can extract values of a tuple back to some other variables. e.g.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span><span class='line'><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>p72 std::tie() creates a tuple of references. the use of std::ignore allows ignoring tuple elements while parsing with tie()</p>

<p>p75 You can initialize a two-element tuple with a pair.Also, you can assign a pair to a two-element tuple.</p>

<p>p76 Tow types of smart pointer:</p>

<ul>
<li>shared_ptr. Multiple smart pointer can refer to the same object.</li>
<li>unique_ptr. only one smart pointer can refer to this object at a time.</li>
</ul>


<p>p77 shared_ptr. you can define other ways to clean up object.</p>

<p>p78 shared_ptr can&rsquo;t assign a new ordinary pointer. but can use reset function to reset the pointer.</p>

<p>p79 assigning a nullptr to a shared_ptr would delete the ownship.</p>

<p>p80 Smart pointer, when use new[] to create an array of object, you must define your own deleter.</p>

<p>p85 weak_ptr allows sharing but not owning an object.</p>

<p>p90 You should always directly initialize a smart pointer the moment you create the object with its associated resource.</p>

<p>p95 Aliasing constructor,The constructor taking another shared_pointer and an additional raw pointer.</p>

<p>p96 shared pointers are not thread safe.</p>

<p>p101 You can&rsquo;t copy or assgin a unique pointer if you use the ordinary copy semantics, but can use move semantics.</p>

<p>p102 assgining nullptr is also possible, which has the same effect as calling reset().</p>

<p>p103 The Reason that no std::move is necessary in the return statement of source() is than according to the language rules of c++11, the compiler will try a move automaticallly.</p>

<p>p105 The c++ stl provides a partial spartial specialization of class unique_ptr for array: std::unique_ptr<code>&lt;std::string[]&gt;</code></p>

<p>p110 unique_ptr not necessarily defined as T*</p>

<p>p115 The new concept of numeric limits has two advantages: first, it offers more type safety. second, it enables a programmer to write templates that evaluate these limits.</p>

<p>p119 all members of numeric_limits are declared as constexpr.</p>

<p>p121 you can query for any arbitrary type whether or not it has numeric limits defined.</p>

<p>p125 Type Traits:</p>

<ul>
<li>Type Predicates</li>
<li>Type Relations</li>
<li>Type Modifiers</li>
</ul>


<p>p130 A reference to a constant type is not constant</p>

<p>p136 Note that swap provides an exception specification</p>

<p>p158 Not that time_t usually is just the number of seconds since the UNXI epoch. bu this is not guaranteed.</p>

<p>p166 The marjor advantage of iterators is that they offer a small but common interface for any arbitrary container type.</p>

<p>p166 The concept of STL is base on a separation of data and operations. The data is managed by container classes, and the operations are defined by configurable algorithms. iterators are the glue between these two components.</p>

<p>p167 There are three general kinds of containers:</p>

<ul>
<li>Sequence contains are ordered collections in which every element has a certain postion.</li>
<li>Associative containers are sorted collections in which the postion of an element depends on its value due to a certain sorting criterion: set multiset map multimap.</li>
<li>Unorderd containers. neither the order of insertion nor the value of the inserted element has an influence on the postion of the element, and the position might change over the lifetime of the container: unordered_set,undered_multiset,undered_map,undered_multimap.</li>
</ul>


<p>p170 size() is provided for any container class execept singly linked lists(class forward_list)</p>

<p>p170 deque rhymes with &ldquo;check&rdquo;</p>

<p>p171 the push_front is not provided for vectors, because it would have a bad runtime for vectors, but is is possible to insert an element at the beginning of a vector.</p>

<p>p171 using array. with a safer and more convenient interface.</p>

<p>p176 forward_list is in principle just a limited list.</p>

<p>p177 The major advantage of associative containers is that finding an element with a specific value is rather fast.</p>

<p>p177 you can consider a set as a special kind of map, in which the value is identical to the key. in fact, all these are implemented by using the same basic implementation of a binary tree.</p>

<p>p180 C++11 guarantees that newly inserted elements are inserted at the end of equivalent elements that multisets and multimaps already contain.</p>

<p>p180 unordered containers are typically implemented as a hash table. the goal is that each element has its own position so that you have fast access to each element.</p>

<p>p185 associative array: an array whose index is not an integer value.</p>

<p>p188 an iterator is an object that can iterate over elements. iterators share the same interface but have different types.</p>

<p>p189 every container defines two iterator types:</p>

<ul>
<li>container::iterator is provided to iterator over elements in read/write mode</li>
<li>container::const_iterator is provided to iterator over elements in read mode</li>
</ul>


<p>p199 To write generic code you should not use special operations for random-access iterators.</p>

<p>p199 Algorithms are not member functions of the container classer but instead are global functions that operator wich iterators. this concept reduces the amount of code and increases the power and the flexibility of the library.</p>

<p>p208 Multiple Ranges, make sure that the second and additional ranges have at least as many elements as the first range.</p>

<p>p209 associative and unordered containers cannot be used as a destination for overwriting algorithms.</p>

<p>p210 Interator Adapters</p>

<p>p210 Insert Interators solve the problem of algorithms that write to destination that does not have enough room.</p>

<p>p212 general insertor call insert()</p>

<p>p213 <code>istream_iterator&lt;string&gt;()</code> calls the default constructor of iterators that creates a so-called end-of-stream iterator.</p>

<p>p214 reverse iterators rbegin()\rend()</p>

<p>p220 distance if iterator were random-access, you could with &ldquo;&ndash;&rdquo;</p>

<p>p221 to make agorithms as flexible as possible there are good reason not requrie that interator know their container.</p>

<p>p223 a container might have member functions that provide much better performance that algorithms</p>

<p>p226 predicates must stateless</p>

<p>p232 Lambda no default constructor and no assignment operator.</p>

<p>p235 function object are functions with states</p>

<ul>
<li>fnctction object has its own type</li>
<li>function object may faster than ordinary functions.</li>
</ul>


<p>p241 Binder to combine predefined function objects with other values or use special cases.</p>

<p>p248 it&rsquo;s turns out that exception specifications could cause performance penalties, so they were replaced by noexcept with c++11.</p>

<p>p249 if you need a transaction-safe container, you should use a list.</p>

<p>p254 container&rsquo;s operators are not safe in the sense that they check for every possible error.</p>

<p>p257 since c++11 you can use move constructor</p>

<p>p258 Move Sytax: The contents of the container on the right-hand side are undefined afterwared:</p>

<p>p258 forware_list not provided size()</p>

<p>p260 all containers except vectors and deques guarantee that iterators an references to elements remianing valid if other elemenets are deleteed.</p>

<p>p262 array&lt;> default initialized.</p>

<p>p267 array you must not pass an iterator as the address of the first element.</p>

<p>p271 vectors： capacity(), which returns the number of elements a vector could contain in its actual memory.</p>

<p>p271 If the only reason for initialization is to reserve memory, you should use reserve()</p>

<p>p271 it is not possible to call reserve for vectors to shrink the capacity.</p>

<p>p282 For vector<bool> the return type of subscript operator is an auxiliary class.</p>

<p>p283 Deque is typically implemented as a bunch of individual blocks.</p>

<p>p284 Deque provide no support to control the capacity and the momnet of reallocation.Howerer reallocation may perform better than for vectors because according to their typical internal structure, deques don&rsquo;t have to copy all elemenets on reallocation.</p>

<p>p284 Blocks of memory might get freed when they are no longer used(implementation specific)</p>

<p>p286 You could say that lists are transaction safe.</p>

<p>p301 The design goal to have &ldquo;zero space or time overhead relative to a hand-written C-stype single linked list.</p>

<p>p303 forward_list provide no support size(), but you can use std::distance(list.begin(),list.end())</p>

<p>p315 you cant change set&rsquo;s value from interator</p>

<p>p316 not that the sorting criterion is also used to check for equivalence of two elements in the same container.</p>

<p>p338 std::for_each(coll.begin(), coll.end(), [] (decltype(coll)::value_type &amp;elem) {}
p342 piecewise_construct emplace.</p>

<p>p345 [] is slower than the insert()</p>

<p>p366 unorder container</p>

<p>p366 unorder containers are optimized for fast searching of elements</p>

<p>p386 using the noninvasive approach is simple, you need only objects that are able to iterate over the elements of an array by using the STL iterator interface.</p>

<p>p386 Any Thing that behaves like an iterator is an iterator.</p>

<p>p437 forward iterators, it is guaranteed that for two forward iterators that refor to the same elemnet, operator == yields true and that they will refer to the same value after both are incremented.</p>

<p>p442 to be able to change container and iterator types, you should use advance</p>

<p>p460 for insert iterator, a bad hint might even be worse than no hint.</p>

<p>p471 writing user-defined iterators</p>

<p>p476 each function object has its own type</p>

<p>p479 by default, function objects are passed by value rather than by reference.</p>

<p>p483 for_each can return a value</p>

<p>p485 a predicate should always be stateless. you should declare operator() as const. but lambda not exist this problem.</p>

<p>p494 bind also could bind data member.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Windows提供的INI接口不是线程安全的]]></title>
    <link href="http://towriting.com/blog/2013/12/17/ini-muti-thread/"/>
    
    <updated>2013-12-17T23:28:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/17/ini-muti-thread</id>
    
    <content type="html"><![CDATA[<p>INI是Windows系统下人们喜闻乐见的一种配置存储方式。Windows提供了一套简单的接口操作INI文件，但它们并不是线程安全的，对于这一点，这些函数比如<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms725501(v=vs.85).aspx">WritePrivateProfileString</a>的文档中并没有提到。
据<a href="http://mfctips.com/tag/getprivateprofilestring/">这篇文章</a>介绍:</p>

<h2>WritePrivateProfileString:</h2>

<ul>
<li>WritePrivateProfileString内部使用NtCreateFile访问文件，共享方式设置为：FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE。使用NtLockFile，FailImmediately设置为False，ExlusiveLock设置为True来锁定文件。</li>
<li>这意味着WritePrivateProfileString是非线程安全的，是进程安全的（非远程机器）。</li>
</ul>


<p>我们目前的软件有大量的并发操作INI的行为，没出现过什么问题只能说是幸运了（亦或是不幸）。同事并不太相信以上结论，让我们用事实证明，写一段并发操作INI的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &quot;stdafx.h&quot;</span>
</span><span class='line'><span class="cp">#include &lt;Windows.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'><span class="cp">#include &lt;process.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cassert&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">GetIniName</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strIniName</span><span class="p">;</span>
</span><span class='line'>  <span class="n">strIniName</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">MAX_PATH</span><span class="p">);</span>
</span><span class='line'>  <span class="n">strIniName</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">GetModuleFileName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">TCHAR</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">strIniName</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span> <span class="n">strIniName</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
</span><span class='line'>  <span class="n">strIniName</span> <span class="o">+=</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;.ini&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">strIniName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">WriteIniInThread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">pText</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">TCHAR</span> <span class="o">*</span><span class="n">pSec</span> <span class="o">=</span> <span class="p">(</span><span class="n">TCHAR</span><span class="o">*</span><span class="p">)</span><span class="n">pText</span><span class="p">;</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">pSec</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strVal</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strIni</span> <span class="o">=</span> <span class="n">GetIniName</span><span class="p">();</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">strVal</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_wstring</span><span class="p">(</span><span class="n">_Longlong</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span><span class='line'>      <span class="n">WritePrivateProfileString</span><span class="p">(</span><span class="n">pSec</span><span class="p">,</span> <span class="n">strVal</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">strVal</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">strIni</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&gt;</span> <span class="n">threadTexts</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="o">&gt;</span> <span class="n">threadHandles</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">60</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strText</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;Thread&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">strText</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_wstring</span><span class="p">(</span><span class="n">_Longlong</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span><span class='line'>      <span class="n">threadTexts</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">strText</span><span class="p">);</span>
</span><span class='line'>      <span class="n">threadHandles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">HANDLE</span><span class="p">(</span><span class="n">_beginthread</span><span class="p">(</span><span class="n">WriteIniInThread</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">threadTexts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">())));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">WaitForMultipleObjects</span><span class="p">(</span><span class="n">threadHandles</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">threadHandles</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码很简单，开60个线程同时往一个INI文件里写东西，让我们对比一下多线程操作INI和非多线程操作的结果，左侧是不使用多线程操作的结果（只贴出前50行）：</p>

<p><img class="pull-left" src="http://towriting.com/images/posts/ini-muti-thread/result.png"></p>

<p><img class="pull-left" src="http://towriting.com/images/posts/ini-muti-thread/error_result.png"></p>

<p></br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br></p>

<p>结果一目了然。（多线程同时操作INI时，每次的结果可能都不一样的）。</p>

<hr />
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[我为什么从同花顺离职]]></title>
    <link href="http://towriting.com/blog/2013/12/16/why-i-quit-ths-job/"/>
    
    <updated>2013-12-16T23:42:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/16/why-i-quit-ths-job</id>
    
    <content type="html"><![CDATA[<p>  最近知乎上很流行的一个问题是<a href="http://www.zhihu.com/topic/19909711">为什么从 X 离职</a>，倒退一年快到自己决定离职的日子了，趁热闹，也说说自己为什么离职。</p>

<p>  首先，照例发自肺腑的感谢一下同花顺，同花顺的日子是我C++进步最快的一段时间，在这里我接触到了正规的开发流程，并且遇到了一个很棒的团队，那时的日子每天都很开心。</p>

<hr />

<p>  切入正题，我为什么离开同花顺：</p>

<h3>待遇认知的分歧</h3>

<p>　员工离职的理由千万条，但薪水待遇肯定是大部分人选择离开的最重要的原因，不过大部分人不肯承认罢了。离职的导火索就是公司的年终奖，入职Offer上明确写明是3-6个月，可实际发到手的一月左右。我表明了自己的不满，公司领导以程序员不是钟点工，薪水是靠产品的收益决定的来“开导”我。这种观点不错，但是却是站在创业者的角度看的。自己作为一个打工者，站在打工者的角度上讲，程序员的待遇在市场经济条件下，是由供求关系决定的，并上下浮动于程序员个体的能力和工作产出。何况公司远没到揭不开锅的程度，你可以不按约定给我应有的Money，但不能忽悠我。</p>

<h3>人为什么要工作？</h3>

<p>　马斯洛总结了人的<a href="http://en.wikipedia.org/wiki/Maslow's_hierarchy_of_needs">五种需求</a>。</p>

<p>　刚毕业时囊空如洗，一头扎进工作中，完全是为了实现人的第一种需求-生理（存）需求。自己前两年的工作确实是为了实现生存需求，但当工作两三年，衣食无虞，现在仍然工作的原因好像是上一阶段的惯性。有些人可能为了实现“昂贵”的生理需求（车房等）而工作一辈子，但对我而言这种动力不足以使我能持续激情的工作。</p>

<p>　顺着马斯洛的需求金子塔往上看，塔顶是自我实现的需求，这是人的最高级的需求。</p>

<p>　是否可以提高自己的能力，是我衡量一份工作是否适合自己的重要指标。以前从没有在内心中将自我能力的提高作为工作的一个直接原因，觉得能力提高（自我实现需求）不过是为了能挣更多钱（生理需求），觉得后者才是工作的直接原因。看来我错了，自我能力的提高属于自我实现的需求，完全是促使我们工作的高级原因。而可贵的是，高级的需求好像兼容低级的需求，就是你在实现了自我实现的需求后，生理需求自然可以满足了。并且生理需求容易满足，自我实现需求难以满足，而自我实现的满足可以给人带来持久且真正的满足。在我看来，工作中的自我实现包括两点：自我能力提高和我（们）创造了有价值的东西。</p>

<p>  而同花顺，据观察感知是无法满足我这两种需求的，尤其第二种，我的判断是错误的吗？</p>

<h5>分割线&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;2014年8月2日&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h5>

<p>时隔半年发现自己上面说的东西有些空洞，现在我的<a href="http://weibo.com/wpcockroach">老领导</a>也早已离开同花顺，并在之乎专门回答了：<a href="http://www.zhihu.com/question/22086638">你为什么离开同花顺</a>。事到如今，一年半时间，原同花顺行情客户端开发组，一波十几个老同事，都差不多走光了。这种情况，公司自身肯定是有问题的，每个走的人肯定也都有自己的小九九。</p>

<p>就我来说，本不想再说同花顺的坏话，毕竟在这里认识了好多好哥们，而且不想给别人留下自己落井下石的形象，但如果是事实，为什么不说呢？</p>

<p>其实，离开同花顺最主要的原因是同花顺作坊式的管理让人看不到希望、没有尊严。如果是其他原因不可能所有人都想跑掉，要知道有些人找的新工作某些方面并不比同花顺好，但依然义无反顾的走了，因为新的环境会让人更有尊严一些。</p>

<p>技术总监，同花顺股东之一，浙大毕业，技术相貌俱佳，但人品不知、管理水平没有。自己与其交流较少，亦没有留下丁点好印象。有些工作久的同事亲切的称呼其为：会写代码的流氓。坊间流传的大量关于他撵走同事的传言，始吾不信，后来年终谈话时，问我：加薪升级是由什么决定的？我说出了几种答案都被其否定，最后他说是由他决定的。</p>

<p>后来我就走了，辗转半年后，一个老同事请我们吃散伙饭，这个老同事是公认的技术总监的红人，但席间讲出了令我心寒齿冷的故事。原来老同事离职前最后一天，被技术总监叫去，让他去一个项目里救火，老同事不愿，技术总监说：给你两条路，一给我在干半个月，把XX弄好，二，走人但最后一个月工资别要了！</p>

<p>所以，在这种环境，这种人手下干活，谁能扛得住？</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[你们是勤劳还是懒惰的程序员？]]></title>
    <link href="http://towriting.com/blog/2013/12/15/are-your-programmers-working-hard-or-are-they-lazy/"/>
    
    <updated>2013-12-15T17:17:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/15/are-your-programmers-working-hard-or-are-they-lazy</id>
    
    <content type="html"><![CDATA[<p><img class="pull-right" src="http://towriting.com/images/posts/working-hard/work-smart-not-hard.jpg">
当人们从事体力劳动时，很容易判断他们的努力程度。你可以看到肢体运动和汗水。并且可以看到他们的劳动成果：高楼拔地，稻谷归仓&hellip;。承认和褒奖辛勤的劳作是人的一种本能，是体力运动迷人的一个原因。然而当管理创造性技术员工时，褒扬辛勤劳作的本能就有问题了。高效的员工有时候看起来并没有非常努力的工作。</p>

<p>时光回到2004年，那时我在一家有线电视公司的收费和服务开通系统项目部做初级工程师。这个系统很大，像所有大系统一样，它由一些小的独立的组件构成，每个组件由一些人或小的团队开发。模拟和数字开通系统是几乎毫无关联的系统，由不同的团队分别开发。</p>

<p>模拟电视组计划基于Microsoft Biztalk的一个早期版本开发他们的系统。由我们四名员工和一个微软的团队来开发这个系统和进行生产运行。他们看起来都工作的很辛苦。经常听说他们在晚上和周末加班。一旦出现任何运行故障，每个人都必须放下手头的工作，围在一个人的桌子前，讨论并提出解决意见。正如我们看到的，他们的队伍凝成了一条绳，并且每个成员都非常的努力。</p>

<p>而数字电视组的风貌则截然不同了。初期所有的代码几乎都是一个叫做Dave的家伙写的，我作为初级程序员主要负责一些维护工作。最初我对这些代码很费解，明明一个函数可以搞定的事情，却用好多只有几行代码的类来实现，一些同事也抱怨Dave把事情搞复杂了。但Dave建议我读一些面向对象的书籍，并给我讲解设计模式、<a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID原则</a>、单元测试。于是这些代码在我脑中生动起来，深入看过这些代码之后，不得不赞叹其设计的优雅：改变一些代码非常简单，实现新功能根本没什么难的，有单元测试意味着甚少有BUG。</p>

<p>结果是我们看起来工作的很随意。每天下午五点半回家，周末从不加班，从来不会挤在一个人的桌子边胡乱猜测系统的哪个部分出问题了。外人肯定以为我们接到的工作要比模拟电视团队的轻松许多。事实上是，需求差不多，我们只是有更好的设计和单元测试等的基础支撑。</p>

<p>加薪时，公司宣布以表现作为评定的标准。轮到我和老板对话时，老板讲到给那些辛勤工作的人加更多的薪水是很公平的，我们的团队并不以公司事情为己任，比不上那些牺牲了自己晚上和周末时间的英雄们。</p>

<p>公司应该做个实验，观察对比良好设计和团队表现这两个因素的效果。大部分组织是不会做这个对比的。很难判断一个挥洒汗水、废寝忘食、日夜待命的人是否有胜任复杂系统开发的能力。也很难说朝九晚五，上班淘宝的家伙是高质量代码的编程好手，还是仅仅分配到简单的任务？但常人看到的只是第一种人努力工作，而第二种没有。勤快是好的，懒惰就是坏的吗？</p>

<p>我必须说困苦工作是失败的前兆。软件开发在压力、中断的环境中不会进行的很好。工作很长时间不是个好主意。有时解决一个难题的方法是停止想它，出去溜一圈，甚至睡一大觉让潜意识去解决掉它。我最喜欢的一本书是20世纪著名的数学家哈代写的<a href='http://www.amazon.cn/gp/product/B0011F7ORK/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011F7ORK&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>一个数学家的辩白</a>。书中提到哈代自己的作息是这样的：早上四个小时的工作然后下午看板球。他提到超过四个小时的连续脑力工作是徒劳和无意义的。</p>

<p>我想对管理者说，要以结果以可以工作的软件来衡量人，而不是以人工作时的辛苦程度。你应该衡量员工的产出，而不是坐在他们旁边观察他们不自在的操作着IDE，抑或是围在一块儿相互“帮助”。</p>

<p>由Towriting.com翻译自：<a href="http://mikehadlow.blogspot.com/2013/12/are-your-programmers-working-hard-or.html">Code rant: Are Your Programmers Working Hard, Or Are They Lazy?</a></p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Boost.Lambda与C++11.Lambda的用法对比]]></title>
    <link href="http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda/"/>
    
    <updated>2013-12-13T22:38:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda</id>
    
    <content type="html"><![CDATA[<p>我们知道C++11已经支持了Lambda表达式，大部分新的编译器都已支持Lambda。但boost里面的Lambda还是有存在的必要，因为并不是每个人都有选择自己编译环境的权利。</p>

<p>让我们通过几个例子对比C++11.Lambda来学习一下boost.Lambda的用法，详细的C++11.Lambda用法可以看这里：<a href="http://towriting.com/blog/2013/08/11/lambda-closures/">C++11系列-Lambda表达式</a></p>

<h3>1.a boost.Lambda：构造一个functor</h3>

<p>boost.Lambda的使用是基于placeholder: <code>boost::Lambda::_1</code>,<code>boost::Lambda::_2</code>,<code>boost::Lambda::_3</code>可以理解为Lambda表达式的第一、第二、第三个参数。Lambda的出现利索地解决了STL算法库函数的使用不便。让我们首先看一个最简单的boost.Lambda与std::for_each结合的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecIn</span><span class="p">;</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the orgin values in vecIn：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子，使用std::for_each遍历vector中的元素并打印内容。boost::Lambda::_1这个占位符表示for_each遍历时传进来的第一个参数，<code>std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;","</code>可以理解为临时创建出来的匿名函数，函数的定义是<code>void(int)</code>。</p>

<p>让我们对比一下C++11标准的写法:</p>

<h3>1.b C++11.Lambda：构造一个functor</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecIn</span><span class="p">;</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the orgin value in vecIn：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一眼望去竟是boost的Lambda用法简洁。</p>

<h3>2.a boost.Lambda：修改参数的内容</h3>

<p>上面的例子，我们使用Lambda表达式，借助于for_each，对vector中的元素进行了访问，那我们可以修改vector的内容吗？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the values in vecIn after Square：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span> <span class="o">*=</span> <span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="p">);</span><span class="c1">//打印</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子，功能是对vecIn中的值求平方。占位符boost::Lambda::_1直接用引用的方式得到了传入的参数（vecIn的元素），结果直接改写进了vecIn。</p>

<h3>2.b C++11.Lambda：修改参数的内容</h3>

<p>修改1.b函数定义为引用即可</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the values in vecIn after Square：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">val</span> <span class="o">*=</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="c1">//打印：</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.a boost.Lambda：变量捕获</h3>

<p>boost.Lambda可以很方便的以引用的方式捕获local变量，看例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the sum of values in vecIn：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">sum</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.b C++11.Lambda：变量捕获</h3>

<p>C++11捕获变量，可控性更强，我们可以指定捕获方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the sum of values in vecIn：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">sum</span><span class="p">](</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">sum</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.a boost.Lambda：返回值</h3>

<p>有时需要匿名函数返回结果，比如作为std::find_if类似函数的Predicate函数时，这种能力boost.Lambda当然也是胜任的，整个Lambda表达式的结果，即是函数的返回值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">IsOdd</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;100 is Odd？ &quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="o">&lt;&lt;</span><span class="n">IsOdd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子创建了一个检测参数是否是奇数的匿名函数，并保存到IsOdd对象中，然后对其进行了调用。例子同样演示了如何将一个boost.Lambda表达式存储起来，后续使用的方法。</p>

<h3>4.b C++11.Lambda：返回值</h3>

<p>C++11的返回值，必须使用return语句，返回值的类型有些时候也需要显示指定。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">IsOdd</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)[](</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span><span class="k">return</span> <span class="n">val</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;};</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;100 is Odd？ &quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="o">&lt;&lt;</span><span class="n">IsOdd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5. 上面四个例子的运行结果</h3>

<pre><code>the orgin values in vecIn：
1,2,3,
the values in vecIn after Square：
1,4,9,
the sum of values in vecIn：
14
100 is Odd？ false
</code></pre>
]]></content>
    
  </entry>
  
</feed>