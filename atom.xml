<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2013-12-26T23:43:00+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[为什么要学Ruby]]></title>
    <link href="http://towriting.com/blog/2013/12/26/learn-ruby/"/>
    <updated>2013-12-26T21:15:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/26/learn-ruby</id>
    <content type="html"><![CDATA[<p>  最早是在09年知道Ruby的，大概是知道Python的同时。当然这里的知道是仅限于名字上的。那是上大学，偏机械的专业，某些同学到今天可都是不会装系统的。而和这些不懂电脑的同学大谈各种计算机知识、编程语言的特点，是我一大爱好：脚本语言是一种易学的语言，要不然为何叫”脚本“，是因为用脚都可以学会；脚本语言里面有三P：Python，Php, Perl，都是极好的，当然还有一个Ruby，不过是日本人发明的，你如果不爱国的话，倒可以学一学&hellip;</p>

<p>  最早的关于Ruby的记忆，就是和同学的这些对话了。毕业后，狂补C++的知识，不惜一切的想要提高C++的技术水平，听闻C++程序员必须要辅修一门脚本语言，于是Perl，Python，Ruby三门语言在我脑中角逐，最后Python胜出，于是啃了两三本Python的书籍，断断续续写了一些脚本，逢人就推荐Python，&#8221;life is short, use Python!&ldquo;, Python是个极佳的工具语言，Python的学习反向促进了对C++的领悟，Lambda的概念是从Python中学到的，当然后来自己又追逐Lambda的源头Haskell，就不多说了。</p>

<p>  而自己为什么又要开始学Ruby了呢？不爱国了吗？当然开玩笑了，互联网的世界那里有国别之分，而且我们谋生用的技术那些是国产呢？</p>

<p>  从Ruby很火可以推断Ruby应该是个不错的语言，除却这个原因和学习本身就是一个快乐的过程外，以下是自己主观上想要学习Ruby的原因：</p>

<h3>C++学习之痒</h3>

<p>当然C++现在处于并且将长期处于自己技术方向的中心。都说C++语法都让人着迷，然自己好像陷入C++的汪洋大海中了，看到这些<a href="http://towriting.com/blog/2013/12/12/cpp-blogs/">大牛的博文</a>，始觉自己对C++了解的太少了。短暂的休息是为了下一次冲锋，C++的深入，先放一放。</p>

<h3>美丽新世界</h3>

<p><a href="http://en.wikipedia.org/wiki/Andy_Hunt_(author)">Andrew Hunt</a>的经典名著<a href='http://www.amazon.cn/gp/product/B004GV08CY/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004GV08CY&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>程序员修炼之道</a>中提到，程序员每年要学习一门语言。一些教授所言的“语言不重要，所有语言都是相通的“这种观点经不起推敲。人为什么要学习外语，无外乎两种原因：了解语言背后的思维习惯和掌握语言背后的信息价值。编程语言和自然语言一样的，学习一门新的编程语言，可以接触到新的思维习惯和语言先天的优势（语法糖、框架、库、社区等）。</p>

<h3>劳动是必需品</h3>

<p>中学时，记得关于共产主义的描述有一条是：<code>劳动已不仅是谋生的手段，而且成了生活的第一需要</code>，设想一下，到那时休5做2，想要加班都会被领导批评，要层层审批才能通过。那时的劳动定是快乐的，可这种乌托邦的社会，你我未必可以赶的上，我们如何爱上我们的工作？</p>

<p><code>Ruby, 让你爱上你的工作</code>。这是某些人打出的Ruby的口号，我特别想证明这个口号是对的，或是错的。</p>

<h3>现实的考量</h3>

<p>Ruby在国内算是小众的语言，但如果要转Ruby的话，能否找到工作，刚才在Indeed上搜索Ruby:948条,Python:4,474条;Haskell:7条；机会确实不太多，再看Ruby的趋势，左侧全球的Ruby热度减退，但右侧国内Ruby热度13年井喷，所以不久以后Ruby还是可以学以致工作的。</p>

<script type="text/javascript" src="http://towriting.com//www.google.com/trends/embed.js?hl=en-US&q=/m/06ff5&cmpt=q&content=1&cid=TIMESERIES_GRAPH_0&export=5&w=400&h=330"></script>




<script type="text/javascript" src="http://towriting.com//www.google.com/trends/embed.js?hl=en-US&q=Ruby&geo=CN&cmpt=geo&content=1&cid=TIMESERIES_GRAPH_0&export=5&w=350&h=330"></script>


<h3>为了自由</h3>

<p>当然并没有人强暴我的心理或肉体，我指的自由是，可以做一个自由职业者。这当然这是3、5年后的目标，而靠C++实现这个目标貌似不容易，如今是Web与APP的天下了，ROR，貌似是一个适宜自由职业者开发web产品的框架。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《C++标准库第二版 上册》笔记]]></title>
    <link href="http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1/"/>
    <updated>2013-12-18T23:27:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1</id>
    <content type="html"><![CDATA[<p>p63 a pair&lt;> using a type that has only a nonconstant copy constructor will no longer compile.</p>

<p>p64 std::piecewise_construct is passed as the first argument is class Foo forced to use a constructor that takes the elements of the tuple rather than a tuple as a whole.</p>

<p>p65 The make_pair() function template enables you to create a value pair without writing the types explicitly.</p>

<p>p67 pair used in functions that return two values.</p>

<p>p68 tuples extend the concept of pairs to an arbitrary number.we can access elements with the get&lt;>() function template.</p>

<p>p70 A tuple type can be a reference. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="n">tuple</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&amp;&gt;</span> <span class="n">t</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>For element access, you must know the index of element at complier time.It is also a complier error if you pass a invalid index.
Make_tuple can create tuple without special the type of element.
By using references with make_tuple(), you can extract values of a tuple back to some other variables. e.g.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span><span class='line'><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>p72 std::tie() creates a tuple of references. the use of std::ignore allows ignoring tuple elements while parsing with tie()</p>

<p>p75 You can initialize a two-element tuple with a pair.Also, you can assign a pair to a two-element tuple.</p>

<p>p76 Tow types of smart pointer:</p>

<ul>
<li>shared_ptr. Multiple smart pointer can refer to the same object.</li>
<li>unique_ptr. only one smart pointer can refer to this object at a time.</li>
</ul>


<p>p77 shared_ptr. you can define other ways to clean up object.</p>

<p>p78 shared_ptr can&rsquo;t assign a new ordinary pointer. but can use reset function to reset the pointer.</p>

<p>p79 assigning a nullptr to a shared_ptr would delete the ownship.</p>

<p>p80 Smart pointer, when use new[] to create an array of object, you must define your own deleter.</p>

<p>p85 weak_ptr allows sharing but not owning an object.</p>

<p>p90 You should always directly initialize a smart pointer the moment you create the object with its associated resource.</p>

<p>p95 Aliasing constructor,The constructor taking another shared_pointer and an additional raw pointer.</p>

<p>p96 shared pointers are not thread safe.</p>

<p>p101 You can&rsquo;t copy or assgin a unique pointer if you use the ordinary copy semantics, but can use move semantics.</p>

<p>p102 assgining nullptr is also possible, which has the same effect as calling reset().</p>

<p>p103 The Reason that no std::move is necessary in the return statement of source() is than according to the language rules of c++11, the compiler will try a move automaticallly.</p>

<p>p105 The c++ stl provides a partial spartial specialization of class unique_ptr for array: std::unique_ptr<code>&lt;std::string[]&gt;</code></p>

<p>p110 unique_ptr not necessarily defined as T*</p>

<p>p115 The new concept of numeric limits has two advantages: first, it offers more type safety. second, it enables a programmer to write templates that evaluate these limits.</p>

<p>p119 all members of numeric_limits are declared as constexpr.</p>

<p>p121 you can query for any arbitrary type whether or not it has numeric limits defined.</p>

<p>p125 Type Traits:</p>

<ul>
<li>Type Predicates</li>
<li>Type Relations</li>
<li>Type Modifiers</li>
</ul>


<p>p130 A reference to a constant type is not constant</p>

<p>p136 Note that swap provides an exception specification</p>

<p>p158 Not that time_t usually is just the number of seconds since the UNXI epoch. bu this is not guaranteed.</p>

<p>p166 The marjor advantage of iterators is that they offer a small but common interface for any arbitrary container type.</p>

<p>p166 The concept of STL is base on a separation of data and operations. The data is managed by container classes, and the operations are defined by configurable algorithms. iterators are the glue between these two components.</p>

<p>p167 There are three general kinds of containers:</p>

<ul>
<li>Sequence contains are ordered collections in which every element has a certain postion.</li>
<li>Associative containers are sorted collections in which the postion of an element depends on its value due to a certain sorting criterion: set multiset map multimap.</li>
<li>Unorderd containers. neither the order of insertion nor the value of the inserted element has an influence on the postion of the element, and the position might change over the lifetime of the container: unordered_set,undered_multiset,undered_map,undered_multimap.</li>
</ul>


<p>p170 size() is provided for any container class execept singly linked lists(class forward_list)</p>

<p>p170 deque rhymes with &ldquo;check&rdquo;</p>

<p>p171 the push_front is not provided for vectors, because it would have a bad runtime for vectors, but is is possible to insert an element at the beginning of a vector.</p>

<p>p171 using array. with a safer and more convenient interface.</p>

<p>p176 forward_list is in principle just a limited list.</p>

<p>p177 The major advantage of associative containers is that finding an element with a specific value is rather fast.</p>

<p>p177 you can consider a set as a special kind of map, in which the value is identical to the key. in fact, all these are implemented by using the same basic implementation of a binary tree.</p>

<p>p180 C++11 guarantees that newly inserted elements are inserted at the end of equivalent elements that multisets and multimaps already contain.</p>

<p>p180 unordered containers are typically implemented as a hash table. the goal is that each element has its own position so that you have fast access to each element.</p>

<p>p185 associative array: an array whose index is not an integer value.</p>

<p>p188 an iterator is an object that can iterate over elements. iterators share the same interface but have different types.</p>

<p>p189 every container defines two iterator types:</p>

<ul>
<li>container::iterator is provided to iterator over elements in read/write mode</li>
<li>container::const_iterator is provided to iterator over elements in read mode</li>
</ul>


<p>p199 To write generic code you should not use special operations for random-access iterators.</p>

<p>p199 Algorithms are not member functions of the container classer but instead are global functions that operator wich iterators. this concept reduces the amount of code and increases the power and the flexibility of the library.</p>

<p>p208 Multiple Ranges, make sure that the second and additional ranges have at least as many elements as the first range.</p>

<p>p209 associative and unordered containers cannot be used as a destination for overwriting algorithms.</p>

<p>p210 Interator Adapters</p>

<p>p210 Insert Interators solve the problem of algorithms that write to destination that does not have enough room.</p>

<p>p212 general insertor call insert()</p>

<p>p213 <code>istream_iterator&lt;string&gt;()</code> calls the default constructor of iterators that creates a so-called end-of-stream iterator.</p>

<p>p214 reverse iterators rbegin()\rend()</p>

<p>p220 distance if iterator were random-access, you could with &ldquo;&ndash;&rdquo;</p>

<p>p221 to make agorithms as flexible as possible there are good reason not requrie that interator know their container.</p>

<p>p223 a container might have member functions that provide much better performance that algorithms</p>

<p>p226 predicates must stateless</p>

<p>p232 Lambda no default constructor and no assignment operator.</p>

<p>p235 function object are functions with states</p>

<ul>
<li>fnctction object has its own type</li>
<li>function object may faster than ordinary functions.</li>
</ul>


<p>p241 Binder to combine predefined function objects with other values or use special cases.</p>

<p>p248 it&rsquo;s turns out that exception specifications could cause performance penalties, so they were replaced by noexcept with c++11.</p>

<p>p249 if you need a transaction-safe container, you should use a list.</p>

<p>p254 container&rsquo;s operators are not safe in the sense that they check for every possible error.</p>

<p>p257 since c++11 you can use move constructor</p>

<p>p258 Move Sytax: The contents of the container on the right-hand side are undefined afterwared:</p>

<p>p258 forware_list not provided size()</p>

<p>p260 all containers except vectors and deques guarantee that iterators an references to elements remianing valid if other elemenets are deleteed.</p>

<p>p262 array&lt;> default initialized.</p>

<p>p267 array you must not pass an iterator as the address of the first element.</p>

<p>p271 vectors： capacity(), which returns the number of elements a vector could contain in its actual memory.</p>

<p>p271 If the only reason for initialization is to reserve memory, you should use reserve()</p>

<p>p271 it is not possible to call reserve for vectors to shrink the capacity.</p>

<p>p282 For vector<bool> the return type of subscript operator is an auxiliary class.</p>

<p>p283 Deque is typically implemented as a bunch of individual blocks.</p>

<p>p284 Deque provide no support to control the capacity and the momnet of reallocation.Howerer reallocation may perform better than for vectors because according to their typical internal structure, deques don&rsquo;t have to copy all elemenets on reallocation.</p>

<p>p284 Blocks of memory might get freed when they are no longer used(implementation specific)</p>

<p>p286 You could say that lists are transaction safe.</p>

<p>p301 The design goal to have &ldquo;zero space or time overhead relative to a hand-written C-stype single linked list.</p>

<p>p303 forward_list provide no support size(), but you can use std::distance(list.begin(),list.end())</p>

<p>p315 you cant change set&rsquo;s value from interator</p>

<p>p316 not that the sorting criterion is also used to check for equivalence of two elements in the same container.</p>

<p>p338 std::for_each(coll.begin(), coll.end(), [] (decltype(coll)::value_type &amp;elem) {}
p342 piecewise_construct emplace.</p>

<p>p345 [] is slower than the insert()</p>

<p>p366 unorder container</p>

<p>p366 unorder containers are optimized for fast searching of elements</p>

<p>p386 using the noninvasive approach is simple, you need only objects that are able to iterate over the elements of an array by using the STL iterator interface.</p>

<p>p386 Any Thing that behaves like an iterator is an iterator.</p>

<p>p437 forward iterators, it is guaranteed that for two forward iterators that refor to the same elemnet, operator == yields true and that they will refer to the same value after both are incremented.</p>

<p>p442 to be able to change container and iterator types, you should use advance</p>

<p>p460 for insert iterator, a bad hint might even be worse than no hint.</p>

<p>p471 writing user-defined iterators</p>

<p>p476 each function object has its own type</p>

<p>p479 by default, function objects are passed by value rather than by reference.</p>

<p>p483 for_each can return a value</p>

<p>p485 a predicate should always be stateless. you should declare operator() as const. but lambda not exist this problem.</p>

<p>p494 bind also could bind data member.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows提供的INI接口不是线程安全的]]></title>
    <link href="http://towriting.com/blog/2013/12/17/ini-muti-thread/"/>
    <updated>2013-12-17T23:28:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/17/ini-muti-thread</id>
    <content type="html"><![CDATA[<p>INI是Windows系统下人们喜闻乐见的一种配置存储方式。Windows提供了一套简单的接口操作INI文件，但它们并不是线程安全的，对于这一点，这些函数比如<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms725501(v=vs.85).aspx">WritePrivateProfileString</a>的文档中并没有提到。
据<a href="http://mfctips.com/tag/getprivateprofilestring/">这篇文章</a>介绍:</p>

<h2>WritePrivateProfileString:</h2>

<ul>
<li>WritePrivateProfileString内部使用NtCreateFile访问文件，共享方式设置为：FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE。使用NtLockFile，FailImmediately设置为False，ExlusiveLock设置为True来锁定文件。</li>
<li>这意味着WritePrivateProfileString是非线程安全的，是进程安全的（非远程机器）。</li>
</ul>


<p>我们目前的软件有大量的并发操作INI的行为，没出现过什么问题只能说是幸运了（亦或是不幸）。同事并不太相信以上结论，让我们用事实证明，写一段并发操作INI的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &quot;stdafx.h&quot;</span>
</span><span class='line'><span class="cp">#include &lt;Windows.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'><span class="cp">#include &lt;process.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cassert&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">GetIniName</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strIniName</span><span class="p">;</span>
</span><span class='line'>  <span class="n">strIniName</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">MAX_PATH</span><span class="p">);</span>
</span><span class='line'>  <span class="n">strIniName</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">GetModuleFileName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">TCHAR</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">strIniName</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span> <span class="n">strIniName</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
</span><span class='line'>  <span class="n">strIniName</span> <span class="o">+=</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;.ini&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">strIniName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">WriteIniInThread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">pText</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">TCHAR</span> <span class="o">*</span><span class="n">pSec</span> <span class="o">=</span> <span class="p">(</span><span class="n">TCHAR</span><span class="o">*</span><span class="p">)</span><span class="n">pText</span><span class="p">;</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">pSec</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strVal</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strIni</span> <span class="o">=</span> <span class="n">GetIniName</span><span class="p">();</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">strVal</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_wstring</span><span class="p">(</span><span class="n">_Longlong</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span><span class='line'>      <span class="n">WritePrivateProfileString</span><span class="p">(</span><span class="n">pSec</span><span class="p">,</span> <span class="n">strVal</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">strVal</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">strIni</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&gt;</span> <span class="n">threadTexts</span><span class="p">;</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="o">&gt;</span> <span class="n">threadHandles</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">60</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strText</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;Thread&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">strText</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_wstring</span><span class="p">(</span><span class="n">_Longlong</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span><span class='line'>      <span class="n">threadTexts</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">strText</span><span class="p">);</span>
</span><span class='line'>      <span class="n">threadHandles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">HANDLE</span><span class="p">(</span><span class="n">_beginthread</span><span class="p">(</span><span class="n">WriteIniInThread</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">threadTexts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">())));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">WaitForMultipleObjects</span><span class="p">(</span><span class="n">threadHandles</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">threadHandles</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码很简单，开60个线程同时往一个INI文件里写东西，让我们对比一下多线程操作INI和非多线程操作的结果，左侧是不使用多线程操作的结果（只贴出前50行）：</p>

<p><img class="pull-left" src="http://towriting.com/images/posts/ini-muti-thread/result.png"></p>

<p><img class="pull-left" src="http://towriting.com/images/posts/ini-muti-thread/error_result.png"></p>

<p></br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br></p>

<p>结果一目了然。（多线程同时操作INI时，每次的结果可能都不一样的）。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我为什么从同花顺离职]]></title>
    <link href="http://towriting.com/blog/2013/12/16/why-i-quit-ths-job/"/>
    <updated>2013-12-16T23:42:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/16/why-i-quit-ths-job</id>
    <content type="html"><![CDATA[<p>  最近知乎上很流行的一个问题是<a href="http://www.zhihu.com/topic/19909711">为什么从 X 离职</a>，倒退一年快到自己决定离职的日子了，趁热闹，也说说自己为什么离职。</p>

<p>  首先，照例发自肺腑的感谢一下同花顺，同花顺的日子是我C++进步最快的一段时间，在这里我接触到了正规的开发流程，并且遇到了一个很棒的团队，那时的日子每天都很开心。</p>

<hr />

<p>  切入正题，我为什么离开同花顺：</p>

<h3>待遇认知的分歧</h3>

<p>　员工离职的理由千万条，但薪水待遇肯定是大部分人选择离开的最重要的原因，不过大部分人不肯承认罢了。离职的导火索就是公司的年终奖，入职Offer上明确写明是3-6个月，可实际发到手的一月左右。我表明了自己的不满，公司领导以程序员不是钟点工，薪水是靠产品的收益决定的来“开导”我。这种观点不错，但是却是站在创业者的角度看的。自己作为一个打工者，站在打工者的角度上讲，程序员的待遇在市场经济条件下，是由供求关系决定的，并上下浮动于程序员个体的能力和工作产出。何况公司远没到揭不开锅的程度，你可以不按约定给我应有的Money，但不能忽悠我。</p>

<h3>人为什么要工作？</h3>

<p>　马斯洛总结了人的<a href="http://en.wikipedia.org/wiki/Maslow's_hierarchy_of_needs">五种需求</a>。</p>

<p>　刚毕业时囊空如洗，一头扎进工作中，完全是为了实现人的第一种需求-生理（存）需求。自己前两年的工作确实是为了实现生存需求，但当工作两三年，衣食无虞，现在仍然工作的原因好像是上一阶段的惯性。有些人可能为了实现“昂贵”的生理需求（车房等）而工作一辈子，但对我而言这种动力不足以使我能持续激情的工作。</p>

<p>　顺着马斯洛的需求金子塔往上看，塔顶是自我实现的需求，这是人的最高级的需求。</p>

<p>　是否可以提高自己的能力，是我衡量一份工作是否适合自己的重要指标。以前从没有在内心中将自我能力的提高作为工作的一个直接原因，觉得能力提高（自我实现需求）不过是为了能挣更多钱（生理需求），觉得后者才是工作的直接原因。看来我错了，自我能力的提高属于自我实现的需求，完全是促使我们工作的高级原因。而可贵的是，高级的需求好像兼容低级的需求，就是你在实现了自我实现的需求后，生理需求自然可以满足了。并且生理需求容易满足，自我实现需求难以满足，而自我实现的满足可以给人带来持久且真正的满足。在我看来，工作中的自我实现包括两点：自我能力提高和我（们）创造了有价值的东西。</p>

<p>  而同花顺，据观察感知是无法满足我这两种需求的，尤其第二种，我的判断是错误的吗？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你们是勤劳还是懒惰的程序员？]]></title>
    <link href="http://towriting.com/blog/2013/12/15/are-your-programmers-working-hard-or-are-they-lazy/"/>
    <updated>2013-12-15T17:17:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/15/are-your-programmers-working-hard-or-are-they-lazy</id>
    <content type="html"><![CDATA[<p><img class="pull-right" src="http://towriting.com/images/posts/working-hard/work-smart-not-hard.jpg">
当人们从事体力劳动时，很容易判断他们的努力程度。你可以看到肢体运动和汗水。并且可以看到他们的劳动成果：高楼拔地，稻谷归仓&hellip;。承认和褒奖辛勤的劳作是人的一种本能，是体力运动迷人的一个原因。然而当管理创造性技术员工时，褒扬辛勤劳作的本能就有问题了。高效的员工有时候看起来并没有非常努力的工作。</p>

<p>时光回到2004年，那时我在一家有线电视公司的收费和服务开通系统项目部做初级工程师。这个系统很大，像所有大系统一样，它由一些小的独立的组件构成，每个组件由一些人或小的团队开发。模拟和数字开通系统是几乎毫无关联的系统，由不同的团队分别开发。</p>

<p>模拟电视组计划基于Microsoft Biztalk的一个早期版本开发他们的系统。由我们四名员工和一个微软的团队来开发这个系统和进行生产运行。他们看起来都工作的很辛苦。经常听说他们在晚上和周末加班。一旦出现任何运行故障，每个人都必须放下手头的工作，围在一个人的桌子前，讨论并提出解决意见。正如我们看到的，他们的队伍凝成了一条绳，并且每个成员都非常的努力。</p>

<p>而数字电视组的风貌则截然不同了。初期所有的代码几乎都是一个叫做Dave的家伙写的，我作为初级程序员主要负责一些维护工作。最初我对这些代码很费解，明明一个函数可以搞定的事情，却用好多只有几行代码的类来实现，一些同事也抱怨Dave把事情搞复杂了。但Dave建议我读一些面向对象的书籍，并给我讲解设计模式、<a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID原则</a>、单元测试。于是这些代码在我脑中生动起来，深入看过这些代码之后，不得不赞叹其设计的优雅：改变一些代码非常简单，实现新功能根本没什么难的，有单元测试意味着甚少有BUG。</p>

<p>结果是我们看起来工作的很随意。每天下午五点半回家，周末从不加班，从来不会挤在一个人的桌子边胡乱猜测系统的哪个部分出问题了。外人肯定以为我们接到的工作要比模拟电视团队的轻松许多。事实上是，需求差不多，我们只是有更好的设计和单元测试等的基础支撑。</p>

<p>加薪时，公司宣布以表现作为评定的标准。轮到我和老板对话时，老板讲到给那些辛勤工作的人加更多的薪水是很公平的，我们的团队并不以公司事情为己任，比不上那些牺牲了自己晚上和周末时间的英雄们。</p>

<p>公司应该做个实验，观察对比良好设计和团队表现这两个因素的效果。大部分组织是不会做这个对比的。很难判断一个挥洒汗水、废寝忘食、日夜待命的人是否有胜任复杂系统开发的能力。也很难说朝九晚五，上班淘宝的家伙是高质量代码的编程好手，还是仅仅分配到简单的任务？但常人看到的只是第一种人努力工作，而第二种没有。勤快是好的，懒惰就是坏的吗？</p>

<p>我必须说困苦工作是失败的前兆。软件开发在压力、中断的环境中不会进行的很好。工作很长时间不是个好主意。有时解决一个难题的方法是停止想它，出去溜一圈，甚至睡一大觉让潜意识去解决掉它。我最喜欢的一本书是20世纪著名的数学家哈代写的<a href='http://www.amazon.cn/gp/product/B0011F7ORK/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011F7ORK&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>一个数学家的辩白</a>。书中提到哈代自己的作息是这样的：早上四个小时的工作然后下午看板球。他提到超过四个小时的连续脑力工作是徒劳和无意义的。</p>

<p>我想对管理者说，要以结果以可以工作的软件来衡量人，而不是以人工作时的辛苦程度。你应该衡量员工的产出，而不是坐在他们旁边观察他们不自在的操作着IDE，抑或是围在一块儿相互“帮助”。</p>

<p>由Towriting.com翻译自：<a href="http://mikehadlow.blogspot.com/2013/12/are-your-programmers-working-hard-or.html">Code rant: Are Your Programmers Working Hard, Or Are They Lazy?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boost.Lambda与C++11.Lambda的用法对比]]></title>
    <link href="http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda/"/>
    <updated>2013-12-13T22:38:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda</id>
    <content type="html"><![CDATA[<p>我们知道C++11已经支持了Lambda表达式，大部分新的编译器都已支持Lambda。但boost里面的Lambda还是有存在的必要，因为并不是每个人都有选择自己编译环境的权利。</p>

<p>让我们通过几个例子对比C++11.Lambda来学习一下boost.Lambda的用法，详细的C++11.Lambda用法可以看这里：<a href="http://towriting.com/blog/2013/08/11/lambda-closures/">C++11系列-Lambda表达式</a></p>

<h3>1.a boost.Lambda：构造一个functor</h3>

<p>boost.Lambda的使用是基于placeholder: <code>boost::Lambda::_1</code>,<code>boost::Lambda::_2</code>,<code>boost::Lambda::_3</code>可以理解为Lambda表达式的第一、第二、第三个参数。Lambda的出现利索地解决了STL算法库函数的使用不便。让我们首先看一个最简单的boost.Lambda与std::for_each结合的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecIn</span><span class="p">;</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the orgin values in vecIn：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子，使用std::for_each遍历vector中的元素并打印内容。boost::Lambda::_1这个占位符表示for_each遍历时传进来的第一个参数，<code>std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;","</code>可以理解为临时创建出来的匿名函数，函数的定义是<code>void(int)</code>。</p>

<p>让我们对比一下C++11标准的写法:</p>

<h3>1.b C++11.Lambda：构造一个functor</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecIn</span><span class="p">;</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">vecIn</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the orgin value in vecIn：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一眼望去竟是boost的Lambda用法简洁。</p>

<h3>2.a boost.Lambda：修改参数的内容</h3>

<p>上面的例子，我们使用Lambda表达式，借助于for_each，对vector中的元素进行了访问，那我们可以修改vector的内容吗？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the values in vecIn after Square：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span> <span class="o">*=</span> <span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="p">);</span><span class="c1">//打印</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子，功能是对vecIn中的值求平方。占位符boost::Lambda::_1直接用引用的方式得到了传入的参数（vecIn的元素），结果直接改写进了vecIn。</p>

<h3>2.b C++11.Lambda：修改参数的内容</h3>

<p>修改1.b函数定义为引用即可</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the values in vecIn after Square：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">val</span> <span class="o">*=</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="c1">//打印：</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.a boost.Lambda：变量捕获</h3>

<p>boost.Lambda可以很方便的以引用的方式捕获local变量，看例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the sum of values in vecIn：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">sum</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.b C++11.Lambda：变量捕获</h3>

<p>C++11捕获变量，可控性更强，我们可以指定捕获方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the sum of values in vecIn：&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vecIn</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecIn</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">sum</span><span class="p">](</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">sum</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.a boost.Lambda：返回值</h3>

<p>有时需要匿名函数返回结果，比如作为std::find_if类似函数的Predicate函数时，这种能力boost.Lambda当然也是胜任的，整个Lambda表达式的结果，即是函数的返回值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">IsOdd</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">Lambda</span><span class="o">::</span><span class="n">_1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;100 is Odd？ &quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="o">&lt;&lt;</span><span class="n">IsOdd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子创建了一个检测参数是否是奇数的匿名函数，并保存到IsOdd对象中，然后对其进行了调用。例子同样演示了如何将一个boost.Lambda表达式存储起来，后续使用的方法。</p>

<h3>4.b C++11.Lambda：返回值</h3>

<p>C++11的返回值，必须使用return语句，返回值的类型有些时候也需要显示指定。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">IsOdd</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)[](</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span><span class="k">return</span> <span class="n">val</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;};</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;100 is Odd？ &quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="o">&lt;&lt;</span><span class="n">IsOdd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5. 上面四个例子的运行结果</h3>

<pre><code>the orgin values in vecIn：
1,2,3,
the values in vecIn after Square：
1,4,9,
the sum of values in vecIn：
14
100 is Odd？ false
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[那些C++牛人的博客]]></title>
    <link href="http://towriting.com/blog/2013/12/12/cpp-blogs/"/>
    <updated>2013-12-12T20:57:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/12/cpp-blogs</id>
    <content type="html"><![CDATA[<p>现整理收集C++世界里那些“牛人”的个人博客。凡三类：一是令人高山仰止的大牛，对C++语言本身产生过深远的影响的人；二是C++运用炉火纯青的高手，有原创性的技术干货；三是中文世界里的C++牛人。</p>

<h2>C++大牛的博客</h2>

<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/BjarneStroustrup.jpg" width="120" height="150"></p>

<ul>
<li><strong>Bjarne Stroustrup的博客</strong>: <a href="http://www.stroustrup.com/">Bjarne Stroustrup&rsquo;s Homepage</a></li>
</ul>


<p>Bjarne Stroustrup，不认识的可以去面壁了，没有他，就没有我们现在的饭碗。Bjarne Stroustrup是丹麦人，目前任教于<a href="http://en.wikipedia.org/wiki/Texas_A%26M_University">TAMU</a>。他的Homepage和他的书籍<a href='http://www.amazon.cn/gp/product/B003EIKI0C/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B003EIKI0C&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>The C++ Programming Language</a>一样，都是百科全书级的，如果你认真研究，你也会成为你同事或周围人的C++之父。</p>

<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/ScottMeyers.jpg" width="120" height="150"></p>

<ul>
<li><strong>Scott Meyers的博客</strong>: <a href="http://scottmeyers.blogspot.com/">The View from Aristeia</a></li>
</ul>


<p>Scott Meyers，不多介绍，世界上几乎每个C++程序员都应该知道的名字，畅销书：<a href='http://www.amazon.cn/gp/product/B004G72P24/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004G72P24&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Effective C++</a>, <a href='http://www.amazon.cn/gp/product/B004IP8BD6/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004IP8BD6&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>More Effective C++</a>的作者。博客长期更新，就凭Scott Meyers这个名字，就值得一读。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/stan_lippman.jpg" width="120" height="150"></p>

<ul>
<li><strong>Stanley B.Lippman的博客</strong>: <a href="http://blogs.msdn.com/b/slippman/">Stan Lippman&rsquo;s BLog</a></li>
</ul>


<p>Lippman，C++第一个编译器<a href="http://en.wikipedia.org/wiki/Cfront">Cfront</a>的实现者，最大的贡献是凭借其著作<a href='http://www.amazon.cn/gp/product/B00ESUIL0O/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ESUIL0O&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>C++ Primer</a>在世界范围内普及了C++。Lippman本人算是个励志故事，父母是蓝领移民，他为了融入美国主流社会而努力工作，终于取得了今日的成就，他的另一本书<a href='http://www.amazon.cn/gp/product/B006QXQXTM/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B006QXQXTM&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Inside The C++ Object Model</a>让我知道了C++代码编译后的样子，不过我不知他写该书时发生了什么事情，因为书中有大量的低级错误，与前一本书的严谨截然相反。列出他的博客，更多的是因为他是C++牛人中无法绕过的一个，而其博客久不更新，早已荒芜，而且是MSDN上的专栏，可能不太能提起人多大兴趣去读。</p>

<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/HerbSutter.jpg" width="120" height="150"></p>

<ul>
<li><strong>Herb Sutter的博客</strong>: <a href="http://herbsutter.com/">Sutter’s Mill: Herb Sutter on software, hardware, and concurrency</a></li>
</ul>


<p>Herb Sutter, C++标准委员会主席，目前就职于微软。代表作为C++ Exceptional系列：<a href='http://www.amazon.cn/gp/product/B008CGKUBS/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008CGKUBS&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Exceptional C++</a>, <a href='http://www.amazon.cn/gp/product/B004IUISIO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004IUISIO&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>More Exceptional C++</a>, <a href='http://www.amazon.cn/gp/product/B00114BFTO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00114BFTO&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Exceptional C++ Style</a>, 因封面头像蓄须，被国人称“小胡子”，不过貌似现在刮干净了。博客更新很快，内容杂乱，有技术亦有资讯，gotw系列个人感觉不错。</p>

<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/AndreiAlexandrescu.jpg" width="120" height="150"></p>

<ul>
<li><strong>Andrei Alexandrescu的博客</strong>: <a href="http://erdani.com/index.php/articles/">Official website of Andrei Alexandrescu</a></li>
</ul>


<p>Andrei Alexandrescu，罗马尼亚人，目前任职于FaceBook, C++天书<a href='http://www.amazon.cn/gp/product/0201704315/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=0201704315&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Modern C++ Design: Generic Programming and Design Patterns Applied</a>的作者，凭借此书使C++社区认识到模板编程鬼斧神工之力。后来不满C++而转投D语言，是D语言的主要开发者。不过他的博客貌似好久不更新了，内容也大多学术气息浓厚。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/dave_abrahams.jpg" width="120" height="150"></p>

<ul>
<li><strong>David Abrahams的博客</strong>: <a href="http://daveabrahams.com/">Dave Abrahams: Home Page | Stuff I wrote, things I did, etc</a></li>
</ul>


<p>David Abrahams，美国人，C++标准委员会成员，将exception-safety加入标准，Boost.org的联合创始人，<a href='http://www.amazon.cn/gp/product/B002WB1J0U/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B002WB1J0U&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>C++ Template Metaprogramming</a>的作者。但博客内容一般，最后一篇内容更新时间是12年的，内容不多，也没有太多亮点，不过笑容却是感染了我。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/BartoszMilewski.jpg" width="120" height="150"></p>

<ul>
<li><strong>Bartosz Milewski的博客</strong>：<a href="http://bartoszmilewski.com/">Bartosz Milewski&rsquo;s Programming Cafe：Concurrency, Multicore, C++, Haskell</a></li>
</ul>


<p>Bartosz Milewski，波兰人，物理系毕业的计算机大牛，曾就职于微软。<a href='http://www.amazon.cn/gp/product/B009TB3ZBW/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009TB3ZBW&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>c++ in action</a>的作者。博客更新频繁，内容密实，观点前卫，对C++的不满流露于字里行间，多以Haskell对比C++的不足，然后实现一些函数式编程风格的C++代码。</p>

<p>不才曾翻译过他的文章：<a href="http://towriting.com/blog/2013/09/23/edward-chands/">C++手爱德华</a></p>

<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/anthony_williams.jpg" width="120" height="150"></p>

<ul>
<li><strong>Anthony Williams的博客</strong>：<a href="http://www.justsoftwaresolutions.co.uk/blog/">Just Software Solutions</a></li>
</ul>


<p>Anthony Williams，英国人，一个记事起就开始写程序的人。<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html">Boost.Thread</a>的作者，参与了C++11 Thread的标准化工作。博客有一部分技术文章，也有一些标准化和他自己维护的一些库的记录，对C++多线程感兴趣的可以读一下他的书：<a href='http://www.amazon.cn/gp/product/1933988770/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1933988770&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>C++ Concurrency in Action</a>，市面上第一本讲解C++11并发的权威书籍。</p>

<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/AlexanderStepanov.jpg" width="120" height="150"></p>

<ul>
<li><strong>Alexander A. Stepanov的博客</strong>：<a href="http://www.stepanovpapers.com/">Collected Papers of Alexander A. Stepanov</a></li>
</ul>


<p>Alexander A. Stepanov，出生于莫斯科，STL之父，<a href='http://www.amazon.cn/gp/product/B006P7V73G/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B006P7V73G&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>编程原本</a>的作者。Alexander A. Stepanov的这个博客如其名，是他个人学术论文的整理，学术价值应该是蛮高吧，不过像我这种低级程序员只能远观了。</p>

<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/austern.jpg" width="120" height="150"></p>

<ul>
<li><strong>Matt Austern的博客</strong>: <a href="http://lafstern.org/matt/">Matt Austern&rsquo;s Home Page</a></li>
</ul>


<p>Matt Austern, 现任职于Google, 前C++标准委员会主席，SCG STL的最初实现者，<a href='http://www.amazon.cn/gp/product/0201309564/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=0201309564&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Generic Programming and the STL</a>的作者。Matt Austern的这个博客其实是个人主页，没有太多技术东西，只是一些生平和生活照片，无聊的看一下倒还行。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/pjp.jpg" width="120" height="150"></p>

<ul>
<li><strong>P.J. Plauger的博客</strong>：<a href="http://www.stepanovpapers.com/">Collected Papers of Alexander A. Stepanov</a></li>
</ul>


<p>P.J. Plauger，这个名字可能不是每个人都听说过，但在Windows平台开发的同学肯定都用过他写的代码，他就是MS VC STL库的实现者。本来他的博客，只是个人主页并且上面没什么内容，不过看到他的履历里面完成了13部科幻小说的编写，拿来勉励大家吧。</p>

<br/>


<br/>


<h2>C++高手的博客</h2>

<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/akrzemi1.jpeg" width="120" height="150"></p>

<ul>
<li><strong>Andrzej Krzemieński的博客</strong>：<a href="http://akrzemi1.wordpress.com/">Andrzej&rsquo;s C++ blog Guidelines and thoughts about C++</a></li>
</ul>


<p>Andrzej Krzemieński，从名字看是波兰人，近期博客更新较快，表达清晰，行文流畅，内容难度不高，有C++11内容，是像我这样的初级并且语言控的C++程序员的福音。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/SumantTambe.jpg" width="120" height="150"></p>

<ul>
<li><strong>Sumant Tambe的博客</strong>： <a href="http://cpptruths.blogspot.com/">c++ truths</a></li>
</ul>


<p>Sumant Tambe，印度人，美国范德堡大学的计算机博士，技术涉猎广泛，同时也是著名的<a href="http://en.wikibooks.org/wiki/More_C++_Idioms">More C++ Idioms</a>创建者。博客一直更新，内容面向中高级C++程序员，最新文章涉及C++11的“高级Idioms”，比如13年10月的一篇文章主题是：创建递归的lambda表达式。</p>

<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/JeffPreshing.jpg" width="120" height="150"></p>

<ul>
<li><strong>Jeff Preshing的博客</strong>: <a href="http://preshing.com/">Preshing on Programming</a></li>
</ul>


<p>Jeff Preshing，加拿大人，自称游戏行业开发10数年，C++功力自是深厚。博客每年更新十数篇，C++相关文章内容上进，直面工程上的难题：并发，而不是在C++本身上打转转。且行为流畅，图文并茂，深入浅出，是C++工程控的福音。</p>

<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/Joaqu.jpg" width="120" height="150"></p>

<ul>
<li><strong>Joaquín M López Muñoz的博客</strong>: <a href="http://bannalia.blogspot.com/">Bannalia: trivial notes on themes diverse</a></li>
</ul>


<p>Joaquín M López Muñoz，西班牙人。Boost.MultiIndex的实现者。博客长期更新，内容偏向算法，文章中有大量的公式推演和曲线图表，估计大部分中国开发者对这种内容是不感冒的。计算机或数学系的研究生，并以后打算从事算法相关工作的，推荐阅读。从这个西班牙男人身上，也可以看到老牌欧洲资本主义国家，教育水平的强悍，尤其是基础学科。</p>

<ul>
<li><strong>Daniel Park的博客</strong>: <a href="http://functionalcpp.wordpress.com/">functionalcpp-Abusing the type system like never before</a></li>
</ul>


<p>Daniel Park，喜欢用昵称whanhee，身世不知。一个注重实干的C++狂热分子，正如其博客简介所说，不想接着讲那些被讲烂掉的函数式编程概念，要用C++来实现这些概念。博客是一个关于函数式编程概念如何用C++实现的一个系列文章，作者采用的是C++11乃至C++14的特性，所以对C++高级函数式实现思想感兴趣的不容错过。近期博客更新也较快的。</p>

<ul>
<li><strong>Agustín Bergé的博客</strong>: <a href="http://talesofcpp.fusionfenix.com/">talesofcpp</a></li>
</ul>


<p>Agustín Bergé，86年生阿根廷人，可能是这里面最年轻的，stackoverflow目前排名708。作者想用自己的博客探索永无边界的C++世界，尤其是那些前人未涉足的犄角旮旯，所以C++中毒颇深者可以看看。</p>

<ul>
<li><strong>Chris Kohlhoff的博客</strong>: <a href="http://blog.think-async.com/">Preshing on Programming</a></li>
</ul>


<p>Chris Kohlhoff，澳大利亚人，Boost.asoi作者。博客更新到10年，内容主要涉及网络，asio相关，使用asio的可以去看看。</p>

<h2>中文C++名博</h2>

<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/liuweipeng.jpg" width="120" height="150"></p>

<ul>
<li><strong>刘未鹏的博客</strong>：<a href="http://mindhacks.cn/">MindHacks-思维改变生活</a></li>
</ul>


<p>刘未鹏，84年生人，现就职于微软，<a href='http://www.amazon.cn/gp/product/B008A4Y2R0/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008A4Y2R0&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Imperfect C++</a>, <a href='http://www.amazon.cn/gp/product/B00114BFTO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00114BFTO&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Exceptional C++ Style</a>译者，大学时对C++有极大的学习兴趣，曾与C++之父邮件往来，记录在另一个博客<a href="http://blog.csdn.net/pongba/">C++的卢浮宫</a>上。据闻刘未鹏现忙于育儿与心理学，所以博客更新较慢，但以往博客含金量高，很值得一读。博客内容偏重于学习方法，纯技术的C++文章少些。</p>

<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/chenhao.jpg" width="120" height="150"></p>

<ul>
<li><strong>陈皓的博客</strong>：<a href="http://coolshell.cn/">酷壳-享受编程和技术所带来的快乐</a></li>
</ul>


<p>陈皓，不认为自己是牛人的牛人，现就职于阿里巴巴。<a href="http://coolshell.cn/articles/4990.html">程序员技术练级攻略</a>这篇博文足以奠定其江湖地位。陈皓自称有技术焦虑症，所以博客更新频繁，内容大量涉及C++及一切劝人上进的观点和方法，也有不少网友的高质量投稿，涉及软件开发的方方面面。</p>

<br/>


<br/>


<p><img class="pull-right" src="http://towriting.com/images/posts/cpp-blogs/chenshuo.jpg" width="120" height="150"></p>

<ul>
<li><strong>陈硕的博客</strong>：<a href="http://blog.csdn.net/solstice/">陈硕的Blog</a></li>
</ul>


<p>陈硕，国内少有的C++工程功底深厚，作风严谨且乐于分享的人。Muduo开源库的作者，有干货著作<a href='http://www.amazon.cn/gp/product/B00AYS2KL0/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00AYS2KL0&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Linux多线程服务端编程:使用muduo C++网络库</a>一本，译注若干。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《黑天鹅—如何应对不可知的未来》读书笔记]]></title>
    <link href="http://towriting.com/blog/2013/12/11/read-notes-of-the-black-swan/"/>
    <updated>2013-12-11T23:57:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/11/read-notes-of-the-black-swan</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.cn/gp/product/B005U9CO3W/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005U9CO3W&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="" target="_blank">《黑天鹅—如何应对不可知的未来》</a>上册的阅读笔记：</p>

<ul>
<li>我们通过观察或经验获得的知识具有严重的局限性和脆弱性</li>
<li>为什么读报实际上降低了你对世界的认识呢</li>
<li>黑天鹅的逻辑是，你不知道的事比你知道的事更有意义，因为许多黑天鹅事件正是由于它们不被预期而发生和加剧的</li>
<li>看到一件事情发生正是因为人们认为它不应该发生，这是不是很奇怪？</li>
<li>尽管他们有经验和数据，但他们并不比普通大众更了解相关问题，只是更善于阐述而已，甚至只是更善于用复杂的数学模型把你弄晕而已</li>
<li>我们不学习规律，而是学习事实</li>
<li>正常的东西经常是不重要的</li>
<li>任何寻求证实的人都能够找到足够的证据来欺骗自己，以及他身边的人</li>
<li>即使我们取得了知识上的进步和成长，或者正因为这种进步和成长，未来仍会越来越不可预测</li>
<li>仅仅在装扮上公然反叛是一回事—社会科学家和经济学家称之为“廉价的标签”</li>
<li>历史是模糊的。你看到了结果，但看不到导致历史事件发生的幕后原因</li>
<li><strong>在预测上，非常聪明和掌握大量信息的人并不比出租车司机更有优势</strong></li>
<li>避免信息毒害的好处</li>
<li>每当我把时间不是花在研究，而是花在追求物质财富上时，它都让我感到羞愧</li>
<li>业余作家为自己写作，专业作家为他人写作</li>
<li>如果你是一名脑力劳动者，你不必工作太卖力，只需要多想。你的产出为 100和 1000 时，你做的工作是一样的</li>
<li><strong>收入具有突破性的职业只有在你成功的时候对你是好的</strong></li>
<li>而今天，少数人夺走几乎一切，剩下的人几乎什么也得不到。</li>
<li>设计一双鞋比真正把它们做出来赚钱得多</li>
<li>当你的样本量足够大时，任何个例都不会对整体产生重大影响</li>
<li>几乎所有社会问题都来自极端斯坦</li>
<li>只花 100 美元就让别人有快乐一天的感觉非常令人飘飘然</li>
<li>火鸡问题可以把“<strong>喂你的那只手也可能是拧断你脖子的那只手</strong>”的情况一般化</li>
<li>从火鸡的角度，第 1001 天没有喂食是黑天鹅事件，从屠宰者的角度却不是，因为这不是意料之外的</li>
<li>正面的黑天鹅事件需要时间来显现它们的影响，而负面的黑天鹅事件发生得非常迅速—毁灭比缔造要容易和迅速得多</li>
<li>现代世界是极端斯坦，被不经常发生及非常不经常发生的事件左右</li>
<li>我们习惯过度解释，偏好简洁的故事，而不是原始真相</li>
<li>叙述谬误指的是我们无法在不编造理由或者强加一种逻辑关系的情况下观察一系列事实。对事实的解释会与事实混在一起，使事实变得更容易被记住</li>
<li>文字或符号表述得越有条理，越不具随机性，越符合一定模式，这种表述就越容易在大脑中储存或者写在一本书里，好让你的后人在某一天读到。</li>
<li>压缩对意识的正常工作至关重要</li>
<li>信息越具有随机性，事物就越复杂，因而越难以概括</li>
<li>不要试图刻意不去想它—这几乎一定会带来反作用。更合适的解决办法是更多地看到事件不可避免的部分</li>
<li>人们提出一个原因，好让你接受一则新闻，同时让事情看上去更具体</li>
<li>有人负责核实事实，却没有人负责核实真理</li>
<li><strong>一个人的死亡是悲剧，100 万人的死亡只是统计学意义上的说法。</strong></li>
<li>因为我们的反应是不经过思考和反省的</li>
<li>我们对黑天鹅现象的误解大部分归因于我们对系统 1（叙述）以及情感（包括情绪）的运用</li>
<li><strong>没有新发现是非常有价值的，因为它是发现过程的一部分</strong></li>
<li>许多人在生活中忙忙碌碌，相信自己在做正确的事，但很长时间都无法拿出实实在在的成绩。他们需要一种不时获得满足感的能力，才能在不断受到周围人的残酷打击的情况下不失去勇气。</li>
<li>这些职业能够产生一种持续的自我满足感</li>
<li>风险投资人比创业家赚钱，出版商比作者赚钱，艺术经纪人比艺术家赚钱，科学比科学家成功（大约 50%的科学和学术论文或许花费了科学家几个月甚至几年的努力，却从来没有被人真正读过）。<strong>参与赌博的人获得了另一种非物质报酬：希望</strong>.</li>
<li><strong>假如你赚了 1000 万美元，然后损失了 900 万美元，这情形比根本没有赚钱还糟！</strong></li>
<li>学派使一个有着非凡思想而从中获益的希望很渺茫的人能够找到同伴</li>
<li>沉默的证据</li>
<li>自传的全部意义就在于武断地把某些品质与事件连成因果关系</li>
<li>这些行业产出了大量失败者：挨饿的演员比挨饿的会计师多，即使你假设他们的平均收入是一样的</li>
<li>没有必要为所有濒危物种感到道义上负有责任</li>
<li>这是一种沉默的犯罪</li>
<li>回想一下证实偏差：政府非常擅长告诉你他们做了什么，而不是他们没做什么</li>
<li>救活一个人只是统计数字，伤害一个人则是奇闻逸事</li>
<li>我们冒险通常不是出于自信，而是出于无知和对不确定性的无视</li>
<li>我的存在是低概率事件的重大结果，而我经常忘记这一点。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++中的静态断言]]></title>
    <link href="http://towriting.com/blog/2013/12/10/static-assert/"/>
    <updated>2013-12-10T00:02:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/10/static-assert</id>
    <content type="html"><![CDATA[<h2>什么是静态断言</h2>

<p>断言（Assert)是报告代码状态错误的技术手段。Windows下的C++开发肯定都知道ASSERT或ATLASSERT，这两个宏生成DEBUG版本下的断言，另外还有assert，是C/C++提供的断言函数，效果和以上两个宏是一样的。</p>

<p>那什么是静态断言？上面介绍的普通断言是运行时检测的，静态断言是编译期检测的，所以被称之为静态断言（static assert）。最早知道编译期检测是在Matthew wilson的<a href="http://www.amazon.cn/gp/product/B008A4Y2R0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008A4Y2R0&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="" target="_blank">《Imperfect C++》</a>中，里面称其为约束（constraints)，并抱怨C++为什么不支持如此常用的功能（C++11已有改善）。</p>

<p>那使用静态断言有什么好处呢？</p>

<h2>静态断言的好处</h2>

<ol>
<li>更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</li>
<li>无法忽略的错误，对于Assert类似DEBUG下的断言，有时候被不会被执行到，即使执行到也会遭到一些开发的忽视，而静态断言的错误是无法忽视的，因为构建失败了。</li>
<li>减少运行时开销，静态断言是编译期检测的，减少了运行时开销</li>
</ol>


<p>那如何使用实现静态断言？</p>

<h2>使用静态断言</h2>

<p>静态断言作用的对象一般是编译时已知的状态。任何可以成为模板类参数的内容都可以作为静态断言的对象。</p>

<p>下面看一个静态断言的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">D</span><span class="p">,</span><span class="k">typename</span> <span class="n">B</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">has_base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>     <span class="o">~</span><span class="n">has_base</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)(</span><span class="n">D</span><span class="o">*</span><span class="p">,</span><span class="n">B</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">constraints</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">void</span> <span class="n">constraints</span><span class="p">(</span><span class="n">D</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span><span class="n">B</span> <span class="o">*</span><span class="n">pb</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="n">pb</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子最早出自Bjarne Stroustrup之手，用于检测一个类型是否是另一个类型的父类（类型相等和void*的情况没有考虑，用起来像这样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CBase</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">CDer</span><span class="o">:</span> <span class="k">public</span> <span class="n">CBase</span> <span class="p">{};</span>
</span><span class='line'><span class="n">has_base</span><span class="o">&lt;</span><span class="n">CDer</span><span class="p">,</span> <span class="n">CBase</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'><span class="n">has_base</span><span class="o">&lt;</span><span class="n">CBase</span><span class="p">,</span> <span class="n">CDer</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//编译错误</span>
</span></code></pre></td></tr></table></div></figure>


<p>它的工作原理是，成员函数constraints试图把D的指针转化成B的指针，这一般只在B是D的派生类时成立。而且constraints函数永远不会被调到，所以没有运行时开销。</p>

<p>在看一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">enum</span> <span class="n">personType</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">person_child</span><span class="p">,</span>
</span><span class='line'>    <span class="n">person_adult</span><span class="p">,</span>
</span><span class='line'>    <span class="n">person_woman</span><span class="p">,</span>
</span><span class='line'>    <span class="n">person_man</span><span class="p">,</span>
</span><span class='line'>    <span class="n">person_count</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">ProcessPersonType</span><span class="p">(</span><span class="n">personType</span> <span class="n">ptVal</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">dummy</span><span class="p">[</span><span class="n">person_count</span> <span class="o">&gt;</span> <span class="n">CHAR_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">cVal</span> <span class="o">=</span> <span class="n">ptVal</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// do something with cVal</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面例子里，试图将枚举类型的值转化成cVal,但可能有溢出的问题，所以设置一个静态断言：<code>char dummy[person_count &gt; UCHAR_MAX ? 1 : -1];</code>，原理是如果personType的最大值大于char类型的最大值，则表达式为<code>char dummy[-1]</code>，我们知道这是编译不过的，所以会提示我们出问题了。</p>

<p>以上方式虽然可以实现静态断言的效果，但提示的信息，可能和我们断言想要报告的完全无关，所以并不是最完美的解决方案。</p>

<h2>C++11中的静态断言</h2>

<p>C++11中增加了static_assert支持静态断言，用法相当简单，static_asset接受两个参数，第一个为要断言的内容，第二个为显示的错误提示。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Factorial</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="n">static_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;n must bigger than 1&quot;</span><span class="p">);</span>
</span><span class='line'> <span class="k">enum</span><span class="p">{</span> <span class="n">value</span><span class="o">=</span><span class="n">n</span> <span class="o">*</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="k">enum</span><span class="p">{</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面是计算阶乘的一个模板，我们使用static_assert检测n的值大于1，如果不满足则，编译错误，提示为：&#8221;n must bigger than 1&#8221;。</p>

<p>static_assert是编译器很容易实现的一个特性，一般的编译器最新版本应该都已支持。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从杭州雾霾谈起]]></title>
    <link href="http://towriting.com/blog/2013/12/08/from-smog/"/>
    <updated>2013-12-08T14:07:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/08/from-smog</id>
    <content type="html"><![CDATA[<p>昨天，在简书上翻看了几篇文章，其中首页竟有两篇是谈论要每天写点东西的。其中有一个想法很好，是教人如何养成写东西的习惯的：每天抽出一刻钟以上的时间写点什么并坚持半个月，从此你可能就会有写东西的习惯。</p>

<p>道理很简单，知易行难，但自己还是想试一试，因为自己最初创建这个博客时，给自己定下了每周一篇文章的目标，到目前虽没有严格达标，但产出还是不少的，半年来也有30篇。这样一看，较往年比今年自己确实留下了一些东西，也有了一点成就感。</p>

<p>但这30篇文章中，技术相关的主要来自翻译，深感自己很难写出高质量、低雷同的原创技术文章，而如今要践行每日一篇的诺言，只能先从非技术写起了，从哪里开始呢？讲一讲近期热议的雾霾吧，终于扯上题目了。</p>

<p>前天做了一个梦，梦中自己游历到台湾，游玩之余不忘社会责任感，遂至一献血站献血，粗大的针头插入自己的臂膀，自己咬紧牙关挺下来，血抽完了。然而噩耗传来，护士失望的告诉我：“您的血液不合格”。我问她怎么回事，她没回答，而是劝我赶紧去医院进行专业检查。</p>

<p>梦至此，我恍然大悟，一定是极恶的病，所以我痛哭流涕，感觉自己人生完了，哭极梦醒，但胳膊还隐隐作痛，醒来回想，长舒一口气。</p>

<p>天明上班，与同事言及此事，感梦中潜意识中的生病来自上下班途中遭遇的雾霾。从12月起，每日晚归回家途中，路上皆蒙蒙的雾霾。前年还笑留在北京的同学，生活环境困厄，想不到自己生活的杭州竟亦至此。杭州从此和，“江南好，最忆是杭州&#8221;这种词句渐行渐远了。</p>

<p>想梦中自己的遭遇，很可能会是雾霾这种东西给我们这些生活在大城市的人下的慢性随机毒药，说不准若干年后谁会中招。尘肺此类职业病，患者还有责任人可寻，而一旦遭遇雾霾的荼毒而遭病，谁来买单？</p>

<p>小时候，印象中，北方的春天，沙尘暴总会来几次，每次都是几天的时间。那时黄沙遮天，阴风呜号，灶台碗里都沾满了沙土。但人们照常上班，上学，人们感觉到的最多的只是不便。确实这种沙尘暴相对还是“自然的”，沙尘中纯粹是沙尘，最多夹杂这一些颗粒垃圾，没有太多化学的物质。</p>

<p>家乡的沙尘暴这几年少了，不过环境并没有好转，村与村之间有好多建材工厂，路上也全是粉尘，空气中也有浓度很高的粉尘悬浮物，路两边本来绿色的庄稼叶子上也全是白色的粉尘，村里院子里都没法子晾衣服，会越晾越脏的。当时也是为了逃避这种环境，所以来到南方工作。想不到现在，杭州也这样了&hellip;</p>

<h2>雾霾的好处</h2>

<p>一切事务皆有两面性，从某种角度讲，雾霾的突然显现有其好处。因为雾霾可能是工业污染和汽车尾气排放长期的一个结果。城市中，空气质量一直很差，对人体的危害上可能每天都差不多一样，看不到雾霾也不能说明空气好，看到雾霾也不能说明空气更坏了。只不过雾霾的出现，将这种危害明面化了，使我们和各级部门不得不重视。换句话说，如果没有雾霾，可能不会有人重视与治理，但空气可能一样的差，不过公众的肉眼看不出而已。</p>

<p>雾霾的好处，就像前一段时间郭美美事件一样，从某种角度看，是好事！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[整洁代码之上]]></title>
    <link href="http://towriting.com/blog/2013/12/03/beyond-clean-code/"/>
    <updated>2013-12-03T23:09:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/03/beyond-clean-code</id>
    <content type="html"><![CDATA[<h2>什么是整洁代码（What Is Clean Code）</h2>

<p>当你拿这个问题问不同的人，或采用不同的语气，你可能会得到不同的答案。但通常无外乎这些评判标准：</p>

<ul>
<li>自解释的命名</li>
<li>一致的代码风格</li>
<li>合适的抽象</li>
<li>可读性良好</li>
<li>清晰的代码流程</li>
<li>良好的架构</li>
<li>复杂任务使用库实现</li>
<li>使用工业级的解决方案</li>
<li>没有安全漏洞</li>
<li>函数短小</li>
<li>函数复杂度小</li>
</ul>


<p>不一而足，当然你也有自己评判整洁代码的标尺&hellip;</p>

<h2>如何写出整洁的代码(How To Write Clean Code)</h2>

<p>这是经久不衰的热议话题。我认为下面这幅画可以精辟地诠释如何写出整洁的代码：</p>

<p><img src="http://towriting.com/images/posts/beyond-clean-code/towriting.png" title="" ></p>

<p>当然这有一点无厘头，但这是真的。大部分程序员没有写出整洁代码的时间。就此我们无可奈何！</p>

<h2>切换视角（Change The Premise)</h2>

<p>我打算在这说点可能稍具争议、离经叛道的想法：</p>

<blockquote><p>这里只有两种代码。一种具有商业价值，另一种没有！</p></blockquote>

<p>在工业界，我们看中的是“漂亮”的代码，我们看好的是可读性好、行为正确的代码。但因为某些原因，我们从来没有谈论过代码必须要有商用价值。再整洁的代码没有商业价值也是“贱货”。</p>

<p>所以，我们把“具有商业价值”整合进整洁代码的评判标尺，我们得到四种代码：</p>

<table border="1">
<tr><th></th><th>良好的商业价值</th><th>贫乏的商业价值</th></tr>
<tr><th>整洁代码</th><td>出色的代码</td><td>坏代码</td></tr>
<tr><th>丑陋代码</th><td>良好的代码</td><td>垃圾代码</td></tr>
</table>


<p>很明显使代码具有商业价值比使其“整洁”更划算。专注于“整洁”最多可以得到“坏代码”，而专注于&#8221;商业价值&#8221;，则最差得到“良好的代码”..</p>

<p>所以，怎样才能专注于商业价值呢？</p>

<h2>DIRTI方法（The DIRTI Method)</h2>

<p>我靠写DIRTI<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的代码来使代码专注于商业价值:</p>

<ol>
<li><strong>Develop</strong> &ndash; 为解决某个（商业）问题而快速开发（Develop)出哪怕很烂的代码。不要担心代码格式、抽象及其他任何问题。就是要完成它。</li>
<li><strong>Isolate</strong> &ndash; 分离（Isolate)上一步实现的功能，整理出抽象模块。这些将成为重构的点。</li>
<li><strong>Refactor</strong> &ndash; 重构(Refactor)这些模块，开始整理代码。</li>
<li><strong>Test</strong> &ndash; 当这些模块整理合理后，开始写测试(Test)用例（单元测试）。</li>
<li><strong>Integrate</strong> &ndash; 一旦这些模块通过测试就可以把它们集成(Integrate)进你的程序（要有集成测试）。</li>
</ol>


<p>妙的是，这一系列步骤假定你开始的时候并不知你的代码抽象的样子。但你一旦你开始写代码，它会逐渐帮助你明白你要解决的问题（方案）。</p>

<p>与TDD（测试驱动开发）截然不同的是，TDD期望你在你开始动手写代码前明白你要写的代码。</p>

<p>这确实会把我们带到一个美妙的境地。使用DIRTI方法会有两个主要的阶段：不停的DIR和不停的RTI。</p>

<p>当你最终明白方案之前，你将一遍遍的开发，分离，重构。而一旦顿悟以后，你将花费更多的时间到下一阶段（重构，测试，集成）。</p>

<h2>为什么这有效（Why This Works)</h2>

<p>为什么我坐在这里给你讲DIRTI方法？因为它行之有效。DIRTI方法确实会帮助你知道你要写的代码。它会帮助你指出要解决的问题。</p>

<p>更重要的是，它为你能做出英明决断提供力量和武器。你一定记得，具有商业价值的代码是好的代码。所以当你离开开发阶段，你的代码已经具有了商业价值，因为它已经可以解决最初要解决的问题。</p>

<p>整个进程是迭代的。你可以不停的分离、重构、分离、重构，直到你对代码满意。但这个过程中，你是在可以工作的代码上进行的。这非常酷！这样允许你责问自己，”是否代码已经足够好了“。一旦你对代码满意了，就进入下一阶段。</p>

<p>这会让你关注于最重要的东西：商业价值，而代码质量上的关注度是可以动态选择的。</p>

<h2>不是方案，仅仅是工具（Not A Solution, A Tool)</h2>

<p>必须要澄清的是：不是要你替换掉TDD、结对编程或其它你已经采用了的方法。DIRTI只会是你工具箱里的又一件工具。针对不同的问题要采用不同的工具：</p>

<p>如果你明白你要写的东西，那就用TDD。如果你仅仅知道问题，而不知解决方案（最佳），那就用DIRTI吧。</p>

<p>===================================================================================</p>

<p>翻译自：<a href="http://blog.ircmaxell.com/2013/11/beyond-clean-code.html">Beyond Clean Code</a></p>

<p>图片来自：<a href="http://www.aqee.net/how-to-write-good-code/">如何写出好代码</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>发音同Dirty<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Tools - 多粘贴板 && 快速搜索]]></title>
    <link href="http://towriting.com/blog/2013/11/17/effective-tools/"/>
    <updated>2013-11-17T13:21:00+08:00</updated>
    <id>http://towriting.com/blog/2013/11/17/effective-tools</id>
    <content type="html"><![CDATA[<p>前两天买了一本<a href="http://www.amazon.cn/gp/product/B001XCWFOI/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B001XCWFOI&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="">《卓有成效的程序员》</a>，看过几章后才明白为什么Stackoverflow里面人们会推荐这本书：它大抵是讲工具的，目的是为了提高程序员的生产率，但工具往往是人们漠视的。</p>

<p>工具的熟练使用，是人之所以成为人的一个重要条件。程序员也一样，虽然我们的可替代性很强，但一个“有成效的”程序员和一个普通的程序员的工作效率天壤之别。</p>

<p>工具是懒惰的程序员面对枯燥的劳动时下意识去寻找的东西。有些工具鲜有人知，但用过的人爱不释手。分享一下另自己爱不释手、每天都用的两款工具：</p>

<h3>多粘贴板 Clipx</h3>

<p>这是一款我每天都会使用，但认识的人里面没人听说过的软件，软件是免费使用的，下载地址在这里：<a href="http://bluemars.org/clipx/">Clipx</a>。</p>

<p>此软件的定位是代替Windows系统粘帖版功能，我们知道Windows系统的粘帖板只能保存最后一个拷贝或剪切的内容，但这对于我们程序员来说是远远不够的，我们每天有大量的Ctrl+C\Ctrl+V操作，这款软件就是为程序员而生的，Clipx可以保存多个历史剪切\复制的内容（格式不限：文本、文件、图片等），并可以快速的选择粘贴：</p>

<p><img src="http://towriting.com/images/posts/effective-tools/clipx.jpg" title="" ></p>

<p><strong>Linux下也有类似软件，不过感觉不太好用：Glipper。</strong></p>

<h3>快速查找 光速搜索</h3>

<p>光速搜索是盛大出的一款免费软件，是以前一位同时推荐自己使用的，软件的优点是极速查找文件，并且有任务栏插件，方便实用。使用光速搜索，从此不用在忍受系统龟速的文件查找，唯一的一点不足就是此软件貌似不再更新，自己在Win7 64位下使用偶现Bug.</p>

<p>国外有一些类似的软件，比如大名鼎鼎的：Everything，但用来皆不如光速搜索体验好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跳槽的好处]]></title>
    <link href="http://towriting.com/blog/2013/11/10/job-hopping/"/>
    <updated>2013-11-10T21:39:00+08:00</updated>
    <id>http://towriting.com/blog/2013/11/10/job-hopping</id>
    <content type="html"><![CDATA[<p>前两天和一个一年半多没联系过的前同事通了个电话，聊了个把小时。我对他现在的工作状态很感兴趣，因为他的工作状态就是我不离开那家公司的可能的状态。</p>

<p>通过他的描述，我感觉他的状态可能与一年半前差别不大。我离开时，推荐他们使用的SVN，到现在还是没有用起来，没有版本控制就没有协作。他讲到他遇到问题会通过Baidu+CSDN找答案，我问他怎么不用Google+Stackoverflow，Stackoverflow我离开前也是向他推荐过的。他知道学，也不排斥技术，现在主要的开发工具是VC6和Delphi6，用C++但没听说过C++11。知道开源，去过SourceForge，但没听说过Github。听说但没有使用过设计模式。</p>

<p>通话最后，本着交流与分享，我向他推荐了以下内容：</p>

<ul>
<li>网站：Github、Stackoverflow、Reddit\r\cpp、HackerNews</li>
<li>书籍：代码大全、程序员修炼之道、The C++ Programming Language、深度探索对象模型、禅与摩托车维修艺术</li>
</ul>


<p>我与他工作年限相仿，技术起点一致，唯一不同的是，我离开了那家公司，所以<strong>有机会学到或接触更多的技术知识，这可能就是跳槽的好处</strong>。</p>

<p>简单梳理一下两次跳槽期间的收获，第一次：
<img class="pull-right" src="http://towriting.com/images/posts/job-hopping/brid.jpg" title="'良禽择木而栖'" ></p>

<ul>
<li>正规的软件开发流程</li>
<li>Bug跟踪系统</li>
<li>静态源码检测系统</li>
<li>自动编译系统</li>
<li>开始正式使用设计模式</li>
<li>GitHub</li>
<li>第一次翻译技术文章</li>
<li>十数本计算机书籍</li>
<li>WBS任务分解</li>
<li>金融知识</li>
<li>Python自动测试</li>
<li>心理学</li>
</ul>


<p>第二次（到现在2013.11)：</p>

<ul>
<li>TFS</li>
<li>项目中大规模使用C++11</li>
<li>Windbg</li>
<li>GDI+</li>
<li>UAC</li>
<li>HackerNews</li>
<li>Reddit</li>
<li>罗辑思维（罗胖）</li>
<li>IPC</li>
<li>Octopress建立博客</li>
<li>wordPress建站</li>
<li>amazon云主机</li>
<li>openshift</li>
<li>手机驱动知识</li>
</ul>


<p>上面纯技术相关的点大部分和跳槽直接相关，因为新公司新气象。其他点或多或少也和跳槽沾边，槽变人变，不同的人可能会给你不同的启发，比如《罗辑思维》这个节目就是一个同事力荐的。</p>

<p>讲到了我自己经历的跳槽的收获，那是不是跳槽一定是利好的？答案是否定的。我曾遇到过一个35岁左右，编程数年的人，有几年中，平均两个月换一份工作，聊天中发现其竟不知很基础的编程知识，使用C++但从没断点调试过。</p>

<p>所以，我以为<strong>好奇心和追求良质<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>是提高技术广度和深度的内部原因、好的项目与工作伙伴是外部原因，而跳槽不过增加了外部原因的刺激而已</strong>。</p>

<p>注：以上是技术提高的角度看跳槽之我见。站在职业发展的角度，最好不要频繁跳槽，站在职业道德与产品责任的角度，更不要轻易跳槽。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>良质，《禅与摩托车维修艺术》中的说法，从现有哲学体系看，良质是唯心的。良质存乎心中，指个人感受到某样东西的好，但无法量化衡量。比如，对比两段相同功能的代码，你可能就觉得其中一段“好”，而说不出原因，这种&#8221;好&#8221;就是良质。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[驳‘做产品必须站在用户的角度考虑’]]></title>
    <link href="http://towriting.com/blog/2013/11/06/from-the-user-perspective/"/>
    <updated>2013-11-06T00:00:00+08:00</updated>
    <id>http://towriting.com/blog/2013/11/06/from-the-user-perspective</id>
    <content type="html"><![CDATA[<blockquote><p>“要站在用户的角度考虑”是互联网软件的从业者几乎听的耳朵磨出茧子的一句话。站在用户的角度考虑才能做出好的产品，似乎是整个行业的共识，但对于这句话我大抵是不赞成的。</p></blockquote>

<h2>只为用户体验</h2>

<p>”站在用户的角度考虑“，首要的目的大概是为了用户体验，但极致的用户体验是否是成就“好产品”的必要条件？</p>

<p>何为好产品？按体验划分的好产品，在我看来大概有两种：</p>

<p>第一种重实用，轻体验。这种产品拥有用户<strong>不可或缺的功能</strong>，并且这个功能有可能“只此一家，别无分店”。这时，这款产品，就有资格“叫嚣”：想用我，就按我的规则来。西方的一些传统软件，功能强大或独特，但界面交互工程感很强，普通人上手困难，<strong>用户可能不多</strong>，但一旦上手，爱不释手。这方面的代表：传统的Linux。</p>

<p>第二种重体验，包装功能。以体验制胜，傻瓜式是其特色，人人可上手，可省心的满足用户基本要求，<strong>拥有大量用户</strong>，这种好产品有“讨好”之嫌。这方面的代表：360安全卫士。</p>

<p>一个产品，成为好产品，和体验并无必然联系，功能是关键，<strong>体验只是锦上添花</strong>。要知道，360安全卫士，不仅体验好，各种功能也是人们亟需的。微信很成功，张小龙也曾在不同场合说过，微信的火是满足了用户的刚需。你会更在意Google的页面还是搜索内容呢？</p>

<p>这是无法弯曲的事实：用户肯定是因为某个功能才使用某款产品的。所以对于用户个体来说，功能是决定产品好坏的最重要标准。</p>

<p><strong>过分强调用户体验，只说明功能平庸！</strong></p>

<h2>锦上添花不容易</h2>

<p>姑且不谈，从逻辑上讲，站在用户的角度考虑，<strong>必然站在创新的反面</strong>，因为创新之物，用户何来想法。</p>

<p>就是想靠“用户的角度”把产品的体验提高一点，也并不容易，因为&#8221;人心难测&#8221;。</p>

<p><strong>1. 你不了解用户</strong>
你无法知道谁会使用你的产品。有限方式的用户调研不保证代表用户答案，这方面的例子是：美国《文摘周刊》1936年进行的总统竞选民意调查的失误。</p>

<p><strong>2. 用户不了解自己</strong>
人有太多的人知缺陷，使其很难告诉你他自己真正的答案，因为他自己也不知道。这方面经典的认知缺陷是选择性认知、问题框架影响答案。</p>

<p>所以，费劲心机得来的“用户角度”也可能有偏差，更何况产品经理脱口而出的”站在用户的角度考虑“呢？</p>

<h2>产品经理的大旗</h2>

<p>常见，若干人围着一个产品经理，讨论一个产品的设计，大家你一言，我一语提出自己对产品的设计看法，最终皆被该产品经理驳回：站在用户的角度考虑, balabala。</p>

<p>难道说这句话时，该产品经理没有意识到刚才与你讨论的这些人不也是用户吗？</p>

<p>产品经理祭出“用户角度”的大旗，大凡三种情况：</p>

<ol>
<li>真正设身处地或调研出的”用户角度“，至少他内心认为是这样。</li>
<li>为了一己私利，压制别人。像文革中的红卫兵，指责别人是走资派。</li>
<li>为了凸显自己的水平与专业性，信口胡诌。</li>
</ol>


<p>相信后两种还是少数，但也客观存在这种面目可憎的家伙。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Safe bool惯用法到explicit标识符]]></title>
    <link href="http://towriting.com/blog/2013/11/01/safe-bool-idiom/"/>
    <updated>2013-11-01T22:52:00+08:00</updated>
    <id>http://towriting.com/blog/2013/11/01/safe-bool-idiom</id>
    <content type="html"><![CDATA[<blockquote><p>C++是一个学语法都能让人入迷的奇葩语言，有各种的奇技淫巧。比如这里的许多的惯用法：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms">More C++ Idioms</a>，虽凝聚了C++程序员的聪明才智，但都是特定时期的产物，
相信都会被冲到C++语言演化长河的河滩上，仅供后人瞻仰（或者是C++本身）。让我们从Safe bool idiom说起。</p></blockquote>

<h2>Safe bool idiom</h2>

<p>什么是safe bool idiom？就是为自定义类型（class）提供检测真假的能力，而又不会带来副作用。</p>

<h3>为类(Class)提供检测真假的能力</h3>

<p>方法有二，第一种简单直白，提供一个返回bool类型的函数，比如下面的isValid成员函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CData</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">IsValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CData</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>   <span class="c1">//dosomething</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是直观而不易出错的。但多多少少有些强迫症的人会说，如果能像检测内置bool类型一样检测data对象不是更好的保证了代码的语法一致性？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CData</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>   <span class="c1">//dosomething</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时他又急于向人们展示，&#8221;我会使用操作符重载哦“。于是第二种方法出来了，重载bool类型转化操作符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CData</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CData</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>   <span class="c1">//dosomething</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>漂亮的外表后面的东西可能是有毒的，比如毒蘑菇、巫婆的毒苹果和传说中的红颜祸水们。软件开发也概莫能外，这个漂亮的解决方案后面有问题。</p>

<h3>bool操作符的副作用</h3>

<p>假使有一个简单的指针外敷类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">CPtr</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">T</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>   <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CPtr</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">CPtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>   <span class="n">p2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>   <span class="c1">//天知道会怎样</span>
</span><span class='line'>   <span class="c1">//something </span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有人不小心拿两个不同类型的类对象来比较，不幸的是编译器并没有报错，因为17行隐式调用了operator==(bool,bool)，后面的结果真真天知道。
这可如何是好？C++社区里最不缺人才，很快有人想出解决方案：</p>

<h3>Safe bool实现</h3>

<p>Safe Bool正式的提出是这里：<a href="http://www.artima.com/cppsource/safebool.html">The Safe Bool Idiom</a>，方法就是写一个类型转化操作符，这个操作符返回一个可以进行 <strong>if</strong> 判断的特有类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Testable</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">ok_</span><span class="p">;</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">Testable</span><span class="o">::*</span><span class="n">bool_type</span><span class="p">)()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">this_type_does_not_support_comparisons</span><span class="p">()</span> <span class="k">const</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">explicit</span> <span class="n">Testable</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="o">:</span><span class="n">ok_</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">operator</span> <span class="n">bool_type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">ok_</span><span class="o">==</span><span class="kc">true</span> <span class="o">?</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">Testable</span><span class="o">::</span><span class="n">this_type_does_not_support_comparisons</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TestableOther</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">ok_</span><span class="p">;</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">TestableOther</span><span class="o">::*</span><span class="n">bool_type</span><span class="p">)()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">this_type_does_not_support_comparisons</span><span class="p">()</span> <span class="k">const</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">explicit</span> <span class="n">TestableOther</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="o">:</span><span class="n">ok_</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">operator</span> <span class="n">bool_type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">ok_</span><span class="o">==</span><span class="kc">true</span> <span class="o">?</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">Testable</span><span class="o">::</span><span class="n">this_type_does_not_support_comparisons</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">Testable</span> <span class="n">testable</span><span class="p">;</span>
</span><span class='line'>  <span class="n">TestableOther</span> <span class="n">testableother</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">testable</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">//something</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">testable</span> <span class="o">==</span> <span class="n">testableother</span><span class="p">)</span> <span class="c1">//编译错误</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码，利用的是bool_type是函数指针类型，所以可以进行 <strong>if</strong> 判断，且不同类的bool_type是不同的，直接比较会编译错误。
这就是safe bool Idiom，详细的代码可以参看这里：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/">More C++ Idioms/Safe bool</a>。
但我认为这个方案是顾此失彼，会引发新的问题，比如类中重载operator int操作符怎么办？</p>

<h2>C++11的做法</h2>

<p>C++11的基因支持safe bool，方法就是使用<a href="http://en.cppreference.com/w/cpp/language/explicit">explicit</a>修饰operator：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Testable</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">Testable</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>      <span class="p">{</span> <span class="cm">/*do something*/</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*do something*/</span> <span class="p">}</span>  <span class="c1">// 编译错误</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>explicit</strong> 在C++11以前是只能用于修饰构造函数，但在C++11中可以用来修饰操作符，上面代码中的operator bool（）加上<strong>explicit</strong>表式其无法隐式转化为bool。
这个解决方案，干净漂亮，无副作用。</p>

<h2>总结</h2>

<p>C++11前后的两种Safe Bool的解决方案比较，优劣立现。站在实用的角度上，C++11出现后，C++中好多“高端技术”已经不需要学习，比如StackOver上列出的这些：<a href="http://stackoverflow.com/questions/9299101/what-c-idioms-are-deprecated-in-c11">what C++ idioms are deprecated in C++11</a>。这些东西就像毛笔字一样，可以仅供专家与爱好者把玩了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openshift小技巧-热部署]]></title>
    <link href="http://towriting.com/blog/2013/10/21/openshift-tips/"/>
    <updated>2013-10-21T22:24:00+08:00</updated>
    <id>http://towriting.com/blog/2013/10/21/openshift-tips</id>
    <content type="html"><![CDATA[<p>最近试着用Openshift搭建了一个Octopress程序，搭建成功后，发现每次部署时，都会引起站点临时无法访问，这是自己使用Github的pages时没遇到的事情，用Google快速搜索下，原来要用热部署（hot deploy)实现不重启openshift程序部署文件，官方是支持的，方法很简单：</p>

<ol>
<li>切换到你的Openshift程序根目录</li>
<li>创建文件hot_deploy到指定目录：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>touch .openshift/markers/hot_deploy
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[神级程序员的神话]]></title>
    <link href="http://towriting.com/blog/2013/09/30/the-myth-of-the-rockstar-programmer/"/>
    <updated>2013-09-30T12:20:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/30/the-myth-of-the-rockstar-programmer</id>
    <content type="html"><![CDATA[<p>神级程序员<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的神话不过就是个，神话！它是由一些可悲的原因形成的神话：</p>

<ul>
<li>给普通人设置难以实现的预期</li>
<li>宣扬虚无的神级程序员打压团队</li>
<li>告诉某人是神级的并使其相信这一说法</li>
</ul>


<p>现实总是正态分布的。大量的程序员是普通水平的，一些大牛已属异类，神级程序员只是传说中有（其实一些也很烂）。</p>

<blockquote><p>落后的项目增加人手,只会导致进度更加落后</p><footer><strong>Brooks&#8217;s law</strong> <cite><a href='http://en.wikipedia.org/wiki/Brooks%27s_law'>维基百科</a></cite></footer></blockquote>


<h2>神级程序员只是个神话</h2>

<p>人们总是津津乐道神级程序员可以做10个普通开发者的工作。天方夜谭！10个孕妇不会只用一个月生出小孩，10个“神级”程序员也无法代替100个普通程序员。</p>

<ul>
<li>助理工程师 &ndash; 简单的问题复杂的解决方案</li>
<li>工程师 &ndash; 简单的问题简单的解决方案</li>
<li>高级工程师 &ndash; 复杂的问题简单的解决方案</li>
<li>神级工程师 &ndash; 消灭复杂的问题于无形</li>
</ul>


<p>我算是神级的吗？我自信自己是一个高级程序员，也小有名气。过去的20年我参加了很多成功的项目，但我从不是坊间最聪明的人。</p>

<blockquote><p>高级 + 耀眼 != 神级</p></blockquote>

<p>按我的理解：</p>

<blockquote><p>高级 + 思想 == 神级</p></blockquote>

<p>这和有没有名气并没有任何关系。不能因为某某人写博客、书或者善于演讲就说他是个好开发。</p>

<p>神级程序员关心代码行数吗？不，好的开发关注的是解决问题。他们解决问题而不是抱怨问题。</p>

<h2>神级的团队是现实存在的</h2>

<p>事实上，团队想法和经验的某些特质成就了神级团队，这肯定是你关心的。深思与实效的组织架构加上激情积极好学的开发者必能有所成就。假如你坚持叫某些人“大神”，他可能是团队的老师或指导者。</p>

<p>John Galloway曾说过：</p>

<blockquote><p>“三思而后行”+“代码追求良质”是成就好团队的良方</p></blockquote>

<p>建造一只聪明个性的团队。创建<strong>神级团队</strong>。</p>

<p><strong>翻译自</strong>：<a href="http://www.hanselman.com/blog/TheMythOfTheRockstarProgrammer.aspx">The Myth of the Rockstar Programmer</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>神级程序员(Rockstar Programmer)是指技术能力很强、经验丰富还必须要有以一敌十的工作效能的程序员。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++手爱德华]]></title>
    <link href="http://towriting.com/blog/2013/09/23/edward-chands/"/>
    <updated>2013-09-23T22:25:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/23/edward-chands</id>
    <content type="html"><![CDATA[<p><img class="pull-right" src="http://towriting.com/images/posts/edward-chands/Edwardscissorhandsposter.png" title="" ></p>

<blockquote><p>我一直在寻找一种可以类比使用C++编程时心情的东西，直到我想起1900年Tim Burton的电影，剪刀手爱德华。</p></blockquote>

<p>在这部电影中，可怜的家伙（Johnny Depp)想温柔的拥抱Winona Ryder但是他笨拙的剪刀手对他们俩都会造成伤害。他的脸上留下了很多伤疤。</p>

<p>拥有一对剪刀手并不总是坏事。爱德华有许多才能，比如，它可以给狗剪除漂亮的发式。</p>

<p>当参加完一些C++会议后，我总会有一些想法，最近参加的是Going Native 2013。去年可喜的是大多会议围绕着闪亮的C++11最新标准。但今年更多的关于实际检查。不要误会，这里有太多的漂亮的小狗发式可以展现（我是说C++代码可以简洁优雅）但是会议的主题总是关于如何避免出错及出错后的补救。</p>

<h2>恐怖小窝</h2>

<p>这里有太多的关于<strong>C++禁忌</strong>的讲座使我意识到这可能不是初级程序员的问题，这明显是C++语言自身的错。所以你仅仅学习了语言的基本元素后就使用它，你会遍体鳞伤的。</p>

<p>C++对此有借口：向后兼容 &mdash; 特别是兼容C语言。你应该认为C作为C++的子集应该像人们不应该每天使用汇编一样，除非你是个汇编程序员。假如你对你的C++工具箱视而不见，你看到的总是裸指针、for循环等丑陋的东西。</p>

<p>一个人所共知的禁忌是不要使用malloc动态分配内存，不要使用free释放内存。malloc接受一个size并返回一个void*，你必须把它转换成其它有用的类型。很难实现一个比这更糟糕的内存分配API。这有一段真的很糟的代码（但一般是运行正确的，假如不可能出现空指针解引用的话）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Pod</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span> <span class="n">counters</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="n">Pod</span> <span class="o">*</span> <span class="n">pod</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pod</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="k">sizeof</span> <span class="n">Pod</span><span class="p">);</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">n</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">free</span> <span class="p">(</span><span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">);</span>
</span><span class='line'><span class="n">free</span> <span class="p">(</span><span class="n">pod</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我希望人们不会写出这样的代码，但我确信现实世界的好多程序的代码中有这样的结构。</p>

<p>C++通过替换malloc和free为new和delete&#8221;解决&#8221;了多余的强转和易出错的size计算。正确的C++代码应该这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Pod</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span> <span class="n">counters</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="n">Pod</span> <span class="o">*</span> <span class="n">pod</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Pod</span><span class="p">;</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="p">[]</span> <span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
</span><span class='line'><span class="k">delete</span> <span class="n">pod</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>顺便说一下，空指针引用的问题同样被解决了，因为如果系统内存耗尽，new总是会抛出异常。但这里在第二个new的地方还是有几率发生内存泄漏，所以这是现实中正确的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Snd</span> <span class="p">{</span> <span class="c1">// Sophisticated New Data</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Snd</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">_count</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">_counters</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="p">{}</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Snd</span> <span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">_counters</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span> <span class="n">_counters</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Snd</span> <span class="o">*</span> <span class="n">snd</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Snd</span> <span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">snd</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们做完了吗？才没呢！这段代码不是异常安全的。</p>

<p>C++的基本准则是避免裸指针、避免数组、避免delete。所以医治malloc的良药new也是不应使用的，它会返回危险的指针。</p>

<p>我们都知道（满脸的伤疤可以证明）尽一切可能使用STL容器和智能指针。也应该按值传递参数。不，等一下。按值传递参数因为多余的拷贝会增加性能损耗。使用shared_ptr或shared_ptr的容器怎么样？但这会增加引用计数的滥用。这里有新的解决方案：移动语义和右值引用。</p>

<p>我能举出无数类似的例子。看到规律了没？一个问题的解决方案可能会引入新的问题。不仅C子集需要避免使用。每个新的语言特性或库组建都会带来新的缺陷。当你听完Scott Meyers讲过后，你会发现一个新的特性怎么设计的这么烂（猜一下Scott Meyers论证的最新的缺陷是什么？是移动语义）。</p>

<h2>C++的哲学</h2>

<p>Bjarne Stroustrup一直强调向后兼容对C++来说多么重要。它是C++哲学的根基。它是决定那些代码是合法的依据。然而兼容性给语言演化代理了极大的拖累。如果自然界和C++一样是向后兼容的，人们还会有尾巴、腮、脚蹼、触角 &mdash; 在进化的过程中它们都有过作用。</p>

<p>C++变成了极度复杂的语言。同一件事情有无数种实现方式，但大部分都走向错误、危险、难维护。问题是代码可以编译甚至运行。错误或者缺陷会在后来被发现，甚至是产品发布以后。</p>

<p>你可能会说这是编程语言的自然特性。如果你真这样想，那要好好看看Haskell了。你的第一反应是：用这种极度严苛的语言我不知怎样实现第一件事（阶乘、斐波那契等）。这完全不同于C++。你不会意识到，运气好的话，需要十年你才能发现C++的“真谛”。能否想到，越好的C++程序员，他的代码越具有“函数性”。请教任何一个C++大神，它会回答你：避免可变的（mutation)，避免边际效应，避免继承和派生。但是你将需要严厉的准则和可以控制你同事的能力，因为C++太宽容了。</p>

<p>Haskell一点也不宽容，它不会让你或者你的同事写出不安全的代码的。是的，一开始你可能因为想要用haskell实现C++几分钟可以完成的事情而抓狂。假如你走运，为Sean Parent<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>或类似严格的程序员共事，他将review你的代码，并指出你不要用C++编码了。或者你自己继续在黑暗的日子里，数着自己伤害自己的伤口个数。</p>

<h2>资源管理</h2>

<p>我以资源管理的例子开始这篇文章（严格说是内存管理），因为这是我的个人爱好。从90年代起我就开始写关于资源管理的东西和宣传它。不过失败的是20年后资源管理技术还是鲜为人知。Bjarne Stroustrup有责任花费一半的演讲时间给高级C++程序员讲解资源管理的知识。你也可能会责备初级程序员们没能领悟资源管理是C++编程的根基。但问题是语言并没有指出我一开始写的那段代码有什么纰漏。事实上学习正确的技术就好像学习新的语言。</p>

<p>为何如此艰难？因为C++中最重要的资源管理是内存管理。事实上需要反复强调的是垃圾收集解决不了资源管理的问题：这里有文件句柄，内核对象，打开的数据库等等。这都是重要的资源，但重要性被繁复的内存管理比下去了。为什么不支持垃圾收集，不是因为找不到一种高效的实现方式，因为C++是排斥垃圾收集的。编译器和运行时总要做最坏的打算：不仅一个指针可能是另一个的别名而且内存地址可以保存成整型甚至它的低字节用作位域（所以C++只考虑保守的垃圾收集）。</p>

<p>一个错误的常识是引用计数（shared pointer中使用）比垃圾收集更好。这有个<a href="http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf">研究</a>显示它们是异曲同工的。你应该知道delete一个shared pointer可能会引发任意时间的程序暂停，这和垃圾收集的性能损耗是一样的。这不仅仅是因为一个靠谱的引用计数算法必须处理好环（cycles），并且每次引用计数到0，对象可以达到的指针都需要遍历。用shared pointer创建的数据结构可能花费很长的时间去释放，除了极简单的情况，你无法知道什么时候shared指针要清零了。</p>

<p>在单线程环境下小心的资源管理和使用shared_ptr还是很好的防御方式。但多线程下，麻烦来了。每一次增加减少计数都需要加锁！锁一般由原子变量实现，而不是互斥量。别傻了：使用原子变量消耗很大，这带给我C++的最大问题。</p>

<h2>并发和并行（Concurrency and Parallelism）</h2>

<p>早在8年以前，herb Sutter就发表了著名的声明：<a href="http://www.gotw.ca/publications/concurrency-ddj.htm">免费的午餐结束了</a>！并发并不是发明在2005年。Posix线程1995年就定义了。微软在Windows95引入线程，在NT中支持了多处理器。然而并发是C++11中才有的知识。</p>

<p>C++11算是“白手起家”并发。它必须定义内存模型：多线程写内存时，什么时候和以什么顺序使其对其它线程可见。基于实用的考虑，C++的内存模型是从java中拷贝来的（去掉了一些有争议的数据竞争时的保证）。一句话就是，如果没有数据竞争C++程序是按次序的。</p>

<p>C++11定义了关于线程创建和管理的一些元素，这些同步元素都是被dijkstra和hoare在1960年定义的，比如互斥量（mutexes）和条件变量。有人可能会争辩这些是否是同步的好组件，但这没关系因为都知道他们不是可组装的（composable)。STM（Software Transactional Memory）是可组装的抽象，但这很难在命令式语言中高效及正确的实现。标准委员会有个STM学习小组，所以STM还是有机会成为标准的一部分的。但是因为C++对边界效应不做任何控制，所以它会很难正确应用的。</p>

<p>还有一些误导和混淆是尝试去提供基于任务的并行，使用的是async tasks和非组装的futures（慎重考虑后都会在C++14中不推荐使用）。线程局部变量的标准化也使基于任务的并发很难实现。锁和条件变量也是线程相关的，而不是任务相关的。未来几年标准委员会的当务之急就是这些了：基于任务的并行, communication通道代替futures , 任务取消, 可能还有longer term, data-driven 并行, 包括支持GPU。一个微软PPL和英特尔TBB的衍生可能会被加进标准库（希望不是微软的AMP）。</p>

<p>预测推断所有这些可以在2015年标准化和实现。假如预测成真，我还是不相信人们会用C++实现并行编程。C++是为单线程编程设计的，支持并行编程需要革命而不是改革。四个字：数据竞争，指令型语言没有对此提供保护，可能除了D语言。</p>

<p>在C++中，数据默认是线程共享的、默认是可变的；函数默认是有边界效应的。所有这些指针和引用为数据竞争提供了富饶的土壤。数据结构和函数在竞争上的先天不足使类型系统无法反射。在C++中，假如你有个对象的const引用，但不能保证另一个线程中不会修改它。更糟的是，一个const对象里面的引用默认是可变的。</p>

<p>D语言至少有深度const和不可变的概念（没有线程可以修改一个不可变的数据结构）。D语言朝着并发的另一个改良是可以定义纯函数（pure functions)。在D语言中，可变对象默认不是进程共享的。这是正确的方向，虽然增加了共享对象的运行开销。更重要的想法是，线程不是一个并发编程的好的抽象，所以这种改进在轻量级的任务序列中就不那么有效了。</p>

<p>但是C++对这些都不支持，并且看起来永远都支持不了。</p>

<p>当然，你可能认出了这些并发和并行的特征都是函数式语言具有的，特别是不可变和纯函数。别嫌我烦：Haskell是并发编程上执牛耳者，包括GPU编程。这是为什么我在布道C++技巧数载后轻易转向了haskell。每一个认真对待并发和并行的程序员都应该好好学习haskell看一下它是如何处理这一切的。这里有一本Simon Marlow写的不错的书：<a href="http://www.amazon.cn/gp/product/1449335942/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1449335942&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="">Parallel and Concurrent Programming in Haskell</a>，读完它你或者开始在C++中使用函数式编程技术，或者认识到并发编程和指令式编程的分歧而转投Haskell。</p>

<h2>结论</h2>

<p>我认为C++语言和其哲学是和并发编程的需求冲突的。这种冲突导致并发编程在主流软件开发中缓慢前行。因为这过时的编程范式，微处理器、vector units和GPU的巨大能力被业界浪费了。</p>

<p>翻译自：<a href="http://bartoszmilewski.com/2013/09/19/edward-chands/">Edward C++Hands</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Adobe公司的首席科学家和移动数字图像组的架构师<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[世界上最杰出的程序员是获得最大快乐的那个人]]></title>
    <link href="http://towriting.com/blog/2013/09/22/the-best-programmer-in-the-world/"/>
    <updated>2013-09-22T00:24:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/22/the-best-programmer-in-the-world</id>
    <content type="html"><![CDATA[<p>Colin停在我的办公室来叫我去看他最近的项目。他拆开了他的显示器切换器（用来在两台PC之间切换单个显示器），拆开的切换器就摊放在他的桌子上。他把切换器接上了从RadioShack<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>淘来的部件，服务程序和客户端也都用VB6开发好了，将这一切整合好就能实现当鼠移动到屏幕边缘时自动切换显示器。Colin做这个项目获得了很大的快乐并且正在变成我们团队里最强大的程序员。这发生在Arduino<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>创建之前一段时间，那时硬件Hacking的门槛还很高。VB6正在衰退，使用它的人被认为只能维护那些烂的LOB程序。从Colin身上，我看到了好的创造者都会有的精神：享受创造的过程而不管使用的工具。</p>

<p>我很确信人们开始编程好多是受到类似与Colin一样的一些事情的激发。多少人开始编程生涯是为了设计我们自己的游戏，自己的网站，自己解决一个问题的方法并执着于编写成代码以给项目生命？有多少人会在自己后面的职业生涯继续这种精神，通过项目，通过失败，通过批判，甚至通过一个LOB<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>程序。</p>

<p>这些年来，程序员的第一要务是谋生而不是通过分享代码或公开博客的开放。现在有了在工作中看到出色程序员的机会，同时我们可以加入目前越来越流行的趋势：将我们自己和我们的作品与其他人做比较。在GitHub和StackOverflow之前我讨厌除了我同事之外的其他人阅读或点评我的代码，我也不喜欢阅读书籍或API文档之外的代码。现在我可以看世界上几乎任何一个程序员的代码，他们也可以看我的。必须谦虚因为世界上的牛人太多了。我能靠这点信息做什么？可以有机会学习或因不足而感到沮丧？或者相反这些代码没有自己完成度好？会留下意见同时增强了自信心吗？我看到那些用VB写的代码会乐起来吗？</p>

<p>如何一直保持编码的乐趣？这是我尝试的方法：</p>

<ol>
<li>维护一个自己的项目，并倾注你的热情同时与人分享</li>
<li>持续学习-多学点并没什么不好</li>
<li>给你的同事积极的回应（特别是竞争对手）</li>
<li>感谢帮助和影响过你的人们</li>
</ol>


<p>我想我不会成为像DHH<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>,Pike<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>,Stroustrup<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>或Resig<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>这样的大牛，但我可以获得和他们获得的同样多的乐趣。是的，你也可以成为世界上最杰出的程序员。</p>

<p>翻译自：<a href="http://hackerhmb.tumblr.com/post/61477929414/thebestprogrammerintheworld">The Best Programmer in the World is the One Having the Most Fun</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>美国的一个电子元器件零售商<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>硬件hacking相关的一个网站<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>line of business application指的是企业环境中的一些固定用途的程序<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>david heinemeier hansson，Ruby On Rails的创建者<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Rob Pike, Go语言的主要创建者之一<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>Bjarne Stroustrup,C++之父<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>John Resig,jQuery库的创建者<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[讲一讲程序员的办公用品]]></title>
    <link href="http://towriting.com/blog/2013/09/21/office-stuff/"/>
    <updated>2013-09-21T16:12:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/21/office-stuff</id>
    <content type="html"><![CDATA[<blockquote><p>高性能、舒适、充足的办公用品可以提高办公效率</p></blockquote>

<p>讲一讲这四年来我所在过的公司都给我们程序员提供过怎样的装配，这些装备主要包括：计算机、椅子、文具、打印机、水果点心等。</p>

<h2>第一份工作时</h2>

<p>刚毕业时经朋友介绍去的宁波一家医疗器械公司，公司规模百来人，产值2、3亿，要说效益还是不错的。公司不是纯粹的软件公司，所以不会在配置电脑、椅子上等方面针对程序员做特殊的考虑。对于电脑等办公用品，在新人入职时，会首先考虑分配旧的（离职员工用过的），如果没有旧的，会申购新的，而有些老旧的电脑基本属于奔四的水平，使用年限在5年以上。而我就不幸的分配到这样一台组装机，金河田的机箱螺丝都没了，P4/512M，键鼠是PS/2的，这台电脑的硬盘磁头老旧，运转的时候会“嘎嘎”的响，对面的同事老是嘲笑我的电脑不行了。这样一台电脑，可以想象运行通常的软件是很吃力的，VC6编辑代码也会经常卡，每次调试时按F5都要好长时间才可以反应过来。那时刚毕业，学习阶段，觉得也没什么资格要求什么，所以一直坚持了8、9个月后，找了一个机会向主管提出了自己电脑影响工作。主管让我去搬一台仓库闲置的工控机先用着，所以用了一段时间的工控机，工控机的性能比开始那台老旧机器好一些，不过声音极大，一开机整个办公室“嗡嗡”的响，每次下班时关机，对面的同事又嘲笑我，“整个世界一下子安静了”。</p>

<p>这个声音火车般的”工控机“用过大概2个月的时间后终于退出了历史的舞台。那时主管让我替公司采购一台品牌机，用于设备的配套机器，要求性能要好，所以我就采购了当时性能还算主流偏上的DELL商用机，I52400/4G，价格是7000多元。可是，机器买回来后发现PCI插槽不够用，退又退不掉，所以主管就让我用这台机器了，使用了新电脑后应该也是我技术提升最快、工作效率最高的时期，往后在同花顺的日子，我还一直怀念这台机器。</p>

<p>到我离职前2个月，老板娘发现了我们办公室那台闲置的金河田老电脑，让我搬给新入职的一位财务姑娘。现在想来但这台电脑节省的钱，不知能不能抵消使用此电脑的低效办公的损失？</p>

<p>那时年轻，椅子什么的从来没在意过，记得自己用的座椅相对还不错的，估计300左右，而其他人有的坐的都是大几十的普通家用椅，整个公司没有一条人体工学椅，但奇怪的是那时从来没有腰酸过，但一个老程序员已经腰肌劳损了，厉害时走路都很明显。</p>

<p>至于其他办公用品，比如本子、笔、插板、灯具等等是有的，不过拿的时候需要签字，记得我离职前后，好像有些东西需要主管审批了。</p>

<p>至于水果什么的，是来到杭州后，才发现可以有的。</p>

<h2>第二份工作</h2>

<p>同花顺的开发一般会配两台电脑，一台可以连接互联网，查找资料，另一台，只能连接SVN服务器，用于开发。电脑的配置策略也和在宁波时一样，优先选用仓库中剩余的机器，自己又不幸的被分配到配置较差的机器。那是一台P4的组装器，做内网开发机用，内存2G，其实应付一般的操作也还行，但主要是我们的项目代码是百万级的，所以VC6打开工程，或者调试时也是很卡的。而那台外网的机器，运行Win7还算跑的流畅。</p>

<p>当时配的椅子却是新的，比周围人的椅子要好些，但价格也不会超过500。来到杭州后，工作强度瞬间增加很多，所以坐在椅子上的时间也变得长了很多，所以这个椅子坐了大概1个多周，自己就腰酸背疼了，还是后来又花100多元买了个靠垫才缓解了这种疼痛。</p>

<p>同花顺每天中午是有水果供应的，这里的工作氛围也很融洽，中午有时吃着水果同时聊着天，心情愉悦后，办公效率自然就上去了。</p>

<p>不能提倡浪费，但在一些小的办公用品上，感觉这里有点节俭过了头。平时打印东西总是正面打了打反面，打印纸也经常没有，没有也只能去找，可打印纸的管理者竟然是负责公司日常事务的领导。我没有去要过，但听同事说过，要打印纸，这个领导要问你几个问题：直属领导是谁，打印纸做什么用，用几张，原来的为什么用的这么快？几个问题下来，再训上几句，半个小时可能就过去了。半个小时的薪水都可以买好多斤白纸了，很难想象上市公司的董事为何可以这样胡子眉毛一把抓。</p>

<h2>现在</h2>

<p>自己现在进入了互联网公司，互联网公司讲求“快&#8221;,快就需要高效的工作。公司这么多年做过来，知道好的办公环境是员工高效工作的保证，所以我们的开发电脑配置都是主流的，自己现在的机器是I7/8G，椅子也是较好的人体工学椅。关于椅子还有一个小趣事，刚来这边时，瞅了一眼椅子，感觉很单薄，觉得很普通的椅子，骨架上面简单套着一个网状的坐垫和靠背。后来在一次培训时，听一位讲师讲到公司给我们每个人配备4K多元的椅子，是为了让我们可以舒服高效的工作。公司给我们配置了好的办公环境，我们自然没有理由不全力工作。</p>

<h2>总结</h2>

<p>说了一大堆儿话，不过是想说，有些人算不清楚，小的投入可以有大产出。切莫捡了芝麻，丢了西瓜。自己以后一定要小心类似的思维陷阱。</p>
]]></content>
  </entry>
  
</feed>
