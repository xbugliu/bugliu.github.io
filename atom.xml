<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2013-08-21T01:50:49+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++11系列-区间迭代]]></title>
    <link href="http://towriting.com/blog/2013/08/20/ranged-for-loop/"/>
    <updated>2013-08-20T22:50:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/20/ranged-for-loop</id>
    <content type="html"><![CDATA[<p>在我前面<a href="http://towriting.com/blog/2013/08/01/what-is-cpp11/">介绍C++11</a>的文章中，我提到C++11将会带来一些实用的改进。我的意思是它将移除一些不必要的打字和其它影响快速编码的壁垒。我前面讲过的<a href="http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11/">auto关键字</a>就是一个例子；现在我想讲一下区间迭代（range-based for loop）。</p>

<h2>区间迭代的基本语法</h2>

<p>近来，基本上所有现代编程语言都有一种对一个区间写for循环的便捷方式。最终，C++也有了相同的概念；你可以给循环提供一个容器，它帮你迭代。前面我们已经在<a href="http://towriting.com/blog/2013/08/01/what-is-cpp11/">什么是C++11</a>中看到了一些简单的例子。让我们回忆一下区间迭代的样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">10</span> <span class="p">);</span>
</span><span class='line'><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">20</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">vec</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码打印一个名叫vec的vector的内容，用i去捕获vector里面的值，直至vector的最后。你也可以用auto代替类型便利的迭代复杂的数据结构。例如，迭代一个map:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">address_book</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="n">address_entry</span> <span class="o">:</span> <span class="n">address_book</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>            <span class="n">cout</span>  <span class="o">&lt;&lt;</span> <span class="n">address_entry</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &lt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">address_entry</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>修改vector的值</h2>

<p>假如你想修改你正在迭代的容器的值，或者你想避免拷贝大对象，你可以用引用的变量遍历。比如，下面的迭代对一个整形vector中每个元素的值加1。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class='line'><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span> <span class="o">:</span> <span class="n">vec</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// increments the value in the vector</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">vec</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// show that the values are updated</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>区间意味着什么？</h2>

<p>Strings,arrays,和所有的STL容器可以被新的区间迭代方式迭代。但是如果你想让你自己的数据结构使用这个新语法怎么办？</p>

<p>为了使这个数据结构可迭代，它必须类似于STL迭代器。</p>

<ul>
<li>这个数据结构必须要有begin和end方法，成员方法和独立函数都行，这两个方法分别返回开始和结束的迭代器</li>
<li>迭代器支持*操作符、!=操作符、++方法（前缀形式，成员函数和独立函数都行）</li>
</ul>


<p>就这些！实现这五个函数，你就可以有一个支持区间迭代的数据结构。因为begin、end可以是非成员函数，你甚至可以适配现有数据结构而不用实现STL风格的迭代器。所有你要做的是创建你自己的支持*、前缀++和!=的迭代器，并且定义好自己的begin、end。</p>

<p>区间迭代如此NICE。所以我怀疑大部分还不支持STL迭代模型的容器都会想添加某种适配方式以支持区间迭代。这里有一个小程序演示创建一个支持区间迭代的迭代器。这个例子里，我创建了一个固定Size是100的IntVector，并且可以被一个叫做Iter的类迭代。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">IntVector</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Iter</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Iter</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVector</span><span class="o">*</span> <span class="n">p_vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
</span><span class='line'>        <span class="o">:</span> <span class="n">_pos</span><span class="p">(</span> <span class="n">pos</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">,</span> <span class="n">_p_vec</span><span class="p">(</span> <span class="n">p_vec</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 这三个方法组成支持区间迭代的迭代器的基础</span>
</span><span class='line'>    <span class="kt">bool</span>
</span><span class='line'>    <span class="k">operator</span><span class="o">!=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Iter</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">_pos</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">_pos</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="k">operator</span><span class="o">*</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">Iter</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span> <span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="o">++</span><span class="n">_pos</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">_pos</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">IntVector</span> <span class="o">*</span><span class="n">_p_vec</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">IntVector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">IntVector</span> <span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">get</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">_data</span><span class="p">[</span> <span class="n">col</span> <span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">Iter</span> <span class="n">begin</span> <span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Iter</span><span class="p">(</span> <span class="k">this</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Iter</span> <span class="n">end</span> <span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Iter</span><span class="p">(</span> <span class="k">this</span><span class="p">,</span> <span class="mi">100</span> <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="n">set</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">_data</span><span class="p">[</span> <span class="n">index</span> <span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">private</span><span class="o">:</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">_data</span><span class="p">[</span> <span class="mi">100</span> <span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">Iter</span><span class="o">::</span><span class="k">operator</span><span class="o">*</span> <span class="p">()</span> <span class="k">const</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">_p_vec</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span> <span class="n">_pos</span> <span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">IntVector</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">v</span><span class="p">.</span><span class="n">set</span><span class="p">(</span> <span class="n">i</span> <span class="p">,</span> <span class="n">i</span> <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v</span> <span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意这段代码中区间迭代时，不允许以引用修改IntVector中的元素。这是为了不使代码变长而影响代码的主要结构，所以并没添加返回引用类型的函数。</p>

<h2>区间迭代提升性能？</h2>

<p>在我使用GCC4.6的有限的测试中，我并没看到区间迭代相对于标准STL迭代的性能提升，但好像可以和STL中的for_each拥有同样的性能。</p>

<h2>编译器支持</h2>

<p>不幸的是，区间迭代的编译器支持的不好。MSVC11以后开始支持，GCC是4.6以后支持。</p>

<p>下一篇：静态表达式</p>

<p>上一篇：<a href="http://towriting.com/blog/2013/08/11/lambda-closures/">lambda表达式</a></p>

<p>译者：<a href="http://towriting.com/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-ranged-for-loop.html">Range-Based For Loops in C++11 &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[七年前作的一首打油诗]]></title>
    <link href="http://towriting.com/blog/2013/08/17/a-doggerel-of-seven-years-ago/"/>
    <updated>2013-08-17T23:45:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/17/a-doggerel-of-seven-years-ago</id>
    <content type="html"><![CDATA[<pre><code>令伊伤神赴荆门
狐死首丘怀故人
祝君安康序仲昆
晋地荒凉伤我心
州内琐忆感乾坤
二更如梦仿诸君
中北桑梓孤独魂
漂泊天涯无定坟
泊头火柴烟头灰
学海无涯岸边蹲
子为成仙广寒奔
事虽有定人两分
业债空乘雪霜痕
有心插柳未生根
成败晦朔魄空存
</code></pre>

<p>这是06年10月份，刚升大学时，写的一首藏头诗：令狐祝晋州二中漂泊学子事业有成。这是自己写来勉励自己与高中同学的，那时大家都叫我令狐。听起来很俗套，句子想必也很晦涩，大家不一定能看得懂，自己也不一一解释。不管如何，庆幸当年留下的东西，可以今天拿来回忆。</p>

<p>七年过去。记得当初写完这首藏头诗，发给几个要好的同学，一个最要好的同学立刻回复：有才。可就是这个最要好的同学在三年前已离我们而去。人生无常，迟早我们都要离开这个世界，可是小小年纪，人生刚刚扬帆即草草落幕，甚是可惜。他走的那年，我们剩余的好友相聚，酒喝了一斤多，醉后抱头痛哭！</p>

<p>刚上大学时，经常做这样一个梦：没好好学习，学校开除我，我要回高中再读。每到此时，都惊出一身冷汗，随即醒来，长吁一声。可见高中的学习在内心深处对我如梦魇一般，但这一点我却不自知。如果有人问我，哪段人生经历最值得珍惜，我会毫不犹豫的说高中。</p>

<p>高中时候，是我们逝去的青春岁月。学业虽然很繁重，我们也很穷，没钱买什么东西，但确是自己最快乐的时光。大家住校，相互之间称呼都很亲昵，一般都是一个字，或者各种外号。每天的日子，看起来都是重复的，早上早早起床出操，然后一天学习，直至晚上10点，中间穿插着吃饭。早起的喇叭里总是放着那几首歌曲，乃至今日我一听这几首歌，脑中就浮现路灯照进宿舍，大家极不情愿的起床穿衣的情景。</p>

<p>高中结时的朋友，感情是可以和发小一样的。自己庆幸自己认识了几个这样的朋友，有他们陪伴的高中岁月一度是很快乐的。大家相互扶持走过了高中，完成了那样繁重的学业。</p>

<p>七年过去了，同学之间的联系渐渐稀疏，各处天南海北，有些还在国外。年少时曾经志存高远，但长大后被现实折磨的没了脾气，同学们大部分过得并不得意，但也有小部分梦想还没被磨灭。不管怎样，希望大家不要麻木，但不要疲惫的去追求什么，成功是相对的，物质的生活容易满足，内心的满足不易。</p>

<p>往昔概相濡以沫，今后翼相望江湖！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员的困境]]></title>
    <link href="http://towriting.com/blog/2013/08/16/programmer-dilemma/"/>
    <updated>2013-08-16T21:34:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/16/programmer-dilemma</id>
    <content type="html"><![CDATA[<p>最近面试了数十个应聘内核开发职位的求职者。这些求职者都来自于芯片或嵌入式操作系统领域出名的非常好的大公司。他们大都声称他们在内核开发领域有至少十年经验。他们的简历看起来闪闪发光，充满着相关项目经验，各种时髦的技术词和奖项&hellip;</p>

<p>但是他们大部分无法回答一个基础的问题：<strong>当你调用标准的malloc函数时，内核里面发生了什么</strong>？</p>

<p>不要吃惊。当我让一位求职者写一个基于glib哈希函数的简单LRU缓存框架时，他首先说他从没用过glib，这是我预料之中的。我把glib手册给他并给他详细讲解了接口，接着一个多小时以后他只写出了几行糟糕的代码。</p>

<p>我不知道这种情况在其他国家是否一样，但是在中国，特别是北京，这就是事实。工作在知名外企数年的&#8221;高级&#8221;程序员无法解决简单基础的问题。</p>

<h2>为什么会这样</h2>

<p>我越想越相信导致这种现象的不仅是他们自己的原因更要归咎于他们就职的公司。这些公司会给他们大量的数年不会有重要修改的稳定的代码。有技术含量的东西都被封装进了这些代码，所以他们只能因循守旧，不再创新。假如你恰巧在这样的代码上工作了很长的时间而没有接触外面的世界，总有一天你会发现自己会处在一个悲哀的境地：在团队或公司内他们叫你&#8221;<strong>专家</strong>&ldquo;，但不幸的是在市场上你难以找到一份不错的工作。</p>

<p>这就叫做<strong>专家陷阱</strong>。日复一日，我们程序员的梦想就是成为团队/公司的专家；然而这一天到来时我们围困了自己。我们在现有代码上钻的越深，我们陷得越深。我们渐渐丧失了从头写一个完整项目的能力，因为现存的代码如此稳固。更糟的是，假如我们的主要工作仅是维护现存的代码，在此之上进行微小的开发，不久之后，不管曾经阅读和学习过多少代码，我们会发现我们无法再写代码&mdash;即使应届生都可以胜任的简单问题。这就是程序员的困境：我们以代码为生，但供养我们的大公司却慢慢摧毁我们谋生的能力。</p>

<h2>如何摆脱这种困境</h2>

<h3>针对个人</h3>

<p>首先，<strong>做你自己的项目</strong>。你需要不断&#8221;磨快你的刀&#8221;。假如你的工作无法对此提供帮助，那你就挑选自己感兴趣的问题并且用自己的时间攻克它。这样做，你肯定会学到新东西。假如你发布自己的项目，比如在Github上，你可能会有机会认识把你拉出当前位置的人。</p>

<p><strong>不要在一个团队里呆的时间超过两年</strong>。强制自己去其它岗位，即使是在同一公司统一组织你也可能会面临新的挑战和技术。试着每18个月进行一些面试。你不一定要换你的工作，但是你要看一下市场上需要什么而自己如何适应需求。</p>

<h3>针对团队/公司</h3>

<p><strong>给你的员工压力与挑战</strong>。轮换岗位，让&#8221;专家&#8221;有机会去拓展技能。开启新的项目，给战士们提供战场。</p>

<p><strong>定期举办&#8221;编程马拉松&#8221;</strong>。这将建立一种改革与创新的文化。人们会被杰出者激励 &mdash; &ldquo;太酷了，这个家伙竟然可以在24小时内写出如何优美的框架，我要努力了&#8221;。</p>

<p>译者：<a href="http://towriting.com/">toWriting.com</a>翻译自：<a href="https://medium.com/i-m-h-o/231d7499a75">Programmer’s dilemma</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[人生本应丰富多彩：《别逗了,费曼先生》读后感]]></title>
    <link href="http://towriting.com/blog/2013/08/12/book-review-surely-you-are-joking-mr-feynman/"/>
    <updated>2013-08-12T23:49:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/12/book-review-surely-you-are-joking-mr-feynman</id>
    <content type="html"><![CDATA[<p>知道这本书的时间应该不超过一年，至少是在经常逛stackoverflow以后，那至少是2011年以后的事了。stackoverflow中列出的<a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read">每个程序员都应该读的书</a>里面，有几本书看起来和编程风牛马不相及，其中之一就是这本《别逗了，费曼先生》。</p>

<p>书不厚，买来20天断续读完，坦白的说没有达到读之前的预期。因为stackoverflow推荐书单上，自己读过的其它书籍，读后或是能切身感觉到促进自己技能的，比如《代码大全》、《设计模式》；或是震撼自己认知的，比如《禅与摩托车维修艺术》。产生预期差异的原因是本不应抱着世俗的心去读它，本书不会直接提高编程技能。费曼是个顶尖的拿过诺贝尔的理论物理学家，但他同时也是一个爱搞怪、特例独行、有小毛病的正常人。他写这本书可能仅为博大家一乐，或者炫耀自己多彩的人生。要脱去费曼物理学家的皮，像亚马逊一条置顶书评说的：“It shows that even our greatest scientists can be just regular guys like you and me“。</p>

<h2>人生就应如费曼这样，而不是把时光都浪费在做自己不喜欢的事情上：</h2>

<h2>多彩的童年</h2>

<p>费曼小时候做的好多事，相信我们中国的孩子也都做过：喜欢瞎捣鼓，修个收音机、搞个小发明什么的。修收音机还貌似都到达收费的水平。回想自己上小时候也喜欢修东西，修过电视、电子表、单放机等等，不过&#8221;修&#8221;坏许多东西，为此遭受不少父亲的呵斥。费曼小时候当过”童工“，为了偷懒搞了好多发明，接电话机，削土豆机等等，想象一群大人围在一个矮自己好几头的小鬼，看他一本正经的演示自己的发明就想笑。</p>

<h2>世俗学习生涯</h2>

<p>很早就开始读一些数学物理的教材，所以费曼考的上MIT。刚上大学时，也会像一个普通美国大学新生参加兄弟会，并且接受“残酷”的考验。本科毕业时，他去了几次贝尔实验室，可能想留下工作，不过好像贝尔的家伙没看上他，所以他失望的去了一家搞镀塑料的公司。时间不长他就去了普林斯顿读研究生。他讨厌并无法逃避一些交际，他也会为修学分而选择自己不在行的人物学科。</p>

<h2>搞怪的人生不枯燥</h2>

<p>喜欢开密码锁，并乐此不疲，是许多读过《别逗了》的人对费曼的印象。他喜欢开锁，并找机会去做，并让别人大吃一惊，为此别人很讨厌他，不让他靠近自己的锁。在MIT时，他也发扬了一把MIT的hack精神，藏了宿舍的门，并且没人相信是他做的。他用杯子戏弄服务员一节是我最喜欢的。书中充满了费曼搞怪的经历，人生如此才有趣。</p>

<h2>人生要成就</h2>

<p>这本书没讲费曼是如何牛起来的，只说他研究生毕业，想为国报效就去了军方，后来有机会参加了曼哈顿计划，他讲自己可能是第一个近距离用肉眼看原子弹爆炸的人。这些足以在历史上留下一笔了，而吾等草根大众，只会淹没于历史长河中，百年后，一抔黄土而已。后来他获得诺奖，但他讨厌别人半夜打电话告诉他，骂别人为什么不等天亮在告诉他，面对成就那是怎样的淡定。</p>

<h2>人生应有一不以此谋生的工作</h2>

<p>费曼有一些特殊的爱好，比如开锁，画画与打鼓。打鼓是他一生的最爱。一些美国的科学家最后会喜欢上一种乐器，比如爱因斯坦喜欢小提琴，但拉的很难听。但费曼的鼓打的很不懒，上的了台面，参加过巴西国家级狂欢节、参加过国际级比赛。一个不以谋生的爱好给人带来的快乐，是持久与强烈的。</p>

<h2>真性情</h2>

<p>费曼从不掩饰自己的喜好，比如漂亮女孩，歌舞表演等等，他喜欢去拉斯维加斯。有一段时间他像个普通人一样（他就是个普通人）混迹酒吧，他向人讨教追求女孩的方法，学成之后屡试不爽。</p>

<h2>爱并不一定要浪漫</h2>

<p>他的第一任妻子阿莲重病时，他被军方召集制造原子弹无法照顾她，甚至没能见她最后一面，对阿莲的生理上的死亡，他没有特别的难过。数月之后，他走过一家百货商店的橱窗，里面挂着女士的服装，他想到其中一件阿莲或许喜欢，那一刻他万分悲戚：十年生死两茫茫，不思量，自难忘！</p>

<h2>行万里路说万家言</h2>

<p>他去日本后，喜欢上了日本精致的生活，他在日本的时光很惬意（但原子的制造他参加了），他想深入了解这个民族，他住在日本人住的酒店里，日语水平也到了可以打出租车出去溜达的地步，但日语这种语气意义丰富的语言，最终令他望而却步。但他葡萄牙语说的很棒，他经常去巴西，喜欢巴西，喜欢狂欢节。他承认巴西的学生不笨，但像中国学生一样，巴西学生也读死书，不知举一反三，对此费曼很无奈。有一次费曼参加一次巴西的学术会议，巴西国内的专家都蹩脚的英语做发言，只有他一个人说葡萄牙语，这令他很差异，如果他来到中国看到举国四六级后会作何感想。</p>

<h2>勇于说“不”</h2>

<p>造原子弹时，军方限制了书信自由，费曼反抗的冲动大于写信，写出好多古怪的信件与军方周旋；看不惯军方的形式主义，执意要回自己的一元专利费；自己去做讲座，宁愿不要费用，也不向邀请方提供发票；他宁愿不要费用也不想遵守政府例行的公文材料&hellip;</p>

<h2>好奇人不老</h2>

<p>除了费曼的搞怪，给人留下强烈印象的是费曼的好奇心：观察草履虫，研究蚂蚁的觅食轨迹、追问油漆合成色、破译玛雅数学、研究读心术、搞清楚梦到底有没有颜色、经历幻觉&hellip;人要有一颗好奇心，要不断的去发现尝试试验新的东西，要不漫长的一生有什么意思？没有好奇心，人只是会行走的尸体罢了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-lambda函数]]></title>
    <link href="http://towriting.com/blog/2013/08/11/lambda-closures/"/>
    <updated>2013-08-11T22:45:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/11/lambda-closures</id>
    <content type="html"><![CDATA[<p><img class="right" src="http://towriting.com/images/posts/lambda-closures/lambda.png" width="66" height="90" title="lambda" alt="C++11一个最激动人心的特性是支持创建lambda函数（有时称为闭包）。这意味着什么？一个Lambda函数是一个可以内联写在你代码中的函数（通常也会传递给另外的函数，类似于仿函数或函数指针）。使用Lambda，创建机动函数会更简单，而以前你必须创建一个有名函数。在这篇文章中，我先用一些例子解释为什么lambda很酷，然后我会讲解可能会用到的关于lambda的所有细节。"></p>

<h2>为什么Lambda很酷</h2>

<p>想象你有一个地址簿类，并且你想要提供一个可供检索的函数。你可能会提供一个简单的函数，接受一个字符串然后返回满足所有字符串的地址。有时有些用户可能希望这样。不过假如他们只是想检索域名或者检索用户名并且忽略域名结果；或者检索出现在其他列表中的所有Email地址。这里可能有许多可能的检索方式。除了类中集成所有这些搜索选项，提供一个通用的查找方法，这个方法接受一个查找规则的函数，这样不是更好些吗？让我们叫这个函数findMatchingAddresses，它接受一个函数或仿函数对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">AddressBook</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// 使用模板可以是我们忽略函数、仿函数和Lambda的不同</span>
</span><span class='line'>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">findMatchingAddresses</span> <span class="p">(</span><span class="n">Func</span> <span class="n">func</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">_addresses</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">_addresses</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">itr</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 调用传递到findMatchingAddresses的函数并检测是否匹配规则</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span> <span class="n">func</span><span class="p">(</span> <span class="o">*</span><span class="n">itr</span> <span class="p">)</span> <span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">results</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="o">*</span><span class="n">itr</span> <span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">results</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">_addresses</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>任何人可以传递一个包含地址查找逻辑的函数给findMatchingAddresses。假如这个函数返回真，则得到相应的地址，地址将被返回。这种方式在以前的C++中一样支持，不过却遭遇一个致命缺陷：创建函数非常不方便。你必须先在其他地方定义好函数，你才能使用它。这就是Lambda出现的原因。</p>

<h2>基本Lambda语法</h2>

<p>在我们解决这个问题之前，让我们看一下真实的lambda基本语法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello world&quot;</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">func</span><span class="p">();</span> <span class="c1">// now call the function</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>好，你找到lambda了吗？它以[]开始。这个标识，叫做捕获指定器，它告诉编译器我们要创建一个lambda表达式。你将看到[](或者里面有变量）在每一个lambda函数的开始。</p>

<p>接着，像其他函数一样，我们需要一个参数列表：()。返回值呢？答案是我们不需要指定。在C++11中，假如编译器可以推导lambda函数的返回值，它将帮你做这件事而不需你显式指定。在这个例子里，编译器知道函数没有返回值。我们只是有一个打印“hello world&#8221;的函数体。这一行事实上不会触发关于打印的任何事：我们仅仅是创建了一个函数在这里。基本上相当于定义了一个普通函数。</p>

<p>我们在下面一行调用了这个lambda函数：func()，像调用其它普通函数一样。顺便看到，配合auto做这些事情是多么简单！你不用担心函数指针的丑陋语法。</p>

<h2>在我们的例子中应用Lambda</h2>

<p>让我们看看怎样将lambda应用到我们地址簿例子里，首先我们创建一个查找包含“.org&#8221;的email地址的简单函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">AddressBook</span> <span class="n">global_address_book</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">findAddressesFromOrgs</span> <span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">global_address_book</span><span class="p">.</span><span class="n">findMatchingAddresses</span><span class="p">(</span>
</span><span class='line'>        <span class="c1">// we&#39;re declaring a lambda here; the [] signals the start</span>
</span><span class='line'>        <span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">addr</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="s">&quot;.org&quot;</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>再一次，我们以捕获指示符[]开始，但这一次我们有一个参数：地址，并且我们检测地址中是否含有“.org&#8221;。再一次说明，lambda的函数体并没有在这里执行；它只会在函数findMatchingAddresses内，当函数变量被使用时，lambda中的代码才会执行。换句话说，findMatchingAddresses的每个循环中会调用lambda函数，并传给它一个地址作为参数，然后这个函数检测地址是否包含“.org&#8221;。</p>

<h2>变量捕获</h2>

<p>虽然这些简单的lambda用法也不错，但变量捕获才是成就lambda卓越的秘方。假如你想创建一个查找包含指定名字的短函数。如果可以写出这样的代码是不是非常不错？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// read in the name from a user, which we want to search</span>
</span><span class='line'><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="n">cin</span><span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">global_address_book</span><span class="p">.</span><span class="n">findMatchingAddresses</span><span class="p">(</span>
</span><span class='line'>    <span class="c1">// 注意lambda函数使用了变量 &#39;name&#39;</span>
</span><span class='line'>    <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">addr</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">name</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以证明示例代码是合法的，并且它展现了lambda函数的价值。我们可以获取声明在lambda函数之外的变量(name)，并在lambda之内使用。当findMatchingAddresses调用我们的lambda函数，函数体会被执行，当addr.find被调用，它处理用户代码传进的name。为了使这可以运行的唯一要做的事是捕获变量。我用[&amp;]捕获指示做这件事，而不是用[]。[]是告诉编译器不捕获任何变量，而[&amp;]是告诉编译器去捕获变量。</p>

<p>是不是不可思议？我们创建了一个简单的可以捕获变量的函数，并将它传给find函数，所有这些只用了几行代码。如果不用C++11实现这些，我们需要创建一个仿函数或者给AddressBook类添加一个特殊方法。用C++11，我们可以轻易实现一个简单的接口函数，但支持各种检索的功能。</p>

<p>只是好玩，我们想查找email地址小于某个特殊长度的地址。我们可以再一次轻松实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">min_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">min_len</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">global_address_book</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">addr</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">min_len</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>你将习惯于&#8221;})&ldquo;，这是lambda结束的标准语法，你开始阅读lambda相关代码或在你自己的代码中使用lambda越多，你将越多的看到这个小的代码片段。</p>

<h2>Lambda和STL</h2>

<p>毋庸质疑，lambda最大的一个优势是在使用STL中的算法(algorithms)库时。以前使用像for_each这样的算法是个体力活。然而现在使用for_each或其他STL算法就好像自己写普通循环一样。对比一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class='line'><span class="c1">//...</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="n">itr</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">itr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>和：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class='line'><span class="c1">//...</span>
</span><span class='line'><span class="n">for_each</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>要我说后一种代码更漂亮，好在它的可读性和结构，也像个普通循环，并且可以利用上for_each可以提供的普通循环没有的一些优势，比如保证你有正确的结束条件。现在你可能会想，这会不会影响性能？意想不到的结论是for_each和普通循环有一样的性能，有时甚至更快（原因是循环展开）。</p>

<p>我希望STL的例子告诉你lambda不仅仅是创建函数的一种简便方式，它创造了一种新的编码方式，当你的代码作为数据处理函数时，你可以抽象处理特殊数据结构的方式。for_each适用于List，但是如果有处理“树”的类似函数是不是很酷？所有你要做的只是写处理每个节点的代码，而无需关心遍历算法。这种一个函数管理数据，将具体的数据处理过程委托到另一个函数的分解方式很有用。使用lambda，C++允许我们这种新的编程方式。这是我们以前没有的，但for_each不是新的，只不过以前我们不想用罢了。</p>

<h2>继续新的lambda语法</h2>

<p>其实参数列表像返回值一样都是可选的，如果你想创建一个不带参数的函数的话。或许最短的lambda是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="p">[]{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个即没有参数又什么也不干的函数。一个稍有内容的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[]</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello, my Greek friends&quot;</span><span class="p">;</span> <span class="p">}();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>个人来讲，我不认可省略参数列表的价值。我认为[]和()的组合结构帮助lambda函数在代码上更出色。</p>

<h3>返回值</h3>

<p>如果你的lambda函数没有return语句，则默认返回void。假如你有一个简单的返回语句，编译器将推导返回值的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="p">[](){</span><span class="k">return</span> <span class="mi">1</span><span class="p">;}</span> <span class="c1">//编译器知道这是返回一个整型</span>
</span></code></pre></td></tr></table></div></figure>


<p>假如你写一个更复杂些的lambda函数，不止一个返回值，你应该指定返回类型（有些编译器，像GCC，即使你有多于一个返回值也不需要你这样做，但标准不保证这一点）。
Lambda函数利用<a href="http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11/">C++11可选的新返回值语法</a>将返回值放在函数的后边。事实上假如你想指定返回类型，你一定要这样做。这里有一个显式指定返回值类型的简单例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="p">[]</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 现在你告诉编译器你想要什么</span>
</span></code></pre></td></tr></table></div></figure>


<h3>抛异常指示（throw)</h3>

<p>虽然C++标准委员会决定不赞成使用throw指示符，但throw还没被移除C++。这里有许多检测throw指示符的静态代码检测工具，像PC link。假如你使用这些工具中的一个去进行编译时异常检测，你肯定想知道你的lambda函数会抛出什么异常。这样做的主要原因可能是当你传递一个lambda函数到另一个函数中，而这个函数期望你的lambda只能抛出指定的异常。给你的lambda函数添加一个异常指示，将允许PC link这样的工具去帮你检测。如果你想这样做是可以的。这有一个无参且不抛出异常的lambda函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="p">[]</span> <span class="p">()</span> <span class="k">throw</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/* 你不希望抛出异常*/</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Lambda函数是如何实现的？</h2>

<p>变量捕获的魔法是如何运作的？其实lambda实现的方法是创建一个简略的类。这个类重载了operator()，所以表现的像个普通函数。一个lambda函数是这个类的实例。当这个类构造的时候，所有捕获的变量被传送到类中并保存为成员变量。事实上这类似于以前就支持的functor。C++11的优势是这一切都变得非常简单。你可以在任意时候使用它，而不仅仅是极少的特殊场合去写一整个的类。</p>

<p>C++为性能计，实际上提供了好几种灵活的捕捉变量的方式，所有这些都是靠捕捉指示控制的[]。你已经看到了两种情况，[]中什么也没有则不捕获变量，用&amp;则变量以引用捕获。如果你创建了一个空[]的lambda函数，C++将创建一个普通的函数而不是类。这里有完整的捕获选项：</p>

<pre><code>[]  不捕获任何变量
[&amp;] 以引用方式捕获所有变量
[=] 用值的方式捕获所有变量（可能被编译器优化为const &amp;)
[=, &amp;foo] 以引用捕获foo, 但其余变量都靠值捕获
[bar] 以值方式捕获bar; 不捕获其它变量
[this] 捕获所在类的this指针
</code></pre>

<p>注意最后一个捕获选项，如果你已经指定了一个默认的捕获（=或者&amp;）那么也包含this。但是能捕获this指针的能力非常重要，这意味着写函数时你不需要区分局部变量和类属性的不同，两者都可以获取到。酷的是你不需显式指定this指针。它真的像你在写一个内联函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Foo</span> <span class="p">()</span> <span class="o">:</span> <span class="n">_x</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">func</span> <span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// a very silly, but illustrative way of printing out the value of _x</span>
</span><span class='line'>        <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">_x</span><span class="p">;</span> <span class="p">}</span> <span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">_x</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
</span><span class='line'>    <span class="n">f</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>捕获引用的优缺点</h3>

<p>以引用捕获变量时，可以在lambda函数内修改局部变量的值。这也意味着从一个函数中返回一个lambda函数，你不能以引用捕获变量，因为引用的值在函数返回时已经无效了。</p>

<h2>lambda函数的类型是什么？</h2>

<p>创建lambda函数的一个原因是有些人创建了一个希望接受lambda函数的函数。我们已经看到了我们使用模板去接收lambda函数作为参数，并且使用auto去接这个lambda函数作为一个局部变量。但是你如何命名指定的lambda函数？因为像前面看到的一样，每一个lambda函数都实现为一个独立的类，所以即使是拥有相同类型和返回值的lambda函数也是不同的类型。但C++11提供了一个便捷的外敷类去存储任何类型的函数，lambda函数、仿函数和函数指针。</p>

<h3>std::function</h3>

<p>新的std::function是传递lambda函数的最好的方式，不管是传递参数还是返回值。它允许你在模板中指定参数列表和返回值的确切类型。这里有AddressBook的例子，这次我们使用std::function代替模板。注意我们用到了&#8217;functional&#8217;头文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">AddressBook</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">findMatchingAddresses</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">_addresses</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">_addresses</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">itr</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 调用传递到findMatchingAddresses的函数并检测是否匹配规则</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span> <span class="n">func</span><span class="p">(</span> <span class="o">*</span><span class="n">itr</span> <span class="p">)</span> <span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">results</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="o">*</span><span class="n">itr</span> <span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">results</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">_addresses</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>std::function较模板的一大优势是，使用模板你必须将整个函数放到头文件中，而std::function则不用。当你的代码变化频繁并且被好多代码文件引用时，这会非常有用。</p>

<p>假如你想检测std::function是否含有一个有效的函数，把它当作boolean就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span> <span class="p">()</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 检测是否包含函数</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="n">func</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// if we did have a function, call it</span>
</span><span class='line'>    <span class="n">func</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>关于函数指针的提示</h3>

<p>在最终的C++11标准中，假如你有一个指定空捕获列表的lambda函数，那它将像普通函数一样并可以被赋值到一个函数指针。这有一个作为指针使用空捕获列表lambda的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)();</span>
</span><span class='line'><span class="n">func</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'><span class="n">f</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样是可以的，因为lambda函数没有捕获组，那也就不需要自己的类。它可以被编译成普通函数，运行被传递给普通函数。不幸的是这个特性没有被包含到MSVC10中，它被加入到标准的时间太晚了。</p>

<h2>使用Lambda实现委托</h2>

<p>让我们在看一个lambda函数的例子，这次我们创建一个委托。当调用一个普通函数时，你只需要知道这个函数。而调用类的成员函数时，你需要知道两件东西：成员函数和类对象。这是func()和obj.method()的不同。要调用一个成员方法，你需要两者，仅仅将函数地址传进去是不够的，你需要一个对象去调用这个函数。</p>

<p>让我们看一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">EmailProcessor</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">receiveMessage</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">_handler_func</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">_handler_func</span><span class="p">(</span> <span class="n">message</span> <span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// other processing</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">setHandlerFunc</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">handler_func</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">_handler_func</span> <span class="o">=</span> <span class="n">handler_func</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">_handler_func</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是注册回调函数到类里的很典型的模式，当感兴趣的事情发生时会调用回调函数。接着我们希望另一个类负责跟踪最长的消息（为什么这么做，或许你是一个无聊的管理员）。总之我们创建了如下的类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">MessageSizeStore</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">MessageSizeStore</span> <span class="p">()</span> <span class="o">:</span> <span class="n">_max_size</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">checkMessage</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">message</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">_max_size</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">_max_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">getSize</span> <span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">_max_size</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">_max_size</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我们想让checkMessage在消息来时被调用，我们该怎么做？我们不能只传进checkMessage自己。它是个成员方法，所以它需要一个对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">EmailProcessor</span> <span class="n">processor</span><span class="p">;</span>
</span><span class='line'><span class="n">MessageSizeStore</span> <span class="n">size_store</span><span class="p">;</span>
</span><span class='line'><span class="n">processor</span><span class="p">.</span><span class="n">setHandlerFunc</span><span class="p">(</span> <span class="n">checkMessage</span> <span class="p">);</span> <span class="c1">// 这行不通</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们需要绑定setHandleFunc和size_store变量的方法。恩，听起来是lambda的拿手好戏！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">EmailProcessor</span> <span class="n">processor</span><span class="p">;</span>
</span><span class='line'><span class="n">MessageSizeStore</span> <span class="n">size_store</span><span class="p">;</span>
</span><span class='line'><span class="n">processor</span><span class="p">.</span><span class="n">setHandlerFunc</span><span class="p">(</span>
</span><span class='line'>        <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span> <span class="n">size_store</span><span class="p">.</span><span class="n">checkMessage</span><span class="p">(</span> <span class="n">message</span> <span class="p">);</span> <span class="p">}</span>
</span><span class='line'><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>够酷吧，我们这里把lambda使成了胶水代码，允许我们传递普通函数到setHandleFunc，实际上调用的还是委托类的成员函数。</p>

<h2>总结</h2>

<p>lambda函数会不会出现在C++代码的各种地方？我觉得会。我开始使用lambda函数在更富生产力的代码中，它们出现在所有的地方：一些为精简代码、一些为支持单元测试、一些代替以前用宏实现的代码。Year，我想lambda比其它希腊字母要酷。</p>

<p>下一篇：<a href="http://towriting.com/blog/2013/08/20/ranged-for-loop/">区间迭代</a></p>

<p>上一篇：<a href="http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></p>

<p>译者：<a href="http://towriting.com/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html">C++11 &ndash; Lambda Closures, the Definitive Guide &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-改进的类型推导：auto、decltype和新的函数语法]]></title>
    <link href="http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11/"/>
    <updated>2013-08-08T00:18:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11</id>
    <content type="html"><![CDATA[<p>C++11引入了一些新的实用的类型推导能力，这意味着你可以花费更少的时间去写那些编译器已经知道的东西。当然有些时候你需要帮助编译器或者你的编程伙伴。但是C++11，你可以在一些乏味的东西上花更少的时间，而多去关注逻辑本身。</p>

<h2>auto之乐</h2>

<p>我们先快速回顾一下auto，万一你没有读<a href="http://towriting.com/blog/2013/08/01/what-is-cpp11/">第一篇C++11文章</a>中关于auto的部分。在C++11中，如果编译器在定义一个变量的时候可以推断出变量的类型，不用写变量的类型，你只需写auto即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这当然不是auto预期的用途！它会在模板和迭代器的配合使用中闪耀光芒：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">iterator</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>其它时候auto也会非常有用。比如，你有一些下面格式的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BuiltType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Builder</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">makeAndProcessObject</span> <span class="p">(</span><span class="k">const</span> <span class="n">Builder</span><span class="o">&amp;</span> <span class="n">builder</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">BuiltType</span> <span class="n">val</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">makeObject</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">// do stuff with val</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码，我们看到这里需要两个模板参数：一个是Builder对象的类型，另一个是Builder创建出的对象的类型。糟糕的是创建出的类型无法被推导出，所以每次你必须这样调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">MyObjBuilder</span> <span class="n">builder</span><span class="p">;</span>
</span><span class='line'><span class="n">makeAndProcessObject</span><span class="o">&lt;</span><span class="n">MyObj</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">builder</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是auto立即将丑陋的代码一扫无余，当Builder创建对象时不用写特殊代码了，你可以让C++帮你做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Builder</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">makeAndProcessObject</span> <span class="p">(</span><span class="k">const</span> <span class="n">Builder</span><span class="o">&amp;</span> <span class="n">builder</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">makeObject</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">// do stuff with val</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在你仅需一个模板参数，而且这个参数可以在函数调用的时候轻松推导：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">MyObjBuilder</span> <span class="n">builder</span><span class="p">;</span>
</span><span class='line'><span class="n">makeAndProcessObject</span><span class="p">(</span> <span class="n">builder</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样更易调用了，并且没丢失可读性，却更清晰了。</p>

<h2>decltype和新的返回值语法</h2>

<p>现在你可能会说auto就这样吗，假如我想返回Builder创建的对象怎么办？我还是需要提供一个模板参数作为返回值的类型。好！这充分证明了标准委员有一群聪明的家伙，对这个问题他们早想好了一个完美的解决方案。这个方案由两部分组成：decltype和新的返回值语法。</p>

<h3>新的返回值语法</h3>

<p>让我们讲一下新的返回值语法，这个语法还能看到auto的另一个用处。在以前版本的C和C++中，返回值的类型必须写在函数的前面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在C++11中，你可以把返回类型放在函数声明的后面，用auto代替前面的返回类型，像这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是为什么我要这样用？让我们看一个证明这个语法好处的例子。一个包含枚举的类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Person</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">enum</span> <span class="n">PersonType</span> <span class="p">{</span> <span class="n">ADULT</span><span class="p">,</span> <span class="n">CHILD</span><span class="p">,</span> <span class="n">SENIOR</span> <span class="p">};</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">setPersonType</span> <span class="p">(</span><span class="n">PersonType</span> <span class="n">person_type</span><span class="p">);</span>
</span><span class='line'>    <span class="n">PersonType</span> <span class="n">getPersonType</span> <span class="p">();</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">PersonType</span> <span class="n">_person_type</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们写了一个简单的类，里面有一个类型PersonType表明Person是小孩、成人和老人。不做特殊考虑，我们定义这些成员方法时会发生什么？
第一个设置方法，很简单，你可以使用枚举类型PersonType而不会有错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">setPersonType</span> <span class="p">(</span><span class="n">PersonType</span> <span class="n">person_type</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">_person_type</span> <span class="o">=</span> <span class="n">person_type</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而第二个方法却是一团糟。简单的代码却编译不过：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// 编译器不知道PersonType是什么，因为PersonType会在Person类之外使用</span>
</span><span class='line'><span class="n">PersonType</span> <span class="n">Person</span><span class="o">::</span><span class="n">getPersonType</span> <span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_person_type</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你必须要这样写，才能使返回值正常工作</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Person</span><span class="o">::</span><span class="n">PersonType</span> <span class="n">Person</span><span class="o">::</span><span class="n">getPersonType</span> <span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_person_type</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这可能不算大问题，不过会容易出错，尤其是牵连进模板的时候。</p>

<p>这就是新的返回值语法引进的原因。因为函数的返回值出现在函数的最后，而不是前面，你不需要补全类作用域。当编译器解析到返回值的时候，它已经知道返回值属于Person类，所以它也知道PersonType是什么。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">Person</span><span class="o">::</span><span class="n">getPersonType</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">PersonType</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_person_type</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>好，这确实不错，但它真的能帮助我们什么吗？我们还不能使用新的返回值语法去解决我们之前的问题，我们能吗？不能，让我们介绍新的概念：decltype。</p>

<h2>decltype</h2>

<p>decltype是auto的反面兄弟。auto让你声明了一个指定类型的变量，decltype让你从一个变量（或表达式）中得到类型。我说的是什么？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="n">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 相当于 auto y = x;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以对基本上任何类型使用decltype，包括函数的返回值。嗯，听起来像个熟悉的问题，假如我们这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">decltype</span><span class="p">(</span> <span class="n">builder</span><span class="p">.</span><span class="n">makeObject</span><span class="p">()</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将得到makeObject的返回值类型，这能让我们指定makeAndProcessObject的返回类型。我们可以整合进新的返回值语法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Builder</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">auto</span>
</span><span class='line'><span class="n">makeAndProcessObject</span> <span class="p">(</span><span class="k">const</span> <span class="n">Builder</span><span class="o">&amp;</span> <span class="n">builder</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltype</span><span class="p">(</span> <span class="n">builder</span><span class="p">.</span><span class="n">makeObject</span><span class="p">()</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">makeObject</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">// do stuff with val</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这仅适用于新的返回值语法，因为旧的语法下，我们在声明函数返回值的时候无法引用函数参数，而新语法，所有的参数都是可访问的。</p>

<h2>auto：引用、指针和常量</h2>

<p>下面要确定的一个问题是auto如何处理引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span> <span class="c1">// int&amp; or int?</span>
</span></code></pre></td></tr></table></div></figure>


<p>答案是在C++11中，auto处理引用时默认是值类型，所以下面的代码bar是int。不过你可以指定&amp;作为修饰符强制它作为引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span> <span class="c1">// int</span>
</span><span class='line'><span class="k">auto</span><span class="o">&amp;</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span> <span class="c1">// int&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过，假如你有一个指针auto则自动获取指针类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">*</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">p_bar</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span> <span class="c1">// int*</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是你也可以显式指定表明变量是一个指针：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">*</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'><span class="k">auto</span> <span class="o">*</span><span class="n">p_baz</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span> <span class="c1">// int*</span>
</span></code></pre></td></tr></table></div></figure>


<p>当处理引用时，你一样可以标记const，如果需要的话：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span> <span class="c1">// const int&amp;</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者指针：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span><span class="o">*</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">const_foo</span><span class="p">();</span>
</span><span class='line'><span class="k">const</span> <span class="k">auto</span><span class="o">*</span> <span class="n">p_bar</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span> <span class="c1">// const int*</span>
</span><span class='line'><span class="k">auto</span> <span class="n">p_bar</span> <span class="o">=</span> <span class="n">const_foo</span><span class="p">();</span> <span class="c1">// const int*</span>
</span></code></pre></td></tr></table></div></figure>


<p>所有这些都很自然，并且这遵循C++模板中类型推导的规则。</p>

<p>下一篇：<a href="http://towriting.com/blog/2013/08/11/lambda-closures/">Lambda表达式简明教程</a></p>

<p>上一篇：<a href="http://towriting.com/blog/2013/08/01/what-is-cpp11/">什么是C++11</a></p>

<p>译者：<a href="http://towriting.com/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html">C++11 &ndash; Auto, Decltype and return values after functions &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建支持拖拽的进程]]></title>
    <link href="http://towriting.com/blog/2013/08/06/process-can-drag-drop/"/>
    <updated>2013-08-06T22:48:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/06/process-can-drag-drop</id>
    <content type="html"><![CDATA[<p>Win7下管理员权限的进程一般不支持拖拽，除非启动一个管理员权限的Explorer。前一段时间，同事给我提出一个需求：管理员权限进程创建非管理员权限进程，方法很简单，见前面的文章：<a href="http://towriting.com/blog/2013/07/31/de-elevate-start-process/">降权启动进程</a>。</p>

<p>而后的一次交谈，才知道同事的真正目的是，创建出的进程支持拖拽。我只是创建出了非管理员的进程，而是否管理员与支持拖拽并没有直接联系，决定拖拽的是<strong>User Interface Privilege Isolation</strong> (<a href="http://en.wikipedia.org/wiki/User_Interface_Privilege_Isolation">UIPI</a>)特性。</p>

<p>根据UIPI，低Integrity的进程无法向高Integrity的进程发送任意消息，这导致高Integrity看起来不支持拖拽。所以要使创建的进程支持拖拽，要满足Integrity低于或等于Explorer进程的Integrity值。</p>

<p>前面文章<a href="http://towriting.com/blog/2013/07/31/de-elevate-start-process/">降权启动进程</a>中，我们通过函数CreateNormalUserToken取得了受限的Token，只要修改此Token的Integrity即可使创建的进程拥有合适的Integrity，我们实现一个修改TokenIntegrity值的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">BOOL</span> <span class="n">ChangeTokenIntegrity</span><span class="p">(</span><span class="n">HANDLE</span> <span class="o">&amp;</span><span class="n">hToken</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">SID_IDENTIFIER_AUTHORITY</span> <span class="n">MLAuthority</span> <span class="o">=</span> <span class="n">SECURITY_MANDATORY_LABEL_AUTHORITY</span><span class="p">;</span>
</span><span class='line'>    <span class="n">PSID</span> <span class="n">pIntegritySid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AllocateAndInitializeSid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MLAuthority</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SECURITY_MANDATORY_MEDIUM_RID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pIntegritySid</span><span class="p">))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">TOKEN_MANDATORY_LABEL</span> <span class="n">tml</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class='line'>    <span class="n">tml</span><span class="p">.</span><span class="n">Label</span><span class="p">.</span><span class="n">Attributes</span> <span class="o">=</span> <span class="n">SE_GROUP_INTEGRITY</span><span class="p">;</span>
</span><span class='line'>    <span class="n">tml</span><span class="p">.</span><span class="n">Label</span><span class="p">.</span><span class="n">Sid</span> <span class="o">=</span> <span class="n">pIntegritySid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">BOOL</span> <span class="n">bRet</span> <span class="o">=</span> <span class="n">SetTokenInformation</span><span class="p">(</span><span class="n">hToken</span><span class="p">,</span> <span class="n">TokenIntegrityLevel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tml</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">tml</span><span class="p">)</span> <span class="o">+</span> <span class="n">GetLengthSid</span><span class="p">(</span><span class="n">pIntegritySid</span><span class="p">)));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">pIntegritySid</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">FreeSid</span><span class="p">(</span><span class="n">pIntegritySid</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">bRet</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面第五行AllocateAndInitializeSid函数的第三个参数，这里取值SECURITY_MANDATORY_MEDIUM_RID是因为Explorer进程的Integrity一般是Medium。当然如果有必要也可以根据获取的Explorer进程的Integrity设置这个值。</p>

<p>参考：<a href="http://msdn.microsoft.com/en-us/library/bb625963.aspx">Windows Integrity Mechanism Design</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress定制公益404页面]]></title>
    <link href="http://towriting.com/blog/2013/08/04/octopress-custom-404/"/>
    <updated>2013-08-04T00:10:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/04/octopress-custom-404</id>
    <content type="html"><![CDATA[<p>一向不认为自己是一个有社会责任感的人，但为什么要接入公益404页面？那是因为我的博客托管在Github上，有一次输错自己博客文章的链接，一下子跑到了Github的默认404上，感觉很突兀。所以自己想定制一个404，而现在公益404很流行，举手之劳，何乐不为。</p>

<h2>1. 创建404页面</h2>

<p>首先，需要创建自定义的404页面，最初我是这样创建的，将404错误页面创建到source目录下的error目录</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rake new_page<span class="o">[</span>error/404.html<span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建一个新的目录error专门保存错误页面，有两个好处。1是存储结构清晰，2是可以在robots.txt将整个目录Disallow掉。</p>

<p>但后来看到github自定义404页面的<a href="https://help.github.com/articles/custom-404-pages">说明</a>，404页面必须放在网站根目录下，所以必须将404页面创建到source目录下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rake new_page<span class="o">[</span>404.html<span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>2. Robots文件隐藏404页面</h2>

<p>404页面异常页面，所谓家丑不可外扬，此页面无需搜索引擎爬虫知道。编辑robots.txt文件，添加404页面的Disallow：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>---
</span><span class='line'>layout: nil
</span><span class='line'>---
</span><span class='line'>User-agent: *
</span><span class='line'>Disallow: /404.html
</span><span class='line'>
</span><span class='line'>Sitemap: <span class="o"></span>/sitemap.xml
</span></code></pre></td></tr></table></div></figure>


<h2>3. 网站地图中隐藏掉404页面</h2>

<p>同样网站地图也不需要包含添加404页面。打开plugins/sitemap_generator.rb，找到EXCLUDED_FILES，然后添加404.html。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Change SITEMAP_FILE_NAME if you would like your sitemap file</span>
</span><span class='line'><span class="c1"># to be called something else</span>
</span><span class='line'><span class="no">SITEMAP_FILE_NAME</span> <span class="o">=</span> <span class="s2">&quot;sitemap.xml&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Any files to exclude from being included in the sitemap.xml</span>
</span><span class='line'><span class="no">EXCLUDED_FILES</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;atom.xml&quot;</span><span class="p">,</span> <span class="s2">&quot;404.html&quot;</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Any files that include posts, so that when a new post is added, the last</span>
</span><span class='line'><span class="c1"># modified date of these pages should take that into account</span>
</span><span class='line'><span class="no">PAGES_INCLUDE_POSTS</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;index.html&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. 定制公益404页面</h2>

<p>我选择的是<a href="http://www.qq.com/404/">腾讯公益404</a>，进入这个<a href="http://www.qq.com/404/">网站</a>拷贝其提供的JS代码，只需将其嵌入到我们的404页面(404.html)即可。下面是我修改过的404页面，把header、footer、comments等都去掉，只显示一个标题和公益广告：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>---
</span><span class='line'>layout: page
</span><span class='line'>title: <span class="s2">&quot;&quot;</span>
</span><span class='line'>header: <span class="nb">false</span>
</span><span class='line'>date: 2013-08-04 00:08
</span><span class='line'>comments: <span class="nb">false</span>
</span><span class='line'>sharing: <span class="nb">false</span>
</span><span class='line'>footer: <span class="nb">false</span>
</span><span class='line'>---
</span><span class='line'>&lt;center&gt;&lt;h1&gt;ToWriting.com 404!&lt;/h1&gt;&lt;/center&gt;
</span><span class='line'>&lt;script <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;text/javascript&quot;</span> <span class="nv">src</span><span class="o">=</span><span class="s2">&quot;http://www.qq.com/404/search_children.js?edition=small&quot;</span> <span class="nv">charset</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span>&gt;&lt;/script&gt;
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bg,Fg,&,Ctrl-Z -- 5个例子搞定Unix(linux)后台任务]]></title>
    <link href="http://towriting.com/blog/2013/08/03/unix-background-job/"/>
    <updated>2013-08-03T19:25:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/03/unix-background-job</id>
    <content type="html"><![CDATA[<p>当你执行一个要花费很长时间的unix脚本或者命令时，你可以在后台执行这个任务。</p>

<p>在这篇文章中，让我们回顾一下如何执行一个任务到后台、将任务切换到前台、查看所有后台任务和结束一个后台任务。</p>

<h2>1. 执行一个后台任务</h2>

<p>在命令后面添加<a href="https://en.wikipedia.org/wiki/Ampersand">&amp;</a>就可以将任务执行到后台。</p>

<p>比如，当你执行一个可能耗时很长的查找命令，你可以像下面例子中一样将它执行到后台。下面的例子将查找root目录下24小时内被修改过的文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>find / -ctime -1 &gt; /tmp/changed-file-list.txt &amp;
</span></code></pre></td></tr></table></div></figure>


<h2>2. 通过CTRL-Z和bg命令将当前任务切换到后台</h2>

<p>你也可以将一个已经运行的前台任务切换到后台：</p>

<ul>
<li>组合键 ‘CTRL+Z’ 将暂停当前任务。</li>
<li>执行bg将任务切换到后台执行</li>
</ul>


<p>像下面的例子，假如你忘记将任务执行到后台，你无需结束当前任务再启动一个新的后台任务。你可以暂停当前任务然后将它切换到后台：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>find / -ctime -1 &gt; /tmp/changed-file-list.txt
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span><span class="o">[</span>CTRL-Z<span class="o">]</span>
</span><span class='line'><span class="o">[</span>2<span class="o">]</span>+  Stopped                 find / -ctime -1 &gt; /tmp/changed-file-list.txt
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span><span class="nb">bg</span>
</span></code></pre></td></tr></table></div></figure>


<h2>3. 使用jobs命令查看所有后台任务</h2>

<p>你可以使用<strong>jobs</strong>命令列出所有后台任务。一个jobs命令的可能输出如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">jobs</span>
</span><span class='line'><span class="o">[</span>1<span class="o">]</span>   Running                 bash download-file.sh &amp;
</span><span class='line'><span class="o">[</span>2<span class="o">]</span>-  Running                 evolution &amp;
</span><span class='line'><span class="o">[</span>3<span class="o">]</span>+  Done                    nautilus .
</span></code></pre></td></tr></table></div></figure>


<h2>4. 通过fg命令将后台任务切换到前台</h2>

<p>你可以通过<strong>fg</strong>命令将后台任务切换到前台。如果执行fg命令不带参数，则将最近的后台任务切换到前台。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">fg</span>
</span></code></pre></td></tr></table></div></figure>


<p>假如你有多个后台任务，你又想将指定任务切换到前台，那你可以先执行jobs命令列出所有任务号和对应命令。下面的例子，fg %1将一号任务(download-file.sh)切换到前台。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">jobs</span>
</span><span class='line'><span class="o">[</span>1<span class="o">]</span>   Running                 bash download-file.sh &amp;
</span><span class='line'><span class="o">[</span>2<span class="o">]</span>-  Running                 evolution &amp;
</span><span class='line'><span class="o">[</span>3<span class="o">]</span>+  Done                    nautilus .
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span><span class="nb">fg</span> %1
</span></code></pre></td></tr></table></div></figure>


<h2>5. 通过kill %结束指定的后台任务</h2>

<p>假如你想杀死指定的后台任务，用<strong>kill</strong> %任务号就行了。下面是杀死2号任务的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">kill</span> %2
</span></code></pre></td></tr></table></div></figure>


<p>译者：<a href="http://toWriting.com">toWriting.com</a>；翻译自：<a href="http://www.thegeekstuff.com/2010/05/unix-background-job/">Bg, Fg, &amp;, Ctrl-Z – 5 Examples to Manage Unix Background Jobs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-什么是C++11]]></title>
    <link href="http://towriting.com/blog/2013/08/01/what-is-cpp11/"/>
    <updated>2013-08-01T20:32:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/01/what-is-cpp11</id>
    <content type="html"><![CDATA[<h2>什么是C++0x?</h2>

<p>C++0x是C++最新标准标准化过程中的曾用名，在这一系列文章中我们将介绍最新标准添加的一系列新的语言特性。在2011年9月份，C++0x正式由官方发布并命名C++11，现在很多编译器已经支持了部分C++11特性。</p>

<p>C++11包括大量的新特性：主要特征像<a href="http://en.cppreference.com/w/cpp/language/lambda">lambda</a>表达式和移动语义，实用的类型推导关键字auto，更简单的容器遍历方法，和大量使模板更容易使用的改进。这一系列教程将包含所以以上特性。</p>

<h2>你该关注C++11吗？</h2>

<p>很明显，C++11为C++带来了大量的新特性。C++11将修复大量缺陷和降低代码拖沓，比如lambda表达式的支持将使代码更简洁。像移动语义这种特性会提高语言内核的基础效率，使你可以写出更快的代码。对模板系统的优化可以使你更容易写出泛型的代码。</p>

<p>新的标准库同时也会包含新的特性，包括对多线程的支持和优化智能指针，后者将给那些还没用类似于<a href="http://www.boost.org/doc/libs/1_46_1/libs/smart_ptr/shared_ptr.htm">boost::shared_ptr</a>的人提供更简单的内存管理方法。</p>

<p>我已经开始使用新的C++11特性，并且非常喜欢：新的auto关键字，对模板&#8221;>>&ldquo;写法的支持，lambda表达式和新的函数定义语法。</p>

<h2>C++11是如何开发出来的？</h2>

<p>C++11的出现，首先要感谢C++标准委员会的辛勤工作，一群来自学术界和工业界的专家，他们的多次会晤攻克难题，终于设计出了一种跨平台，被多种编译器支持，可以生成高效易维护代码的语言。而C++11新标准，就像对灵活强大的C++的一次不可思议的扩展。</p>

<h2>C++11包括什么？</h2>

<h4>更易用的语言</h4>

<p>使用过C++11后，我发现它提供了大量的基础方法使C++变成了一种更易使用的语言。这不是说它变成了简单的语言&mdash;这里有大量的新特性&mdash;提供了大量的方法使编程更容易。让我们看一个例子，auto关键字。在C++11中，假如编译器可以从变量的初始化中得到它的类型，那么你不必要指定类型。比如，你可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译器可以推导出y的类型是int。当然，这不是一个证明auto有用的一个闪亮的例子。当使用模板特别是STL时auto很好用。为什么这么说，想象使用一个迭代器(iterator):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">address_book</span><span class="p">;</span>
</span><span class='line'><span class="n">address_book</span><span class="p">[</span><span class="s">&quot;Alex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;webmaster@towriting.com&quot;</span><span class="p">;</span>
</span><span class='line'><span class="c1">//add a bunch of people to address_book</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在你想遍历address_book中的元素，要这样做，你需要一个迭代器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">address_book</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个恐怖的长类型声明，当你已经知道这个类型的时候。这样是不是简洁多了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">address_book</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码变得更简单明了，我觉得可读性也更高了，因为模板语法使这一行其它内容变模糊了。这是我特别喜欢的一个特性，我发现它消除了许多头疼和难以追踪的编译错误，节省了时间而没有丢掉表达式的意思。</p>

<h4>区间迭代（range-based for loop)</h4>

<p>下面迭代器的例子是C++11提供的一种处理迭代的更好方法，有些人叫做区间迭代（基本上所有的现代语言都支持）。这个例子足够证明这种语法是多么优雅：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="nl">i:</span> <span class="n">vec</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你需要做的就是给出一个变量和要迭代的区间。但是如果你想迭代一个map怎么办？你怎么设置map中值的类型？你知道vector值的类型是int。但map的值类型是pair，通过.first和.second给你提供键和值。但是用auto，你根本无需关心确切类型，你可以简单的写成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">address_entry:</span> <span class="n">address_book</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">address_entry</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="s">&quot; &quot;</span><span class="o">&lt;</span><span class="n">address_entry</span><span class="p">.</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这将打印出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Alex webmaster@towriting.com
</span></code></pre></td></tr></table></div></figure>


<p>这是一个不错的C++11新特性组合用法吧？</p>

<h4>>>(right angle brackets)</h4>

<p>我这里还有更易用的优化&mdash;在以前的C++标准中，假如你写一个含有其他模板类型的模板：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">vector_of_int_vectors</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>你必须在结束的两个&#8217;>&lsquo;之间添加空格。这不仅烦人，而且当你写成>>而没有空格时，你将得到困惑和误导的编译错误信息。产生这种行为的原因是C++词法分析的最大匹配原则（<a href="http://en.wikipedia.org/wiki/Maximal_munch">maximal munch rule</a>)。一个好消息是从今往后，你再也不用担心了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vector_of_int_vectors</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>对，这确实是个小东西，不过却是人工代码克服机器工具的胜利。另外，这样写就不那么丑了。</p>

<h4>多线程</h4>

<p>这是第一次，C++11将包含一种内存模型和对应的多线程库，这意味着你将可以编写符合标准的多线程代码。新标准将提供所有的通用线程方法，比如线程、线程局部存储和原子操作。它也提供了一系列有趣的特性：futures和promises。futures和promises的主要思想是，你可以编写代码表示，“这个对象，一个future代码还没计算完的结果&#8221;，它将可以在后台计算结果。当这个值需要的时候，你向future发请求，假如这个值准备好了，那就可以得到它，要不然继续等待。</p>

<p>我将在后续的文章中深入探讨多线程。</p>

<h4>还有好多其他的东西</h4>

<p>C++11特性的数量是客观的。你可以阅读维基百科里的<a href="http://en.wikipedia.org/wiki/C%2B%2B0x">C++11</a>页面，而我计划在这一系列文章中深入探索这些特性，包括：</p>

<ul>
<li><a href="http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></li>
<li><a href="http://towriting.com/blog/2013/08/11/lambda-closures/">Lambda表达式</a></li>
<li><a href="http://towriting.com/blog/2013/08/20/ranged-for-loop/">区间迭代</a></li>
<li>静态表达式</li>
<li>右值引用和移动语义</li>
<li>nullptr和强类型的枚举</li>
</ul>


<h3>C++11的编译器支持</h3>

<p>当然，如果无法使用再好的语言特性又有什么用，好消息是大量的编译器已经开始支持C++11。Apache基金会整理了一个列表，列出了C++11的语言特性和编译器的支持情况：<a href="http://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport">支持C++11的编译器</a>。假如你对GCC感兴趣，这里有<a href="http://gcc.gnu.org/gcc-4.7/cxx0x_status.html">GCC4.7支持C++11</a>。</p>

<p>有些编译器，比如GCC，不会默认支持这些新特性&mdash;例如，为了支持C++11特性，编译时必须指定 -std=c++0x。当然这也是很有用的，你可以在你的项目中选择编译器和语言集。</p>

<p>下一篇：<a href="http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></p>

<p>译者：<a href="http://towriting.com/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/what-is-c++0x.html">What is C++0x? &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降权启动进程]]></title>
    <link href="http://towriting.com/blog/2013/07/31/de-elevate-start-process/"/>
    <updated>2013-07-31T22:01:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/31/de-elevate-start-process</id>
    <content type="html"><![CDATA[<p>Win7下有些进程需要以管理员权限启动，比如安装程序。但又需要这个具有管理员权限的进程启动一个非管理员权限的进程。要实现这一点，方法很简单，首先得到受限的Token，然后由这个Token调用<a href="http://msdn.microsoft.com/en-us/library/ms682429.aspx">CreateProcessAsUser</a>。</p>

<figure class='code'><figcaption><span>代码：WIN7/VS2010 (de_elevate_start_process.cpp)</span> <a href='http://towriting.com/downloads/code/cpp/de_elevate_start_process.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &quot;stdafx.h&quot;</span>
</span><span class='line'><span class="cp">#include &lt;Windows.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;UserEnv.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;WinBase.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;WinSafer.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma comment(lib, &quot;Userenv.lib&quot;)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取不含管理员权限的Token</span>
</span><span class='line'><span class="n">HANDLE</span> <span class="n">CreateNormalUserToken</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">SAFER_LEVEL_HANDLE</span> <span class="n">hLevel</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SaferCreateLevel</span><span class="p">(</span><span class="n">SAFER_SCOPEID_USER</span><span class="p">,</span> <span class="n">SAFER_LEVELID_NORMALUSER</span><span class="p">,</span> <span class="n">SAFER_LEVEL_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hLevel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">HANDLE</span> <span class="n">hRestrictedToken</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SaferComputeTokenFromLevel</span><span class="p">(</span><span class="n">hLevel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hRestrictedToken</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">hRestrictedToken</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">SaferCloseLevel</span><span class="p">(</span><span class="n">hLevel</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">hRestrictedToken</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 从管理员进程，创建非管理员进程</span>
</span><span class='line'><span class="n">BOOL</span> <span class="n">DeElevateStartProcess</span><span class="p">(</span><span class="n">TCHAR</span><span class="o">*</span> <span class="n">cmd</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">HANDLE</span> <span class="n">hRestToken</span> <span class="o">=</span> <span class="n">CreateNormalUserToken</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">hRestToken</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">DWORD</span> <span class="n">dwCreationFlags</span> <span class="o">=</span> <span class="n">NORMAL_PRIORITY_CLASS</span> <span class="o">|</span> <span class="n">CREATE_NEW_CONSOLE</span><span class="p">;</span>
</span><span class='line'>  <span class="n">LPVOID</span> <span class="n">pEnv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">CreateEnvironmentBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pEnv</span><span class="p">,</span> <span class="n">hRestToken</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">dwCreationFlags</span> <span class="o">|=</span> <span class="n">CREATE_UNICODE_ENVIRONMENT</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">pEnv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">;</span>
</span><span class='line'>  <span class="n">STARTUPINFO</span> <span class="n">si</span><span class="p">;</span>    
</span><span class='line'>  <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFO</span><span class="p">));</span>
</span><span class='line'>  <span class="n">si</span><span class="p">.</span><span class="n">cb</span><span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFO</span><span class="p">);</span>
</span><span class='line'>  <span class="n">si</span><span class="p">.</span><span class="n">lpDesktop</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;winsta0</span><span class="se">\\</span><span class="s">default&quot;</span><span class="p">);</span> <span class="c1">//default input desktop for the interactive window station</span>
</span><span class='line'>  <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pi</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">const</span> <span class="n">BOOL</span> <span class="n">bResult</span> <span class="o">=</span> <span class="n">CreateProcessAsUser</span><span class="p">(</span><span class="n">hRestToken</span><span class="p">,</span>    <span class="c1">// client&#39;s access token</span>
</span><span class='line'>                      <span class="nb">NULL</span><span class="p">,</span>                   <span class="c1">// file to execute</span>
</span><span class='line'>                      <span class="n">cmd</span><span class="p">,</span>      <span class="c1">// command line</span>
</span><span class='line'>                      <span class="nb">NULL</span><span class="p">,</span>                   <span class="c1">// pointer to process SECURITY_ATTRIBUTES</span>
</span><span class='line'>                      <span class="nb">NULL</span><span class="p">,</span>                   <span class="c1">// pointer to thread SECURITY_ATTRIBUTES</span>
</span><span class='line'>                      <span class="n">FALSE</span><span class="p">,</span>                  <span class="c1">// handles are not inheritable</span>
</span><span class='line'>                      <span class="n">dwCreationFlags</span><span class="p">,</span>        <span class="c1">// creation flags</span>
</span><span class='line'>                      <span class="n">pEnv</span><span class="p">,</span>                   <span class="c1">// pointer to new environment block</span>
</span><span class='line'>                      <span class="nb">NULL</span><span class="p">,</span>                   <span class="c1">// name of current directory</span>
</span><span class='line'>                      <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span>                    <span class="c1">// pointer to STARTUPINFO structure</span>
</span><span class='line'>                      <span class="o">&amp;</span><span class="n">pi</span>                     <span class="c1">// receives information about new process</span>
</span><span class='line'>                      <span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">bResult</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">CloseHandle</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">);</span>
</span><span class='line'>      <span class="n">CloseHandle</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hThread</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">pEnv</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">DestroyEnvironmentBlock</span><span class="p">(</span><span class="n">pEnv</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hRestToken</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">bResult</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">TCHAR</span> <span class="n">cmd</span><span class="p">[]</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;notepad.exe&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">DeElevateStartProcess</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>需要创建出的进程支持拖拽的看这里：<a href="http://towriting.com/blog/2013/08/06/process-can-drag-drop/">创建支持拖拽的进程</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[获取进程打开的互斥量]]></title>
    <link href="http://towriting.com/blog/2013/07/25/mutexs-owned-by-process/"/>
    <updated>2013-07-25T21:36:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/25/mutexs-owned-by-process</id>
    <content type="html"><![CDATA[<p>最近有个任务涉及到区分【同进程名进程】，所以想到了用进程&#8221;拥有&#8221;的互斥量来区分这些进程。所以下面实现了获取指定进程&#8221;拥有&#8221;哪些互斥量的方法，当然这种方法也适合各种内核对象（FILE、REG&hellip;)。</p>

<pre><code>1. 使用NtQuerySystemInformation检索SystemHandleInformation(16)即可获得系统中所有的句柄信息：
</code></pre>

<p>通过SystemHandleInformation检索到的系统中所有句柄的数据结构是这样定义的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SYSTEM_HANDLE_INFORMATION</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HandleCount</span><span class="p">;</span>
</span><span class='line'>  <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span> <span class="n">Handles</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span> <span class="n">SYSTEM_HANDLE_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">PSYSTEM_HANDLE_INFORMATION</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中SYSTEM_HANDLE_TABLE_ENTRY_INFO是一个句柄信息的数据结构</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SYSTEM_HANDLE_TABLE_ENTRY_INFO</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">ProcessId</span><span class="p">;</span>
</span><span class='line'>  <span class="n">BYTE</span> <span class="n">ObjectTypeNumber</span><span class="p">;</span>
</span><span class='line'>  <span class="n">BYTE</span> <span class="n">Flags</span><span class="p">;</span>
</span><span class='line'>  <span class="n">USHORT</span> <span class="n">Handle</span><span class="p">;</span>
</span><span class='line'>  <span class="n">PVOID</span> <span class="n">Object</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ACCESS_MASK</span> <span class="n">GrantedAccess</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="p">,</span> <span class="o">*</span><span class="n">PSYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>2. 将句柄复制到当前进程
</code></pre>

<p>想要获取一个句柄的详细信息，必须将其拷贝到当前进程，对于一个句柄数据类型：SYSTEM_HANDLE_TABLE_ENTRY_INFO，我们可以使用其第四个成员Handle，然后使用DuplicateHandle将这个句柄复制到当前进程。</p>

<pre><code>3. 获取句柄的类型信息
</code></pre>

<p>由2中获取的复制到当前进程的句柄，调用函数NtQueryObject，指定获取ObjectNameInformation(1)即可获取句柄的类型信息，获取到的句柄的类型信息结构是这样的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_OBJECT_TYPE_INFORMATION</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">UNICODE_STRING</span> <span class="n">TypeName</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalNumberOfObjects</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalNumberOfHandles</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalNonPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalNamePoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalHandleTableUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterNumberOfObjects</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterNumberOfHandles</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterNonPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterNamePoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterHandleTableUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">InvalidAttributes</span><span class="p">;</span>
</span><span class='line'>  <span class="n">GENERIC_MAPPING</span> <span class="n">GenericMapping</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">ValidAccessMask</span><span class="p">;</span>
</span><span class='line'>  <span class="n">BOOLEAN</span> <span class="n">SecurityRequired</span><span class="p">;</span>
</span><span class='line'>  <span class="n">BOOLEAN</span> <span class="n">MaintainHandleCount</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">PoolType</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">DefaultPagedPoolCharge</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">DefaultNonPagedPoolCharge</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">OBJECT_TYPE_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">POBJECT_TYPE_INFORMATION</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中第一个成员TypeName即是句柄类型的类型名</p>

<!--more-->


<pre><code>4. 获取句柄的名字
</code></pre>

<p>调用函数NtQueryObject，指定获取ObjectNameInformation即可获取句柄的类型信息，获取到的句柄的名字数据结构是UNICODE_STRING类型。</p>

<pre><code>5. 找到当前进程占有的互斥量
</code></pre>

<p>由获取的句柄的类型信息和句柄所在的进程ID，即可找到当前进程拥有的互斥量，同时我们也得到了互斥量的名字。</p>

<h3>完整代码如下：</h3>

<figure class='code'><figcaption><span>代码：WIN7/VS2010 (get_process_mutex.cpp)</span> <a href='http://towriting.com/downloads/code/cpp/get_process_mutex.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &quot;stdafx.h&quot;</span>
</span><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'><span class="cp">#include &lt;Windows.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;winternl.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;ntstatus.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// NtQueryObject枚举出的内核对象的类型信息的结构</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_OBJECT_TYPE_INFORMATION</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">UNICODE_STRING</span> <span class="n">TypeName</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalNumberOfObjects</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalNumberOfHandles</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalNonPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalNamePoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">TotalHandleTableUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterNumberOfObjects</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterNumberOfHandles</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterNonPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterNamePoolUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">HighWaterHandleTableUsage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">InvalidAttributes</span><span class="p">;</span>
</span><span class='line'>  <span class="n">GENERIC_MAPPING</span> <span class="n">GenericMapping</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">ValidAccessMask</span><span class="p">;</span>
</span><span class='line'>  <span class="n">BOOLEAN</span> <span class="n">SecurityRequired</span><span class="p">;</span>
</span><span class='line'>  <span class="n">BOOLEAN</span> <span class="n">MaintainHandleCount</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">PoolType</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">DefaultPagedPoolCharge</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">DefaultNonPagedPoolCharge</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">OBJECT_TYPE_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">POBJECT_TYPE_INFORMATION</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 一个句柄信息的数据结构</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SYSTEM_HANDLE_TABLE_ENTRY_INFO</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">ULONG</span> <span class="n">ProcessId</span><span class="p">;</span>
</span><span class='line'>  <span class="n">BYTE</span> <span class="n">ObjectTypeNumber</span><span class="p">;</span>
</span><span class='line'>  <span class="n">BYTE</span> <span class="n">Flags</span><span class="p">;</span>
</span><span class='line'>  <span class="n">USHORT</span> <span class="n">Handle</span><span class="p">;</span>
</span><span class='line'>  <span class="n">PVOID</span> <span class="n">Object</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ACCESS_MASK</span> <span class="n">GrantedAccess</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="p">,</span> <span class="o">*</span><span class="n">PSYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取一个句柄的详细信息</span>
</span><span class='line'><span class="c1">// 可以获取类型名和内核对象的名字</span>
</span><span class='line'><span class="c1">// bType - 获取句柄的类型名</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">QueryHandleNameInfo</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">handle</span><span class="p">,</span> <span class="n">BOOL</span> <span class="n">bType</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strName</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">HMODULE</span> <span class="n">hDll</span> <span class="o">=</span> <span class="n">LoadLibrary</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;ntdll.dll&quot;</span><span class="p">));</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">hDll</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">strName</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">NTSTATUS</span> <span class="p">(</span><span class="n">NTAPI</span> <span class="o">*</span><span class="n">NtQueryObjectFunc</span><span class="p">)(</span><span class="n">HANDLE</span><span class="p">,</span> <span class="n">OBJECT_INFORMATION_CLASS</span><span class="p">,</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">ULONG</span><span class="p">,</span> <span class="n">PULONG</span><span class="p">);</span>
</span><span class='line'>  <span class="n">NtQueryObjectFunc</span> <span class="n">NtQueryObject_</span> <span class="o">=</span> <span class="p">(</span><span class="n">NtQueryObjectFunc</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hDll</span><span class="p">,</span> <span class="s">&quot;NtQueryObject&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">do</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">NtQueryObject_</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="c1">// 获取信息</span>
</span><span class='line'>      <span class="k">const</span> <span class="n">DWORD</span> <span class="n">ObjectNameInformation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="n">OBJECT_INFORMATION_CLASS</span> <span class="n">infoType</span> <span class="o">=</span> <span class="n">bType</span> <span class="o">?</span> <span class="n">ObjectTypeInformation</span> <span class="o">:</span> <span class="n">OBJECT_INFORMATION_CLASS</span><span class="p">(</span><span class="n">ObjectNameInformation</span><span class="p">);</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BYTE</span><span class="o">&gt;</span> <span class="n">objVec</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
</span><span class='line'>      <span class="n">ULONG</span> <span class="n">bytesOfRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span><span class='line'>      <span class="n">NTSTATUS</span> <span class="n">status</span> <span class="o">=</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span>
</span><span class='line'>      <span class="k">do</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">status</span> <span class="o">=</span> <span class="n">NtQueryObject_</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">infoType</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">objVec</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">objVec</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">bytesOfRead</span><span class="p">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">STATUS_INFO_LENGTH_MISMATCH</span> <span class="o">==</span> <span class="n">status</span><span class="p">)</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="n">objVec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">objVec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>              <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">objVec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">bytesOfRead</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">bType</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="k">const</span> <span class="n">OBJECT_TYPE_INFORMATION</span> <span class="o">*</span><span class="n">pObjType</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">OBJECT_TYPE_INFORMATION</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">objVec</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span><span class='line'>          <span class="n">strName</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="p">(</span><span class="n">pObjType</span><span class="o">-&gt;</span><span class="n">TypeName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">pObjType</span><span class="o">-&gt;</span><span class="n">TypeName</span><span class="p">.</span><span class="n">Length</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">));</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="k">const</span> <span class="n">UNICODE_STRING</span> <span class="o">*</span><span class="n">pObjName</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">UNICODE_STRING</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">objVec</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span><span class='line'>          <span class="n">strName</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="p">(</span><span class="n">pObjName</span><span class="o">-&gt;</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">pObjName</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">));</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">FreeLibrary</span><span class="p">(</span><span class="n">hDll</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">strName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 遍历句柄辅助类</span>
</span><span class='line'><span class="k">class</span> <span class="nc">WalkHandleHelper</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">WalkHandleHelper</span><span class="p">(</span><span class="k">const</span> <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="o">&amp;</span> <span class="n">handleInfo</span><span class="p">,</span> <span class="k">const</span> <span class="n">HANDLE</span><span class="o">&amp;</span> <span class="n">handle</span><span class="p">)</span><span class="o">:</span><span class="n">m_HandleInfo</span><span class="p">(</span><span class="n">handleInfo</span><span class="p">),</span> <span class="n">m_Handle</span><span class="p">(</span><span class="n">handle</span><span class="p">){}</span>
</span><span class='line'>  <span class="n">DWORD</span> <span class="n">GetProcessID</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">m_HandleInfo</span><span class="p">.</span><span class="n">ProcessId</span><span class="p">;}</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">GetTypeName</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">QueryHandleNameInfo</span><span class="p">(</span><span class="n">m_Handle</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">GetObjectName</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">QueryHandleNameInfo</span><span class="p">(</span><span class="n">m_Handle</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="o">&amp;</span> <span class="n">m_HandleInfo</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">HANDLE</span><span class="o">&amp;</span> <span class="n">m_Handle</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 枚举系统的句柄</span>
</span><span class='line'><span class="kt">void</span> <span class="n">WalkHandle</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">WalkHandleHelper</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">functor</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">HMODULE</span> <span class="n">hDll</span> <span class="o">=</span> <span class="n">LoadLibrary</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;ntdll.dll&quot;</span><span class="p">));</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">hDll</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 使用NtQuerySystemInformation检索SystemHandleInformation(16)即可获得系统中所有的句柄信息</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">DWORD</span> <span class="n">SystemHandleInformation</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>        
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 通过SystemHandleInformation检索到的系统中所有句柄的数据结构</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SYSTEM_HANDLE_INFORMATION</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">ULONG</span> <span class="n">HandleCount</span><span class="p">;</span>
</span><span class='line'>      <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span> <span class="n">Handles</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">SYSTEM_HANDLE_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">PSYSTEM_HANDLE_INFORMATION</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">NTSTATUS</span> <span class="p">(</span><span class="n">NTAPI</span> <span class="o">*</span><span class="n">NtQuerySystemInformationFunc</span><span class="p">)(</span><span class="n">ULONG</span><span class="p">,</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">ULONG</span><span class="p">,</span> <span class="n">PULONG</span><span class="p">);</span>
</span><span class='line'>  <span class="n">NtQuerySystemInformationFunc</span> <span class="n">NtQuerySystemInformation_</span> <span class="o">=</span> <span class="p">(</span><span class="n">NtQuerySystemInformationFunc</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hDll</span><span class="p">,</span> <span class="s">&quot;NtQuerySystemInformation&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">HANDLE</span> <span class="n">hCurProcess</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
</span><span class='line'>  <span class="k">do</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">NtQuerySystemInformation_</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="c1">// 获取系统句柄表</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BYTE</span><span class="o">&gt;</span> <span class="n">vecData</span><span class="p">(</span><span class="mi">512</span><span class="p">);</span>
</span><span class='line'>      <span class="n">ULONG</span> <span class="n">bytesOfRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>      <span class="n">NTSTATUS</span> <span class="n">status</span><span class="p">;</span>
</span><span class='line'>      <span class="k">do</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">status</span> <span class="o">=</span> <span class="n">NtQuerySystemInformation_</span><span class="p">(</span><span class="n">SystemHandleInformation</span><span class="p">,</span> <span class="n">vecData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">vecData</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">bytesOfRead</span><span class="p">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">STATUS_INFO_LENGTH_MISMATCH</span> <span class="o">==</span> <span class="n">status</span><span class="p">)</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="n">vecData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">vecData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>              <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">vecData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">bytesOfRead</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">PSYSTEM_HANDLE_INFORMATION</span> <span class="n">pSysHandleInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSYSTEM_HANDLE_INFORMATION</span><span class="p">)</span><span class="n">vecData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">pSysHandleInfo</span><span class="o">-&gt;</span><span class="n">HandleCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="k">const</span> <span class="n">HANDLE</span> <span class="n">hOwnProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_DUP_HANDLE</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">pSysHandleInfo</span><span class="o">-&gt;</span><span class="n">Handles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ProcessId</span><span class="p">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">hOwnProcess</span><span class="p">)</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="n">HANDLE</span> <span class="n">hDuplicate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>          <span class="c1">// 必须把Handle放入自己的进程中，否则无法获取其他进程拥有Handle的信息</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DuplicateHandle</span><span class="p">(</span><span class="n">hOwnProcess</span><span class="p">,</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">pSysHandleInfo</span><span class="o">-&gt;</span><span class="n">Handles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Handle</span><span class="p">,</span> <span class="n">hCurProcess</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hDuplicate</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">DUPLICATE_SAME_ACCESS</span><span class="p">))</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hOwnProcess</span><span class="p">);</span>
</span><span class='line'>              <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="n">WalkHandleHelper</span> <span class="n">helper</span><span class="p">(</span><span class="n">pSysHandleInfo</span><span class="o">-&gt;</span><span class="n">Handles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hDuplicate</span><span class="p">);</span>
</span><span class='line'>          <span class="n">functor</span><span class="p">(</span><span class="n">helper</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>          <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDuplicate</span><span class="p">);</span>
</span><span class='line'>          <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hOwnProcess</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">FreeLibrary</span><span class="p">(</span><span class="n">hDll</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 枚举当前进程的互斥量</span>
</span><span class='line'><span class="kt">void</span> <span class="n">EnumCurProcessMutex</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">wcout</span><span class="o">&lt;&lt;</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;Find The Mutex Opened By Current Process:&quot;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">DWORD</span> <span class="n">dwCurProcess</span> <span class="o">=</span> <span class="n">GetCurrentProcessId</span><span class="p">();</span>
</span><span class='line'>  <span class="n">WalkHandle</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">WalkHandleHelper</span><span class="o">&amp;</span> <span class="n">helper</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strMutant</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;Mutant&quot;</span><span class="p">));</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">helper</span><span class="p">.</span><span class="n">GetProcessID</span><span class="p">()</span> <span class="o">==</span> <span class="n">dwCurProcess</span> <span class="o">&amp;&amp;</span> <span class="n">helper</span><span class="p">.</span><span class="n">GetTypeName</span><span class="p">().</span><span class="n">compare</span><span class="p">(</span><span class="n">strMutant</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>            
</span><span class='line'>          <span class="n">std</span><span class="o">::</span><span class="n">wcout</span><span class="o">&lt;&lt;</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;ObjectName: &quot;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">helper</span><span class="p">.</span><span class="n">GetObjectName</span><span class="p">().</span><span class="n">c_str</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CreateMutex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CreateMutex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;TestMutex&quot;</span><span class="p">));</span>
</span><span class='line'>  <span class="n">CreateMutex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;Global</span><span class="se">\\</span><span class="s">TestGlobalMutex&quot;</span><span class="p">));</span>
</span><span class='line'>  <span class="n">EnumCurProcessMutex</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smart GetProcAddress之实现]]></title>
    <link href="http://towriting.com/blog/2013/07/20/smart-getprocaddress/"/>
    <updated>2013-07-20T22:36:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/20/smart-getprocaddress</id>
    <content type="html"><![CDATA[<p>Windows下有过编程经验的朋友肯定用过这个函数：<a href="http://msdn.microsoft.com/en-us/library/ms683212%28v=vs.85%29.aspx">GetProcAddress</a>，作用呢，就是从加载的动态库中获取指定函数名的函数入口地址，函数使用方法简单，一般是如下流程：</p>

<figure class='code'><figcaption><span>DLL导出函数的头文件:dll.h</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">WINAPI</span> <span class="n">func1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">WINAPI</span> <span class="n">func2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>动态加载DLL调用上面两个函数</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">FUNC1</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">FUNC2</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="n">FUNC1</span> <span class="n">func1</span> <span class="o">=</span> <span class="p">(</span><span class="n">FUNC1</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hDLL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;func1&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">FUNC2</span> <span class="n">func2</span> <span class="o">=</span> <span class="p">(</span><span class="n">FUNC2</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hDLL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;func2&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">func1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">func2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上是主流的代码写法，但其实稍有问题：
1. 要定义一套函数类型，且违反DRY，枯燥乏味，影响代码美观
2. 隐式类型转换是魔鬼，如果DLL实现变化，则调用出错，比如：</p>

<figure class='code'><figcaption><span>DLL导出函数的头文件：fun2的参数变成了三个，调用非出错不可</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">WINAPI</span> <span class="n">func1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">WINAPI</span> <span class="n">func2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>好，问题来了，如何避免：</p>

<figure class='code'><figcaption><span>方案1：使用模板</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// 封装一个智能GetProcAddress</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">T</span> <span class="n">SmartGetProcAddress</span><span class="p">(</span><span class="n">HModule</span> <span class="n">hModule</span><span class="p">,</span> <span class="n">TChar</span><span class="o">*</span> <span class="n">pFuncName</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hModule</span><span class="p">,</span> <span class="n">pFuncName</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用方法如下：注意1. 要引用对应头文件，2. auto（自动类型推导）关键字从VS2010开始支持</span>
</span><span class='line'><span class="k">auto</span> <span class="n">func1</span> <span class="o">=</span> <span class="n">SmartGetProcAddress</span><span class="p">(</span><span class="n">hDLL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;func1&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">func1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来我们解决了DRY问题，也不用写繁琐的typedef了，于是我们开始Build，很快你就发现Link错误，unresolved external symbol，没注意取地址&amp;func1，已静态依赖于DLL，看来此路不通。取地址的目的是从头文件中获取函数的类型，还有什么方法可以获取函数的类型呢？</p>

<figure class='code'><figcaption><span>方案2：使用decltype</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// 封装一个智能GetProcAddress</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">T</span> <span class="n">SmartGetProcAddress</span><span class="p">(</span><span class="n">HModule</span> <span class="n">hModule</span><span class="p">,</span> <span class="n">TChar</span><span class="o">*</span> <span class="n">pFuncName</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hModule</span><span class="p">,</span> <span class="n">pFuncName</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用方法如下：</span>
</span><span class='line'><span class="k">auto</span> <span class="n">func1</span> <span class="o">=</span> <span class="n">SmartGetProcAddress</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">func1</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hDLL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;func1&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用decltype可以解决，函数取地址（&amp;)会静态依赖DLL问题，这里的关键是decltype(func1)这种写法的支持，最初这种写法在g++4.7测试是支持的，不过后来再VS2012、VS2010上测试好像都不支持，所以SmartGetProcAddress只能存在于理论阶段了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我曾读过的那些书]]></title>
    <link href="http://towriting.com/blog/2013/07/20/the-books-i-have-read/"/>
    <updated>2013-07-20T08:13:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/20/the-books-i-have-read</id>
    <content type="html"><![CDATA[<p>在我心中读书一直是一件很酷的事情：束发读诗书，修德兼修身，仰观与俯查，韬略胸中存。在此记录下自己曾读过的书们。</p>

<blockquote><p>大学以前读的书：这个时期距今较久，房屋翻新书籍都已轶失，当时亦没有记录下来读书清单，所以只能模糊的回忆了：</p></blockquote>

<ol>
<li><p>书名：各种启蒙读物  作者：百家 阅读时间：启蒙时至小学毕业</p>

<p> 此时读过的非课本书主要是一些启蒙读物、幼儿读物、作文书。能说的上名字的只有有：《小学生必读》系列杂志、《舒克和贝塔》、《旁中华书法》，《格林童话》，《上下五千年》，《成语故事》。这个时期好像没有主动买过书，父母偶尔会买一些绘画、作文书，故事书也很少买。自己读书的主要来源是班上的同学带来的课外书，和哥哥的教材。哥哥比我大四岁，他那些语文书我总是看的津津有味，一遍又一遍。</p></li>
<li><p>白马笑西风</p></li>
<li>鹿鼎记</li>
<li>碧血剑</li>
<li>雪山飞狐</li>
<li>鸳鸯刀</li>
<li>物理演义</li>
<li>化学演义</li>
<li>东周列国志</li>
<li>情人剑</li>
<li>方与圆 高二</li>
<li>平凡的世界 高二</li>
<li>胡雪岩</li>
<li>红与黑</li>
<li>平凡的世界</li>
<li>红楼梦</li>
<li>战争与和平</li>
<li>学习的革命</li>
<li>鲁迅文集</li>
<li>余秋雨文集</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开始写博客]]></title>
    <link href="http://towriting.com/blog/2013/07/17/begin-writing-blog/"/>
    <updated>2013-07-17T22:04:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/17/begin-writing-blog</id>
    <content type="html"><![CDATA[<h3>离职的意外收获</h3>

<p>今年离职有一个意外收获，合适的工作很难找，找工作的空白期间，买了个域名（towriting)，开了这个个人博客，自此可以在这里记录自己的成长，乃至老去。</p>

<h3>写博客的好处</h3>

<p>这个好处是显而易见，人所共知的，刘未鹏很早以前就提出了一个技术人员应该写博客，书写是为了更好的思考，可以使知识融汇贯通。除了这些，世俗的讲，博客可以是姜太公钓鱼的勾，好的博客可以大大增加简历的含金量，吸引各种Headhunting；恶俗的讲，博客更可以引入Google Ads等，成为一项收入来源。</p>

<h3>我为什么必须要写博客</h3>

<ul>
<li>自己生于农村，较之同侪启蒙早，当时农村文娱匮乏，酷喜读书，聊以消遣。16岁左右，正值高中，甚喜作文，高二以前，还能写有生命的作文，语言与文字能力倍受老师同学钦佩，自己竟曾立志成为中国最后一个释、儒、道集大成者。高三读《石头记》，且其它科目压力骤大，遂由《芙蓉女儿诔》推导出适应各种命题的万能作文模板，自此文章徒具形式。虽旧梦难圆，但做程序员久矣，口齿含糊，木讷呆滞，想借写博客，防止自己失语与老年痴呆。</li>
<li>从业三年来，读书不辍，遇问题好奇追根，所以技术进步较大。因识人不多，所以自视C++水平处周围大部分人之上。然半路出家，技术似空中楼阁，学习已经进入瓶颈期。技能进步的目标模糊，但写博客无疑是朝目标走的，瓶颈期只能先如此了，同时梳理一下三年来的收获。</li>
<li>记录下自己活着的证据。</li>
</ul>


<h3>给自己的要求</h3>

<ul>
<li>内容必需保证原创或翻译</li>
<li>能保证每周一篇文章</li>
<li>不能因为上一条的要求而使内容敷衍</li>
</ul>

]]></content>
  </entry>
  
</feed>
