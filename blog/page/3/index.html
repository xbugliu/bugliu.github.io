
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>书写|记下人生痕迹</title>
  <meta name="author" content="ToWriting">

          
        <meta name="description" content="记录人生痕迹|分享技术心得 -- ToWriting.com. 一个立志独立思维的程序员的博客网站. 这里会记录下自己工作, 生活和回忆; 同时会分享编程等相关技术知识; 所有文章皆为原创或翻译.">
        <meta name="keywords" content="阅读,思考,书写,程序员,C++">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://towriting.com/blog/page/3">
  <link href="/favicon.ico" rel="icon">

  <link href="/assets/bootstrap/css/spacelab.min.css" rel="stylesheet" type="text/css">
  <link href="/assets/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css">
  <link href="/assets/bootstrap/css/custom.css" rel="stylesheet" type="text/css">
  <link href="/assets/font-awesome/css/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="/stylesheets/screen.css" rel="stylesheet" type="text/css">
  <link href="/stylesheets/github.css" rel="stylesheet" type="text/css">
  
  <link href="/atom.xml" rel="alternate" title="书写|记下人生痕迹" type="application/atom+xml">
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42601840-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="no-sidebar"   data-spy="scroll">

  <div class="container">
    <header class="jumbotron subhead" id="overview">
      
<div class="subscribe">
  <table>
    <tr>
      <td><span>订阅: &nbsp;</span></td>
      
      
      <td><a href="/atom.xml" class="btn"><i class="icon-cog"></i> By RSS</a></td>
      
      
    </tr>
  </table>
</div>

<h1 class="title">ToWriting</h1>


      <div class="navbar">
  <div class="navbar-inner">
    <div class="container" style="width: auto;">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <div class="nav-collapse">
                <ul class="nav">
          <li><a href="/">Home</a></li>
          <li><a href="/blog/archives">Archives</a></li>
          <li><a href="/about">About</a></li>
        </ul>

        
          <form action="http://google.com/search" method="get" class="navbar-search pull-left">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:towriting.com" />
              <input type="text" name="q" results="0" placeholder="Search" class="search-query span2" />
            </fieldset>
          </form>
        
        
      </div><!-- /.nav-collapse -->
    </div>
  </div><!-- /navbar-inner -->
</div>

    </header>
    <div id="main">
      <div id="content">
        
<div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/11/read-notes-of-the-black-swan/">《黑天鹅—如何应对不可知的未来》读书笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-11T23:57:00+08:00" pubdate data-updated="true">2013-12-11</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.amazon.cn/gp/product/B005U9CO3W/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005U9CO3W&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="" target="_blank">《黑天鹅—如何应对不可知的未来》</a>上册的阅读笔记：</p>

<ul>
<li>我们通过观察或经验获得的知识具有严重的局限性和脆弱性</li>
<li>为什么读报实际上降低了你对世界的认识呢</li>
<li>黑天鹅的逻辑是，你不知道的事比你知道的事更有意义，因为许多黑天鹅事件正是由于它们不被预期而发生和加剧的</li>
<li>看到一件事情发生正是因为人们认为它不应该发生，这是不是很奇怪？</li>
<li>尽管他们有经验和数据，但他们并不比普通大众更了解相关问题，只是更善于阐述而已，甚至只是更善于用复杂的数学模型把你弄晕而已</li>
<li>我们不学习规律，而是学习事实</li>
<li>正常的东西经常是不重要的</li>
<li>任何寻求证实的人都能够找到足够的证据来欺骗自己，以及他身边的人</li>
<li>即使我们取得了知识上的进步和成长，或者正因为这种进步和成长，未来仍会越来越不可预测</li>
<li>仅仅在装扮上公然反叛是一回事—社会科学家和经济学家称之为“廉价的标签”</li>
<li>历史是模糊的。你看到了结果，但看不到导致历史事件发生的幕后原因</li>
<li><strong>在预测上，非常聪明和掌握大量信息的人并不比出租车司机更有优势</strong></li>
<li>避免信息毒害的好处</li>
<li>每当我把时间不是花在研究，而是花在追求物质财富上时，它都让我感到羞愧</li>
<li>业余作家为自己写作，专业作家为他人写作</li>
<li>如果你是一名脑力劳动者，你不必工作太卖力，只需要多想。你的产出为 100和 1000 时，你做的工作是一样的</li>
<li><strong>收入具有突破性的职业只有在你成功的时候对你是好的</strong></li>
<li>而今天，少数人夺走几乎一切，剩下的人几乎什么也得不到。</li>
<li>设计一双鞋比真正把它们做出来赚钱得多</li>
<li>当你的样本量足够大时，任何个例都不会对整体产生重大影响</li>
<li>几乎所有社会问题都来自极端斯坦</li>
<li>只花 100 美元就让别人有快乐一天的感觉非常令人飘飘然</li>
<li>火鸡问题可以把“<strong>喂你的那只手也可能是拧断你脖子的那只手</strong>”的情况一般化</li>
<li>从火鸡的角度，第 1001 天没有喂食是黑天鹅事件，从屠宰者的角度却不是，因为这不是意料之外的</li>
<li>正面的黑天鹅事件需要时间来显现它们的影响，而负面的黑天鹅事件发生得非常迅速—毁灭比缔造要容易和迅速得多</li>
<li>现代世界是极端斯坦，被不经常发生及非常不经常发生的事件左右</li>
<li>我们习惯过度解释，偏好简洁的故事，而不是原始真相</li>
<li>叙述谬误指的是我们无法在不编造理由或者强加一种逻辑关系的情况下观察一系列事实。对事实的解释会与事实混在一起，使事实变得更容易被记住</li>
<li>文字或符号表述得越有条理，越不具随机性，越符合一定模式，这种表述就越容易在大脑中储存或者写在一本书里，好让你的后人在某一天读到。</li>
<li>压缩对意识的正常工作至关重要</li>
<li>信息越具有随机性，事物就越复杂，因而越难以概括</li>
<li>不要试图刻意不去想它—这几乎一定会带来反作用。更合适的解决办法是更多地看到事件不可避免的部分</li>
<li>人们提出一个原因，好让你接受一则新闻，同时让事情看上去更具体</li>
<li>有人负责核实事实，却没有人负责核实真理</li>
<li><strong>一个人的死亡是悲剧，100 万人的死亡只是统计学意义上的说法。</strong></li>
<li>因为我们的反应是不经过思考和反省的</li>
<li>我们对黑天鹅现象的误解大部分归因于我们对系统 1（叙述）以及情感（包括情绪）的运用</li>
<li><strong>没有新发现是非常有价值的，因为它是发现过程的一部分</strong></li>
<li>许多人在生活中忙忙碌碌，相信自己在做正确的事，但很长时间都无法拿出实实在在的成绩。他们需要一种不时获得满足感的能力，才能在不断受到周围人的残酷打击的情况下不失去勇气。</li>
<li>这些职业能够产生一种持续的自我满足感</li>
<li>风险投资人比创业家赚钱，出版商比作者赚钱，艺术经纪人比艺术家赚钱，科学比科学家成功（大约 50%的科学和学术论文或许花费了科学家几个月甚至几年的努力，却从来没有被人真正读过）。<strong>参与赌博的人获得了另一种非物质报酬：希望</strong>.</li>
<li><strong>假如你赚了 1000 万美元，然后损失了 900 万美元，这情形比根本没有赚钱还糟！</strong></li>
<li>学派使一个有着非凡思想而从中获益的希望很渺茫的人能够找到同伴</li>
<li>沉默的证据</li>
<li>自传的全部意义就在于武断地把某些品质与事件连成因果关系</li>
<li>这些行业产出了大量失败者：挨饿的演员比挨饿的会计师多，即使你假设他们的平均收入是一样的</li>
<li>没有必要为所有濒危物种感到道义上负有责任</li>
<li>这是一种沉默的犯罪</li>
<li>回想一下证实偏差：政府非常擅长告诉你他们做了什么，而不是他们没做什么</li>
<li>救活一个人只是统计数字，伤害一个人则是奇闻逸事</li>
<li>我们冒险通常不是出于自信，而是出于无知和对不确定性的无视</li>
<li>我的存在是低概率事件的重大结果，而我经常忘记这一点。</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/10/static-assert/">C++中的静态断言</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-10T00:02:00+08:00" pubdate data-updated="true">2013-12-10</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>什么是静态断言</h2>

<p>断言（Assert)是报告代码状态错误的技术手段。Windows下的C++开发肯定都知道ASSERT或ATLASSERT，这两个宏生成DEBUG版本下的断言，另外还有assert，是C/C++提供的断言函数，效果和以上两个宏是一样的。</p>

<p>那什么是静态断言？上面介绍的普通断言是运行时检测的，静态断言是编译期检测的，所以被称之为静态断言（static assert）。最早知道编译期检测是在Matthew wilson的<a href="http://www.amazon.cn/gp/product/B008A4Y2R0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008A4Y2R0&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="" target="_blank">《Imperfect C++》</a>中，里面称其为约束（constraints)，并抱怨C++为什么不支持如此常用的功能（C++11已有改善）。</p>

<p>那使用静态断言有什么好处呢？</p>

<h2>静态断言的好处</h2>

<ol>
<li>更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</li>
<li>无法忽略的错误，对于Assert类似DEBUG下的断言，有时候被不会被执行到，即使执行到也会遭到一些开发的忽视，而静态断言的错误是无法忽视的，因为构建失败了。</li>
<li>减少运行时开销，静态断言是编译期检测的，减少了运行时开销</li>
</ol>


<p>那如何使用实现静态断言？</p>

<h2>使用静态断言</h2>

<p>静态断言作用的对象一般是编译时已知的状态。任何可以成为模板类参数的内容都可以作为静态断言的对象。</p>

<p>下面看一个静态断言的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">D</span><span class="p">,</span><span class="k">typename</span> <span class="n">B</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">has_base</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>     <span class="o">~</span><span class="n">has_base</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)(</span><span class="n">D</span><span class="o">*</span><span class="p">,</span><span class="n">B</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">constraints</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">void</span> <span class="n">constraints</span><span class="p">(</span><span class="n">D</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span><span class="n">B</span> <span class="o">*</span><span class="n">pb</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="n">pb</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子最早出自Bjarne Stroustrup之手，用于检测一个类型是否是另一个类型的父类（类型相等和void*的情况没有考虑，用起来像这样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CBase</span> <span class="p">{};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">CDer</span><span class="o">:</span> <span class="k">public</span> <span class="n">CBase</span> <span class="p">{};</span>
</span><span class='line'><span class="n">has_base</span><span class="o">&lt;</span><span class="n">CDer</span><span class="p">,</span> <span class="n">CBase</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'><span class="n">has_base</span><span class="o">&lt;</span><span class="n">CBase</span><span class="p">,</span> <span class="n">CDer</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//编译错误</span>
</span></code></pre></td></tr></table></div></figure>


<p>它的工作原理是，成员函数constraints试图把D的指针转化成B的指针，这一般只在B是D的派生类时成立。而且constraints函数永远不会被调到，所以没有运行时开销。</p>

<p>在看一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">enum</span> <span class="n">personType</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">person_child</span><span class="p">,</span>
</span><span class='line'>    <span class="n">person_adult</span><span class="p">,</span>
</span><span class='line'>    <span class="n">person_woman</span><span class="p">,</span>
</span><span class='line'>    <span class="n">person_man</span><span class="p">,</span>
</span><span class='line'>    <span class="n">person_count</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">ProcessPersonType</span><span class="p">(</span><span class="n">personType</span> <span class="n">ptVal</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">dummy</span><span class="p">[</span><span class="n">person_count</span> <span class="o">&gt;</span> <span class="n">CHAR_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">cVal</span> <span class="o">=</span> <span class="n">ptVal</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// do something with cVal</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面例子里，试图将枚举类型的值转化成cVal,但可能有溢出的问题，所以设置一个静态断言：<code>char dummy[person_count &gt; UCHAR_MAX ? 1 : -1];</code>，原理是如果personType的最大值大于char类型的最大值，则表达式为<code>char dummy[-1]</code>，我们知道这是编译不过的，所以会提示我们出问题了。</p>

<p>以上方式虽然可以实现静态断言的效果，但提示的信息，可能和我们断言想要报告的完全无关，所以并不是最完美的解决方案。</p>

<h2>C++11中的静态断言</h2>

<p>C++11中增加了static_assert支持静态断言，用法相当简单，static_asset接受两个参数，第一个为要断言的内容，第二个为显示的错误提示。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Factorial</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="n">static_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;n must bigger than 1&quot;</span><span class="p">);</span>
</span><span class='line'> <span class="k">enum</span><span class="p">{</span> <span class="n">value</span><span class="o">=</span><span class="n">n</span> <span class="o">*</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="k">enum</span><span class="p">{</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面是计算阶乘的一个模板，我们使用static_assert检测n的值大于1，如果不满足则，编译错误，提示为：&#8221;n must bigger than 1&#8221;。</p>

<p>static_assert是编译器很容易实现的一个特性，一般的编译器最新版本应该都已支持。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/08/from-smog/">从杭州雾霾谈起</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-08T14:07:00+08:00" pubdate data-updated="true">2013-12-08</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>昨天，在简书上翻看了几篇文章，其中首页竟有两篇是谈论要每天写点东西的。其中有一个想法很好，是教人如何养成写东西的习惯的：每天抽出一刻钟以上的时间写点什么并坚持半个月，从此你可能就会有写东西的习惯。</p>

<p>道理很简单，知易行难，但自己还是想试一试，因为自己最初创建这个博客时，给自己定下了每周一篇文章的目标，到目前虽没有严格达标，但产出还是不少的，半年来也有30篇。这样一看，较往年比今年自己确实留下了一些东西，也有了一点成就感。</p>

<p>但这30篇文章中，技术相关的主要来自翻译，深感自己很难写出高质量、低雷同的原创技术文章，而如今要践行每日一篇的诺言，只能先从非技术写起了，从哪里开始呢？讲一讲近期热议的雾霾吧，终于扯上题目了。</p>

<p>前天做了一个梦，梦中自己游历到台湾，游玩之余不忘社会责任感，遂至一献血站献血，粗大的针头插入自己的臂膀，自己咬紧牙关挺下来，血抽完了。然而噩耗传来，护士失望的告诉我：“您的血液不合格”。我问她怎么回事，她没回答，而是劝我赶紧去医院进行专业检查。</p>

<p>梦至此，我恍然大悟，一定是极恶的病，所以我痛哭流涕，感觉自己人生完了，哭极梦醒，但胳膊还隐隐作痛，醒来回想，长舒一口气。</p>

<p>天明上班，与同事言及此事，感梦中潜意识中的生病来自上下班途中遭遇的雾霾。从12月起，每日晚归回家途中，路上皆蒙蒙的雾霾。前年还笑留在北京的同学，生活环境困厄，想不到自己生活的杭州竟亦至此。杭州从此和，“江南好，最忆是杭州&#8221;这种词句渐行渐远了。</p>

<p>想梦中自己的遭遇，很可能会是雾霾这种东西给我们这些生活在大城市的人下的慢性随机毒药，说不准若干年后谁会中招。尘肺此类职业病，患者还有责任人可寻，而一旦遭遇雾霾的荼毒而遭病，谁来买单？</p>

<p>小时候，印象中，北方的春天，沙尘暴总会来几次，每次都是几天的时间。那时黄沙遮天，阴风呜号，灶台碗里都沾满了沙土。但人们照常上班，上学，人们感觉到的最多的只是不便。确实这种沙尘暴相对还是“自然的”，沙尘中纯粹是沙尘，最多夹杂这一些颗粒垃圾，没有太多化学的物质。</p>

<p>家乡的沙尘暴这几年少了，不过环境并没有好转，村与村之间有好多建材工厂，路上也全是粉尘，空气中也有浓度很高的粉尘悬浮物，路两边本来绿色的庄稼叶子上也全是白色的粉尘，村里院子里都没法子晾衣服，会越晾越脏的。当时也是为了逃避这种环境，所以来到南方工作。想不到现在，杭州也这样了&hellip;</p>

<h2>雾霾的好处</h2>

<p>一切事务皆有两面性，从某种角度讲，雾霾的突然显现有其好处。因为雾霾可能是工业污染和汽车尾气排放长期的一个结果。城市中，空气质量一直很差，对人体的危害上可能每天都差不多一样，看不到雾霾也不能说明空气好，看到雾霾也不能说明空气更坏了。只不过雾霾的出现，将这种危害明面化了，使我们和各级部门不得不重视。换句话说，如果没有雾霾，可能不会有人重视与治理，但空气可能一样的差，不过公众的肉眼看不出而已。</p>

<p>雾霾的好处，就像前一段时间郭美美事件一样，从某种角度看，是好事！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/03/beyond-clean-code/">整洁代码之上</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-03T23:09:00+08:00" pubdate data-updated="true">2013-12-03</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>什么是整洁代码（What Is Clean Code）</h2>

<p>当你拿这个问题问不同的人，或采用不同的语气，你可能会得到不同的答案。但通常无外乎这些评判标准：</p>

<ul>
<li>自解释的命名</li>
<li>一致的代码风格</li>
<li>合适的抽象</li>
<li>可读性良好</li>
<li>清晰的代码流程</li>
<li>良好的架构</li>
<li>复杂任务使用库实现</li>
<li>使用工业级的解决方案</li>
<li>没有安全漏洞</li>
<li>函数短小</li>
<li>函数复杂度小</li>
</ul>


<p>不一而足，当然你也有自己评判整洁代码的标尺&hellip;</p>

<h2>如何写出整洁的代码(How To Write Clean Code)</h2>

<p>这是经久不衰的热议话题。我认为下面这幅画可以精辟地诠释如何写出整洁的代码：</p>

<p><img src="/images/posts/beyond-clean-code/towriting.png" title="" ></p>

<p>当然这有一点无厘头，但这是真的。大部分程序员没有写出整洁代码的时间。就此我们无可奈何！</p>

<h2>切换视角（Change The Premise)</h2>

<p>我打算在这说点可能稍具争议、离经叛道的想法：</p>

<blockquote><p>这里只有两种代码。一种具有商业价值，另一种没有！</p></blockquote>

<p>在工业界，我们看中的是“漂亮”的代码，我们看好的是可读性好、行为正确的代码。但因为某些原因，我们从来没有谈论过代码必须要有商用价值。再整洁的代码没有商业价值也是“贱货”。</p>

<p>所以，我们把“具有商业价值”整合进整洁代码的评判标尺，我们得到四种代码：</p>

<table border="1">
<tr><th></th><th>良好的商业价值</th><th>贫乏的商业价值</th></tr>
<tr><th>整洁代码</th><td>出色的代码</td><td>坏代码</td></tr>
<tr><th>丑陋代码</th><td>良好的代码</td><td>垃圾代码</td></tr>
</table>


<p>很明显使代码具有商业价值比使其“整洁”更划算。专注于“整洁”最多可以得到“坏代码”，而专注于&#8221;商业价值&#8221;，则最差得到“良好的代码”..</p>

<p>所以，怎样才能专注于商业价值呢？</p>

<h2>DIRTI方法（The DIRTI Method)</h2>

<p>我靠写DIRTI<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的代码来使代码专注于商业价值:</p>

<ol>
<li><strong>Develop</strong> &ndash; 为解决某个（商业）问题而快速开发（Develop)出哪怕很烂的代码。不要担心代码格式、抽象及其他任何问题。就是要完成它。</li>
<li><strong>Isolate</strong> &ndash; 分离（Isolate)上一步实现的功能，整理出抽象模块。这些将成为重构的点。</li>
<li><strong>Refactor</strong> &ndash; 重构(Refactor)这些模块，开始整理代码。</li>
<li><strong>Test</strong> &ndash; 当这些模块整理合理后，开始写测试(Test)用例（单元测试）。</li>
<li><strong>Integrate</strong> &ndash; 一旦这些模块通过测试就可以把它们集成(Integrate)进你的程序（要有集成测试）。</li>
</ol>


<p>妙的是，这一系列步骤假定你开始的时候并不知你的代码抽象的样子。但你一旦你开始写代码，它会逐渐帮助你明白你要解决的问题（方案）。</p>

<p>与TDD（测试驱动开发）截然不同的是，TDD期望你在你开始动手写代码前明白你要写的代码。</p>

<p>这确实会把我们带到一个美妙的境地。使用DIRTI方法会有两个主要的阶段：不停的DIR和不停的RTI。</p>

<p>当你最终明白方案之前，你将一遍遍的开发，分离，重构。而一旦顿悟以后，你将花费更多的时间到下一阶段（重构，测试，集成）。</p>

<h2>为什么这有效（Why This Works)</h2>

<p>为什么我坐在这里给你讲DIRTI方法？因为它行之有效。DIRTI方法确实会帮助你知道你要写的代码。它会帮助你指出要解决的问题。</p>

<p>更重要的是，它为你能做出英明决断提供力量和武器。你一定记得，具有商业价值的代码是好的代码。所以当你离开开发阶段，你的代码已经具有了商业价值，因为它已经可以解决最初要解决的问题。</p>

<p>整个进程是迭代的。你可以不停的分离、重构、分离、重构，直到你对代码满意。但这个过程中，你是在可以工作的代码上进行的。这非常酷！这样允许你责问自己，”是否代码已经足够好了“。一旦你对代码满意了，就进入下一阶段。</p>

<p>这会让你关注于最重要的东西：商业价值，而代码质量上的关注度是可以动态选择的。</p>

<h2>不是方案，仅仅是工具（Not A Solution, A Tool)</h2>

<p>必须要澄清的是：不是要你替换掉TDD、结对编程或其它你已经采用了的方法。DIRTI只会是你工具箱里的又一件工具。针对不同的问题要采用不同的工具：</p>

<p>如果你明白你要写的东西，那就用TDD。如果你仅仅知道问题，而不知解决方案（最佳），那就用DIRTI吧。</p>

<p>===================================================================================</p>

<p>翻译自：<a href="http://blog.ircmaxell.com/2013/11/beyond-clean-code.html">Beyond Clean Code</a></p>

<p>图片来自：<a href="http://www.aqee.net/how-to-write-good-code/">如何写出好代码</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>发音同Dirty<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/17/effective-tools/">Effective Tools - 多粘贴板 && 快速搜索</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-17T13:21:00+08:00" pubdate data-updated="true">2013-11-17</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前两天买了一本<a href="http://www.amazon.cn/gp/product/B001XCWFOI/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B001XCWFOI&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="">《卓有成效的程序员》</a>，看过几章后才明白为什么Stackoverflow里面人们会推荐这本书：它大抵是讲工具的，目的是为了提高程序员的生产率，但工具往往是人们漠视的。</p>

<p>工具的熟练使用，是人之所以成为人的一个重要条件。程序员也一样，虽然我们的可替代性很强，但一个“有成效的”程序员和一个普通的程序员的工作效率天壤之别。</p>

<p>工具是懒惰的程序员面对枯燥的劳动时下意识去寻找的东西。有些工具鲜有人知，但用过的人爱不释手。分享一下另自己爱不释手、每天都用的两款工具：</p>

<h3>多粘贴板 Clipx</h3>

<p>这是一款我每天都会使用，但认识的人里面没人听说过的软件，软件是免费使用的，下载地址在这里：<a href="http://bluemars.org/clipx/">Clipx</a>。</p>

<p>此软件的定位是代替Windows系统粘帖版功能，我们知道Windows系统的粘帖板只能保存最后一个拷贝或剪切的内容，但这对于我们程序员来说是远远不够的，我们每天有大量的Ctrl+C\Ctrl+V操作，这款软件就是为程序员而生的，Clipx可以保存多个历史剪切\复制的内容（格式不限：文本、文件、图片等），并可以快速的选择粘贴：</p>

<p><img src="/images/posts/effective-tools/clipx.jpg" title="" ></p>

<p><strong>Linux下也有类似软件，不过感觉不太好用：Glipper。</strong></p>

<h3>快速查找 光速搜索</h3>

<p>光速搜索是盛大出的一款免费软件，是以前一位同时推荐自己使用的，软件的优点是极速查找文件，并且有任务栏插件，方便实用。使用光速搜索，从此不用在忍受系统龟速的文件查找，唯一的一点不足就是此软件貌似不再更新，自己在Win7 64位下使用偶现Bug.</p>

<p>国外有一些类似的软件，比如大名鼎鼎的：Everything，但用来皆不如光速搜索体验好。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/4/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/2/">Newer &rarr;</a>
    
  </div>
</div>

  



      </div>
    </div>
    <footer class="footer"><p>
  Copyright &copy; 2014 - ToWriting -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span> -
  <span class="credit">Theme by <a href="https://github.com/barmstrong/octopress-bootstrap">Armstrong</a></span> -
  <span class="credit">本站内容采用<a rel="license" href="http://creativecommons.org/licenses/by/3.0/cn/">知识共享署名 3.0 中国大陆许可协议</a>进行许可</span>
</p>
</footer>
    







<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="/assets/bootstrap/js/bootstrap.min.js"></script>



  </div>
</body>
</html>
