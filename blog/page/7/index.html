
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>书写|记下人生痕迹</title>
  <meta name="author" content="ToWriting">

          
        <meta name="description" content="记录人生痕迹|分享技术心得 -- ToWriting.com. 一个立志独立思维的程序员的博客网站. 这里会记录下自己工作, 生活和回忆; 同时会分享编程等相关技术知识; 所有文章皆为原创或翻译.">
        <meta name="keywords" content="阅读,思考,书写,程序员,C++">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://towriting.com/blog/page/7">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="书写|记下人生痕迹" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.useso.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.useso.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42601840-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="no-sidebar"  class="collapse-sidebar sidebar-footer" >
  <header role="banner">
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:towriting.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2013/10/21/openshift-tips/">Openshift小技巧-热部署</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2013-10-21T22:24:00+00:00" pubdate data-updated="true">2013-10-21</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近试着用Openshift搭建了一个Octopress程序，搭建成功后，发现每次部署时，都会引起站点临时无法访问，这是自己使用Github的pages时没遇到的事情，用Google快速搜索下，原来要用热部署（hot deploy)实现不重启openshift程序部署文件，官方是支持的，方法很简单：</p>

<ol>
<li>切换到你的Openshift程序根目录</li>
<li>创建文件hot_deploy到指定目录：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>touch .openshift/markers/hot_deploy
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2013/09/30/the-myth-of-the-rockstar-programmer/">神级程序员的神话</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2013-09-30T12:20:00+00:00" pubdate data-updated="true">2013-09-30</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>神级程序员<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的神话不过就是个，神话！它是由一些可悲的原因形成的神话：</p>

<ul>
<li>给普通人设置难以实现的预期</li>
<li>宣扬虚无的神级程序员打压团队</li>
<li>告诉某人是神级的并使其相信这一说法</li>
</ul>


<p>现实总是正态分布的。大量的程序员是普通水平的，一些大牛已属异类，神级程序员只是传说中有（其实一些也很烂）。</p>

<blockquote><p>落后的项目增加人手,只会导致进度更加落后</p><footer><strong>Brooks&#8217;s law</strong> <cite><a href='http://en.wikipedia.org/wiki/Brooks%27s_law'>维基百科</a></cite></footer></blockquote>


<h2>神级程序员只是个神话</h2>

<p>人们总是津津乐道神级程序员可以做10个普通开发者的工作。天方夜谭！10个孕妇不会只用一个月生出小孩，10个“神级”程序员也无法代替100个普通程序员。</p>

<ul>
<li>助理工程师 &ndash; 简单的问题复杂的解决方案</li>
<li>工程师 &ndash; 简单的问题简单的解决方案</li>
<li>高级工程师 &ndash; 复杂的问题简单的解决方案</li>
<li>神级工程师 &ndash; 消灭复杂的问题于无形</li>
</ul>


<p>我算是神级的吗？我自信自己是一个高级程序员，也小有名气。过去的20年我参加了很多成功的项目，但我从不是坊间最聪明的人。</p>

<blockquote><p>高级 + 耀眼 != 神级</p></blockquote>

<p>按我的理解：</p>

<blockquote><p>高级 + 思想 == 神级</p></blockquote>

<p>这和有没有名气并没有任何关系。不能因为某某人写博客、书或者善于演讲就说他是个好开发。</p>

<p>神级程序员关心代码行数吗？不，好的开发关注的是解决问题。他们解决问题而不是抱怨问题。</p>

<h2>神级的团队是现实存在的</h2>

<p>事实上，团队想法和经验的某些特质成就了神级团队，这肯定是你关心的。深思与实效的组织架构加上激情积极好学的开发者必能有所成就。假如你坚持叫某些人“大神”，他可能是团队的老师或指导者。</p>

<p>John Galloway曾说过：</p>

<blockquote><p>“三思而后行”+“代码追求良质”是成就好团队的良方</p></blockquote>

<p>建造一只聪明个性的团队。创建<strong>神级团队</strong>。</p>

<p><strong>翻译自</strong>：<a href="http://www.hanselman.com/blog/TheMythOfTheRockstarProgrammer.aspx">The Myth of the Rockstar Programmer</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>神级程序员(Rockstar Programmer)是指技术能力很强、经验丰富还必须要有以一敌十的工作效能的程序员。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2013/09/23/edward-chands/">C++手爱德华</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2013-09-23T22:25:00+00:00" pubdate data-updated="true">2013-09-23</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="pull-right" src="/images/posts/edward-chands/Edwardscissorhandsposter.png" title="" ></p>

<blockquote><p>我一直在寻找一种可以类比使用C++编程时心情的东西，直到我想起1900年Tim Burton的电影，剪刀手爱德华。</p></blockquote>

<p>在这部电影中，可怜的家伙（Johnny Depp)想温柔的拥抱Winona Ryder但是他笨拙的剪刀手对他们俩都会造成伤害。他的脸上留下了很多伤疤。</p>

<p>拥有一对剪刀手并不总是坏事。爱德华有许多才能，比如，它可以给狗剪除漂亮的发式。</p>

<p>当参加完一些C++会议后，我总会有一些想法，最近参加的是Going Native 2013。去年可喜的是大多会议围绕着闪亮的C++11最新标准。但今年更多的关于实际检查。不要误会，这里有太多的漂亮的小狗发式可以展现（我是说C++代码可以简洁优雅）但是会议的主题总是关于如何避免出错及出错后的补救。</p>

<h2>恐怖小窝</h2>

<p>这里有太多的关于<strong>C++禁忌</strong>的讲座使我意识到这可能不是初级程序员的问题，这明显是C++语言自身的错。所以你仅仅学习了语言的基本元素后就使用它，你会遍体鳞伤的。</p>

<p>C++对此有借口：向后兼容 &mdash; 特别是兼容C语言。你应该认为C作为C++的子集应该像人们不应该每天使用汇编一样，除非你是个汇编程序员。假如你对你的C++工具箱视而不见，你看到的总是裸指针、for循环等丑陋的东西。</p>

<p>一个人所共知的禁忌是不要使用malloc动态分配内存，不要使用free释放内存。malloc接受一个size并返回一个void*，你必须把它转换成其它有用的类型。很难实现一个比这更糟糕的内存分配API。这有一段真的很糟的代码（但一般是运行正确的，假如不可能出现空指针解引用的话）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Pod</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span> <span class="n">counters</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="n">Pod</span> <span class="o">*</span> <span class="n">pod</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pod</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="k">sizeof</span> <span class="n">Pod</span><span class="p">);</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">n</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">free</span> <span class="p">(</span><span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">);</span>
</span><span class='line'><span class="n">free</span> <span class="p">(</span><span class="n">pod</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我希望人们不会写出这样的代码，但我确信现实世界的好多程序的代码中有这样的结构。</p>

<p>C++通过替换malloc和free为new和delete&#8221;解决&#8221;了多余的强转和易出错的size计算。正确的C++代码应该这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Pod</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span> <span class="n">counters</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="n">Pod</span> <span class="o">*</span> <span class="n">pod</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Pod</span><span class="p">;</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="p">[]</span> <span class="n">pod</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
</span><span class='line'><span class="k">delete</span> <span class="n">pod</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>顺便说一下，空指针引用的问题同样被解决了，因为如果系统内存耗尽，new总是会抛出异常。但这里在第二个new的地方还是有几率发生内存泄漏，所以这是现实中正确的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Snd</span> <span class="p">{</span> <span class="c1">// Sophisticated New Data</span>
</span><span class='line'><span class="nl">public:</span>
</span><span class='line'>    <span class="n">Snd</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">_count</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">_counters</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="p">{}</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Snd</span> <span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">_counters</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="nl">private:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span> <span class="n">_counters</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Snd</span> <span class="o">*</span> <span class="n">snd</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Snd</span> <span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">snd</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们做完了吗？才没呢！这段代码不是异常安全的。</p>

<p>C++的基本准则是避免裸指针、避免数组、避免delete。所以医治malloc的良药new也是不应使用的，它会返回危险的指针。</p>

<p>我们都知道（满脸的伤疤可以证明）尽一切可能使用STL容器和智能指针。也应该按值传递参数。不，等一下。按值传递参数因为多余的拷贝会增加性能损耗。使用shared_ptr或shared_ptr的容器怎么样？但这会增加引用计数的滥用。这里有新的解决方案：移动语义和右值引用。</p>

<p>我能举出无数类似的例子。看到规律了没？一个问题的解决方案可能会引入新的问题。不仅C子集需要避免使用。每个新的语言特性或库组建都会带来新的缺陷。当你听完Scott Meyers讲过后，你会发现一个新的特性怎么设计的这么烂（猜一下Scott Meyers论证的最新的缺陷是什么？是移动语义）。</p>

<h2>C++的哲学</h2>

<p>Bjarne Stroustrup一直强调向后兼容对C++来说多么重要。它是C++哲学的根基。它是决定那些代码是合法的依据。然而兼容性给语言演化代理了极大的拖累。如果自然界和C++一样是向后兼容的，人们还会有尾巴、腮、脚蹼、触角 &mdash; 在进化的过程中它们都有过作用。</p>

<p>C++变成了极度复杂的语言。同一件事情有无数种实现方式，但大部分都走向错误、危险、难维护。问题是代码可以编译甚至运行。错误或者缺陷会在后来被发现，甚至是产品发布以后。</p>

<p>你可能会说这是编程语言的自然特性。如果你真这样想，那要好好看看Haskell了。你的第一反应是：用这种极度严苛的语言我不知怎样实现第一件事（阶乘、斐波那契等）。这完全不同于C++。你不会意识到，运气好的话，需要十年你才能发现C++的“真谛”。能否想到，越好的C++程序员，他的代码越具有“函数性”。请教任何一个C++大神，它会回答你：避免可变的（mutation)，避免边际效应，避免继承和派生。但是你将需要严厉的准则和可以控制你同事的能力，因为C++太宽容了。</p>

<p>Haskell一点也不宽容，它不会让你或者你的同事写出不安全的代码的。是的，一开始你可能因为想要用haskell实现C++几分钟可以完成的事情而抓狂。假如你走运，为Sean Parent<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>或类似严格的程序员共事，他将review你的代码，并指出你不要用C++编码了。或者你自己继续在黑暗的日子里，数着自己伤害自己的伤口个数。</p>

<h2>资源管理</h2>

<p>我以资源管理的例子开始这篇文章（严格说是内存管理），因为这是我的个人爱好。从90年代起我就开始写关于资源管理的东西和宣传它。不过失败的是20年后资源管理技术还是鲜为人知。Bjarne Stroustrup有责任花费一半的演讲时间给高级C++程序员讲解资源管理的知识。你也可能会责备初级程序员们没能领悟资源管理是C++编程的根基。但问题是语言并没有指出我一开始写的那段代码有什么纰漏。事实上学习正确的技术就好像学习新的语言。</p>

<p>为何如此艰难？因为C++中最重要的资源管理是内存管理。事实上需要反复强调的是垃圾收集解决不了资源管理的问题：这里有文件句柄，内核对象，打开的数据库等等。这都是重要的资源，但重要性被繁复的内存管理比下去了。为什么不支持垃圾收集，不是因为找不到一种高效的实现方式，因为C++是排斥垃圾收集的。编译器和运行时总要做最坏的打算：不仅一个指针可能是另一个的别名而且内存地址可以保存成整型甚至它的低字节用作位域（所以C++只考虑保守的垃圾收集）。</p>

<p>一个错误的常识是引用计数（shared pointer中使用）比垃圾收集更好。这有个<a href="http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf">研究</a>显示它们是异曲同工的。你应该知道delete一个shared pointer可能会引发任意时间的程序暂停，这和垃圾收集的性能损耗是一样的。这不仅仅是因为一个靠谱的引用计数算法必须处理好环（cycles），并且每次引用计数到0，对象可以达到的指针都需要遍历。用shared pointer创建的数据结构可能花费很长的时间去释放，除了极简单的情况，你无法知道什么时候shared指针要清零了。</p>

<p>在单线程环境下小心的资源管理和使用shared_ptr还是很好的防御方式。但多线程下，麻烦来了。每一次增加减少计数都需要加锁！锁一般由原子变量实现，而不是互斥量。别傻了：使用原子变量消耗很大，这带给我C++的最大问题。</p>

<h2>并发和并行（Concurrency and Parallelism）</h2>

<p>早在8年以前，herb Sutter就发表了著名的声明：<a href="http://www.gotw.ca/publications/concurrency-ddj.htm">免费的午餐结束了</a>！并发并不是发明在2005年。Posix线程1995年就定义了。微软在Windows95引入线程，在NT中支持了多处理器。然而并发是C++11中才有的知识。</p>

<p>C++11算是“白手起家”并发。它必须定义内存模型：多线程写内存时，什么时候和以什么顺序使其对其它线程可见。基于实用的考虑，C++的内存模型是从java中拷贝来的（去掉了一些有争议的数据竞争时的保证）。一句话就是，如果没有数据竞争C++程序是按次序的。</p>

<p>C++11定义了关于线程创建和管理的一些元素，这些同步元素都是被dijkstra和hoare在1960年定义的，比如互斥量（mutexes）和条件变量。有人可能会争辩这些是否是同步的好组件，但这没关系因为都知道他们不是可组装的（composable)。STM（Software Transactional Memory）是可组装的抽象，但这很难在命令式语言中高效及正确的实现。标准委员会有个STM学习小组，所以STM还是有机会成为标准的一部分的。但是因为C++对边界效应不做任何控制，所以它会很难正确应用的。</p>

<p>还有一些误导和混淆是尝试去提供基于任务的并行，使用的是async tasks和非组装的futures（慎重考虑后都会在C++14中不推荐使用）。线程局部变量的标准化也使基于任务的并发很难实现。锁和条件变量也是线程相关的，而不是任务相关的。未来几年标准委员会的当务之急就是这些了：基于任务的并行, communication通道代替futures , 任务取消, 可能还有longer term, data-driven 并行, 包括支持GPU。一个微软PPL和英特尔TBB的衍生可能会被加进标准库（希望不是微软的AMP）。</p>

<p>预测推断所有这些可以在2015年标准化和实现。假如预测成真，我还是不相信人们会用C++实现并行编程。C++是为单线程编程设计的，支持并行编程需要革命而不是改革。四个字：数据竞争，指令型语言没有对此提供保护，可能除了D语言。</p>

<p>在C++中，数据默认是线程共享的、默认是可变的；函数默认是有边界效应的。所有这些指针和引用为数据竞争提供了富饶的土壤。数据结构和函数在竞争上的先天不足使类型系统无法反射。在C++中，假如你有个对象的const引用，但不能保证另一个线程中不会修改它。更糟的是，一个const对象里面的引用默认是可变的。</p>

<p>D语言至少有深度const和不可变的概念（没有线程可以修改一个不可变的数据结构）。D语言朝着并发的另一个改良是可以定义纯函数（pure functions)。在D语言中，可变对象默认不是进程共享的。这是正确的方向，虽然增加了共享对象的运行开销。更重要的想法是，线程不是一个并发编程的好的抽象，所以这种改进在轻量级的任务序列中就不那么有效了。</p>

<p>但是C++对这些都不支持，并且看起来永远都支持不了。</p>

<p>当然，你可能认出了这些并发和并行的特征都是函数式语言具有的，特别是不可变和纯函数。别嫌我烦：Haskell是并发编程上执牛耳者，包括GPU编程。这是为什么我在布道C++技巧数载后轻易转向了haskell。每一个认真对待并发和并行的程序员都应该好好学习haskell看一下它是如何处理这一切的。这里有一本Simon Marlow写的不错的书：<a href="http://www.amazon.cn/gp/product/1449335942/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1449335942&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="">Parallel and Concurrent Programming in Haskell</a>，读完它你或者开始在C++中使用函数式编程技术，或者认识到并发编程和指令式编程的分歧而转投Haskell。</p>

<h2>结论</h2>

<p>我认为C++语言和其哲学是和并发编程的需求冲突的。这种冲突导致并发编程在主流软件开发中缓慢前行。因为这过时的编程范式，微处理器、vector units和GPU的巨大能力被业界浪费了。</p>

<p>翻译自：<a href="http://bartoszmilewski.com/2013/09/19/edward-chands/">Edward C++Hands</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Adobe公司的首席科学家和移动数字图像组的架构师<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2013/09/22/the-best-programmer-in-the-world/">世界上最杰出的程序员是获得最大快乐的那个人</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2013-09-22T00:24:00+00:00" pubdate data-updated="true">2013-09-22</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Colin停在我的办公室来叫我去看他最近的项目。他拆开了他的显示器切换器（用来在两台PC之间切换单个显示器），拆开的切换器就摊放在他的桌子上。他把切换器接上了从RadioShack<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>淘来的部件，服务程序和客户端也都用VB6开发好了，将这一切整合好就能实现当鼠移动到屏幕边缘时自动切换显示器。Colin做这个项目获得了很大的快乐并且正在变成我们团队里最强大的程序员。这发生在Arduino<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>创建之前一段时间，那时硬件Hacking的门槛还很高。VB6正在衰退，使用它的人被认为只能维护那些烂的LOB程序。从Colin身上，我看到了好的创造者都会有的精神：享受创造的过程而不管使用的工具。</p>

<p>我很确信人们开始编程好多是受到类似与Colin一样的一些事情的激发。多少人开始编程生涯是为了设计我们自己的游戏，自己的网站，自己解决一个问题的方法并执着于编写成代码以给项目生命？有多少人会在自己后面的职业生涯继续这种精神，通过项目，通过失败，通过批判，甚至通过一个LOB<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>程序。</p>

<p>这些年来，程序员的第一要务是谋生而不是通过分享代码或公开博客的开放。现在有了在工作中看到出色程序员的机会，同时我们可以加入目前越来越流行的趋势：将我们自己和我们的作品与其他人做比较。在GitHub和StackOverflow之前我讨厌除了我同事之外的其他人阅读或点评我的代码，我也不喜欢阅读书籍或API文档之外的代码。现在我可以看世界上几乎任何一个程序员的代码，他们也可以看我的。必须谦虚因为世界上的牛人太多了。我能靠这点信息做什么？可以有机会学习或因不足而感到沮丧？或者相反这些代码没有自己完成度好？会留下意见同时增强了自信心吗？我看到那些用VB写的代码会乐起来吗？</p>

<p>如何一直保持编码的乐趣？这是我尝试的方法：</p>

<ol>
<li>维护一个自己的项目，并倾注你的热情同时与人分享</li>
<li>持续学习-多学点并没什么不好</li>
<li>给你的同事积极的回应（特别是竞争对手）</li>
<li>感谢帮助和影响过你的人们</li>
</ol>


<p>我想我不会成为像DHH<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>,Pike<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>,Stroustrup<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>或Resig<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>这样的大牛，但我可以获得和他们获得的同样多的乐趣。是的，你也可以成为世界上最杰出的程序员。</p>

<p>翻译自：<a href="http://hackerhmb.tumblr.com/post/61477929414/thebestprogrammerintheworld">The Best Programmer in the World is the One Having the Most Fun</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>美国的一个电子元器件零售商<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>硬件hacking相关的一个网站<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>line of business application指的是企业环境中的一些固定用途的程序<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>david heinemeier hansson，Ruby On Rails的创建者<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Rob Pike, Go语言的主要创建者之一<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p>Bjarne Stroustrup,C++之父<a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
<li id="fn:7">
<p>John Resig,jQuery库的创建者<a href="#fnref:7" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2013/09/21/office-stuff/">讲一讲程序员的办公用品</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2013-09-21T16:12:00+00:00" pubdate data-updated="true">2013-09-21</time>
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>高性能、舒适、充足的办公用品可以提高办公效率</p></blockquote>

<p>讲一讲这四年来我所在过的公司都给我们程序员提供过怎样的装配，这些装备主要包括：计算机、椅子、文具、打印机、水果点心等。</p>

<h2>第一份工作时</h2>

<p>刚毕业时经朋友介绍去的宁波一家医疗器械公司，公司规模百来人，产值2、3亿，要说效益还是不错的。公司不是纯粹的软件公司，所以不会在配置电脑、椅子上等方面针对程序员做特殊的考虑。对于电脑等办公用品，在新人入职时，会首先考虑分配旧的（离职员工用过的），如果没有旧的，会申购新的，而有些老旧的电脑基本属于奔四的水平，使用年限在5年以上。而我就不幸的分配到这样一台组装机，金河田的机箱螺丝都没了，P4/512M，键鼠是PS/2的，这台电脑的硬盘磁头老旧，运转的时候会“嘎嘎”的响，对面的同事老是嘲笑我的电脑不行了。这样一台电脑，可以想象运行通常的软件是很吃力的，VC6编辑代码也会经常卡，每次调试时按F5都要好长时间才可以反应过来。那时刚毕业，学习阶段，觉得也没什么资格要求什么，所以一直坚持了8、9个月后，找了一个机会向主管提出了自己电脑影响工作。主管让我去搬一台仓库闲置的工控机先用着，所以用了一段时间的工控机，工控机的性能比开始那台老旧机器好一些，不过声音极大，一开机整个办公室“嗡嗡”的响，每次下班时关机，对面的同事又嘲笑我，“整个世界一下子安静了”。</p>

<p>这个声音火车般的”工控机“用过大概2个月的时间后终于退出了历史的舞台。那时主管让我替公司采购一台品牌机，用于设备的配套机器，要求性能要好，所以我就采购了当时性能还算主流偏上的DELL商用机，I52400/4G，价格是7000多元。可是，机器买回来后发现PCI插槽不够用，退又退不掉，所以主管就让我用这台机器了，使用了新电脑后应该也是我技术提升最快、工作效率最高的时期，往后在同花顺的日子，我还一直怀念这台机器。</p>

<p>到我离职前2个月，老板娘发现了我们办公室那台闲置的金河田老电脑，让我搬给新入职的一位财务姑娘。现在想来但这台电脑节省的钱，不知能不能抵消使用此电脑的低效办公的损失？</p>

<p>那时年轻，椅子什么的从来没在意过，记得自己用的座椅相对还不错的，估计300左右，而其他人有的坐的都是大几十的普通家用椅，整个公司没有一条人体工学椅，但奇怪的是那时从来没有腰酸过，但一个老程序员已经腰肌劳损了，厉害时走路都很明显。</p>

<p>至于其他办公用品，比如本子、笔、插板、灯具等等是有的，不过拿的时候需要签字，记得我离职前后，好像有些东西需要主管审批了。</p>

<p>至于水果什么的，是来到杭州后，才发现可以有的。</p>

<h2>第二份工作</h2>

<p>同花顺的开发一般会配两台电脑，一台可以连接互联网，查找资料，另一台，只能连接SVN服务器，用于开发。电脑的配置策略也和在宁波时一样，优先选用仓库中剩余的机器，自己又不幸的被分配到配置较差的机器。那是一台P4的组装器，做内网开发机用，内存2G，其实应付一般的操作也还行，但主要是我们的项目代码是百万级的，所以VC6打开工程，或者调试时也是很卡的。而那台外网的机器，运行Win7还算跑的流畅。</p>

<p>当时配的椅子却是新的，比周围人的椅子要好些，但价格也不会超过500。来到杭州后，工作强度瞬间增加很多，所以坐在椅子上的时间也变得长了很多，所以这个椅子坐了大概1个多周，自己就腰酸背疼了，还是后来又花100多元买了个靠垫才缓解了这种疼痛。</p>

<p>同花顺每天中午是有水果供应的，这里的工作氛围也很融洽，中午有时吃着水果同时聊着天，心情愉悦后，办公效率自然就上去了。</p>

<p>不能提倡浪费，但在一些小的办公用品上，感觉这里有点节俭过了头。平时打印东西总是正面打了打反面，打印纸也经常没有，没有也只能去找，可打印纸的管理者竟然是负责公司日常事务的领导。我没有去要过，但听同事说过，要打印纸，这个领导要问你几个问题：直属领导是谁，打印纸做什么用，用几张，原来的为什么用的这么快？几个问题下来，再训上几句，半个小时可能就过去了。半个小时的薪水都可以买好多斤白纸了，很难想象上市公司的董事为何可以这样胡子眉毛一把抓。</p>

<h2>现在</h2>

<p>自己现在进入了互联网公司，互联网公司讲求“快&#8221;,快就需要高效的工作。公司这么多年做过来，知道好的办公环境是员工高效工作的保证，所以我们的开发电脑配置都是主流的，自己现在的机器是I7/8G，椅子也是较好的人体工学椅。关于椅子还有一个小趣事，刚来这边时，瞅了一眼椅子，感觉很单薄，觉得很普通的椅子，骨架上面简单套着一个网状的坐垫和靠背。后来在一次培训时，听一位讲师讲到公司给我们每个人配备4K多元的椅子，是为了让我们可以舒服高效的工作。公司给我们配置了好的办公环境，我们自然没有理由不全力工作。</p>

<h2>总结</h2>

<p>说了一大堆儿话，不过是想说，有些人算不清楚，小的投入可以有大产出。切莫捡了芝麻，丢了西瓜。自己以后一定要小心类似的思维陷阱。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/8">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/6">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/11/15/api-design-for-c-plus-plus-notes/">C++API设计 - 笔记</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/26/shop-class-as-soulcraft-notes/">读《摩托车修理店的未来工作哲学》</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/31/24-hour-stand-by/">互联网公司“24小时待命”的陋习</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/25/cpp-14-dessert/">C++14-大餐后的甜点</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/18/common-pitfalls-in-writing-lock-free-algorithms/">实现无锁算法的常见陷阱</a>
      </li>
    
  </ul>
</section>
<section>
  <h2>文章分类</h2>
    <ul id="category-list"><li><a href='/blog/categories/blog'>blog (1)</a></li><li><a href='/blog/categories/c-plus-plus'>c++ (18)</a></li><li><a href='/blog/categories/c-plus-plus-11'>c++11 (7)</a></li><li><a href='/blog/categories/c-plus-plus-14'>c++14 (1)</a></li><li><a href='/blog/categories/linux'>linux (2)</a></li><li><a href='/blog/categories/octopress'>octopress (2)</a></li><li><a href='/blog/categories/openshift'>openshift (1)</a></li><li><a href='/blog/categories/python'>python (1)</a></li><li><a href='/blog/categories/ruby'>ruby (1)</a></li><li><a href='/blog/categories/windows'>windows (6)</a></li><li><a href='/blog/categories/shu-xie'>书写 (1)</a></li><li><a href='/blog/categories/chan-pin'>产品 (1)</a></li><li><a href='/blog/categories/ren-sheng-gui-ji'>人生轨迹 (1)</a></li><li><a href='/blog/categories/hui-yi'>回忆 (5)</a></li><li><a href='/blog/categories/gong-zuo'>工作 (2)</a></li><li><a href='/blog/categories/gong-ju'>工具 (1)</a></li><li><a href='/blog/categories/bing-fa'>并发 (1)</a></li><li><a href='/blog/categories/zong-jie'>总结 (3)</a></li><li><a href='/blog/categories/cheng-xu-ren-sheng'>程序人生 (12)</a></li><li><a href='/blog/categories/xing-dong'>行动 (1)</a></li><li><a href='/blog/categories/ji-lu'>记录 (2)</a></li><li><a href='/blog/categories/du-shu'>读书 (1)</a></li><li><a href='/blog/categories/du-hou-gan'>读后感 (4)</a></li><li><a href='/blog/categories/yue-du'>阅读 (6)</a></li></ul>
</section>
<section>
  <h2>每日必读</h2>
   <ul>
    <li>
    <a href="http://news.ycombinator.com/">Hacker News</a>
    </li>
    <li>
    <a href="http://www.reddit.com/r/programming/">/r/programming</a>
    </li>
   </ul>
  <h2>关注博客</h2>
  <ul>
    <li>
      <a href="http://coolshell.cn/">酷壳</a>
    </li>
    <li>
      <a href="http://mindhacks.cn/">Mind Hacks</a>
    </li>
  </ul>
  <h2>友情链接</h2>
  <ul>
    <li>
      <a href="http://bestcbooks.com">计算机书籍控</a>
    </li>
  </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - ToWriting <br/>
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a>, customized with <a href="https://github.com/mjhea0/whiterspace">whiterspace</a>.</span>
</p>

<p>
  <span class="credit">本站内容采用<a rel="license" href="http://creativecommons.org/licenses/by/3.0/cn/">知识共享署名 3.0 中国大陆许可协议</a>进行许可</span>
</p></footer>
  











</body>
</html>
