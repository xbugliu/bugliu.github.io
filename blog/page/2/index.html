
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>书写|记下人生痕迹</title>
  <meta name="author" content="ToWriting">

          
        <meta name="description" content="记录人生痕迹|分享技术心得 -- ToWriting.com. 一个立志独立思维的程序员的博客网站. 这里会记录下自己工作, 生活和回忆; 同时会分享编程等相关技术知识; 所有文章皆为原创或翻译.">
        <meta name="keywords" content="阅读,思考,书写,程序员,C++">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://towriting.com/blog/page/2">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="书写|记下人生痕迹" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.useso.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.useso.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42601840-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="no-sidebar"  class="collapse-sidebar sidebar-footer" >
  <header role="banner">
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:towriting.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2014/08/25/cpp-14-dessert/">C++14-大餐后的甜点</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-08-25T23:15:41+00:00" pubdate data-updated="true">2014-08-25</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这次C++标准委员会快速的通过了最新的C++标准:C++14，要知道C++11可是一再跳票后的产物。此次快速的发布的缘由可能和C++14的改动较小有关，C++之父Bjarne Stroustrup也说，相比与C++11来说，C++14的改动是<a href="http://electronicdesign.com/dev-tools/bjarne-stroustrup-talks-about-c14">谨小甚微的</a>。相信C++14不会给我们带来像C++11那样的震撼，所以我们只能期待下一个版本C++17了。</p>

<p><img class="pull-right" src="/images/posts/cpp-14-dessert/wg21-timeline.png"></p>

<p>但Bjarne还说了，C++永远是心向开发者的，C++14将给开发者大开方面之门。关于C++14更详细的细节可以看维基百科:<a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14</a>,这里讲下自己感兴趣的特性：</p>

<h3>语言改变</h3>

<p><strong>范型lambda</strong></p>

<p>在C++11下，如果你想要打印出一个数的平方，可能需要这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">square_int</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'><span class="k">auto</span> <span class="n">square_double</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">square_int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">square_int</span><span class="p">(</span><span class="mf">10.1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了保持函数的局部性，我们才选择的lambda，但C++11的lambda却导致多个类型时代码膨胀且重复，此时我们需要回过头来借助全局的模板了。</p>

<p>但C++14可以完美的解决上面的问题，因为C++14中lambda的参数可以用auto代替具体的类型：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">square_int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">square_int</span><span class="p">(</span><span class="mf">10.1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>auto返回类型</strong></p>

<p>C++11支持auto关键字，用于变量的自动类型推导。但由于时间限制，C++标准委员会并没有让auto也支持函数的返回值类型自动推导，现在C++14支持了。这将会在返回类内部类型的成员函数书写上减少好多工作量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Wiget</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">Status</span><span class="p">{</span><span class="n">show</span><span class="p">,</span> <span class="n">hide</span><span class="p">}</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">getStatus</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">auto</span> <span class="n">Wiget</span><span class="o">::</span><span class="n">getStatus</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">show</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>编译器支持</h3>

<p>曾经被标准折磨的死去活来的编译器如今越挫越勇。标准出来的快，编译器支持的更快。CLang（3.4）半年前就宣布已完全支持C++14(draft)特性（语言和库）。本人电脑上的GCC4.9.1也已部分支持C++14特性。但公司的开发环境要支持C++14可就难了。</p>

<p>参考：</p>

<p><a href="https://isocpp.org/std/status">https://isocpp.org/std/status</a></p>

<p><a href="http://cpprocks.com/c1114-compiler-and-library-shootout/">http://cpprocks.com/c1114-compiler-and-library-shootout/</a></p>

<p><a href="http://cpprocks.com/an-overview-of-c14-language-features/">http://cpprocks.com/an-overview-of-c14-language-features/</a></p>

<p><a href="http://llvm.org/releases/3.4/tools/clang/docs/ReleaseNotes.html">http://llvm.org/releases/3.4/tools/clang/docs/ReleaseNotes.html</a></p>

<p><a href="https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/">https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2014/08/18/common-pitfalls-in-writing-lock-free-algorithms/">实现无锁算法的常见陷阱</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-08-18T23:34:52+00:00" pubdate data-updated="true">2014-08-18</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>翻译自：<a href="http://blog.memsql.com/common-pitfalls-in-writing-lock-free-algorithms/">Common Pitfalls in Writing Lock-Free Algorithms</a></h2>

<p>通常，只要两个操作之间的步骤是有穷的，一个多线程算法就认为可以实现为无锁(lock-free)。理论上无锁算法也早已被证明，看起来实现一个无锁算法也很简单。但其实不然，每一步都隐藏着陷阱：并发的线程可以修改共享的对象，甚至在执行一个操作时线程可以突然暂停或中止，而这是另一个线程当作好像若无其事。</p>

<p>线程同步是多线程程序设计的核心，传统的做法上就是代码临界区上加锁。锁可以防止多个线程同一时间进入临界区代码。在高度并发的程序里，锁可能成为严重的性能瓶颈。无锁编程的目标是不用锁也能解决并发问题。无锁编程一般依赖的是原子操作，比如“compare-and-swap”<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>原子的执行下面的操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="mi">1</span> <span class="kt">bool</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="n">Value</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">Value</span> <span class="n">oldVal</span><span class="p">,</span> <span class="n">Value</span> <span class="n">newVal</span><span class="p">){</span>
</span><span class='line'><span class="mi">2</span>     <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span> <span class="o">==</span> <span class="n">oldVal</span><span class="p">){</span>
</span><span class='line'><span class="mi">3</span>         <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">newVal</span><span class="p">;</span>
</span><span class='line'><span class="mi">4</span>         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="mi">5</span>     <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'><span class="mi">6</span>         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'><span class="mi">7</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">8</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用无锁算法的最大缺陷是：</p>

<ul>
<li>无锁算法并不总是可实现的</li>
<li>无锁算法的代码很难写</li>
<li>写出正确的无锁算法代码更是难如登天</li>
</ul>


<p>为了证明以上三点，我们来看一个错误实现的一个无锁栈(lock-free stack)，可能大部分人第一次都会写出这样保护这些错误无锁栈。这个无锁栈算法主要是使用一个链表(linked-list)来存放节点，并用<code>CompareAndSwap</code>来修改链表的表头。 Push一个元素时，我们首先创建一个节点保存数据，并将这个节点设为栈顶，并使用<code>CompareAndSwap</code>将原栈顶指向新的元素。<code>CompareAndSwap</code>操作保证只有我们的新节点指向老的栈顶节点，才会替换老的栈顶（因为多线程可能改变老的栈顶）。当Pop一个元素时，我们快照当前的栈顶节点，然后替换当前的栈顶节点到下一个节点。我们再一次使用<code>CompareAndSwap</code>保证替换的节点等于快照的节点。</p>

<p>C++代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'> <span class="mi">1</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Entry</span><span class="o">&gt;</span>
</span><span class='line'> <span class="mi">2</span> <span class="k">class</span> <span class="nc">LockFreeStack</span><span class="p">{</span>
</span><span class='line'> <span class="mi">3</span>     <span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
</span><span class='line'> <span class="mi">4</span>         <span class="n">Entry</span><span class="o">*</span> <span class="n">entry</span><span class="p">;</span>
</span><span class='line'> <span class="mi">5</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span><span class='line'> <span class="mi">6</span>     <span class="p">};</span>
</span><span class='line'> <span class="mi">7</span>
</span><span class='line'> <span class="mi">8</span>     <span class="n">Node</span><span class="o">*</span> <span class="n">m_head</span><span class="p">;</span>
</span><span class='line'> <span class="mi">9</span>
</span><span class='line'><span class="mi">10</span>     <span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">Entry</span><span class="o">*</span> <span class="n">e</span><span class="p">){</span>
</span><span class='line'><span class="mi">11</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span>
</span><span class='line'><span class="mi">12</span>         <span class="n">n</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
</span><span class='line'><span class="mi">13</span>         <span class="k">do</span><span class="p">{</span>
</span><span class='line'><span class="mi">14</span>             <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">15</span>         <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_head</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
</span><span class='line'><span class="mi">16</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">17</span>
</span><span class='line'><span class="mi">18</span>     <span class="n">Entry</span><span class="o">*</span> <span class="nf">Pop</span><span class="p">(){</span>
</span><span class='line'><span class="mi">19</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">old_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">20</span>         <span class="n">Entry</span><span class="o">*</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="mi">21</span>         <span class="k">do</span><span class="p">{</span>
</span><span class='line'><span class="mi">22</span>             <span class="n">old_head</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">23</span>             <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span><span class='line'><span class="mi">24</span>                 <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="mi">25</span>             <span class="p">}</span>
</span><span class='line'><span class="mi">26</span>         <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_head</span><span class="p">,</span> <span class="n">old_head</span><span class="p">,</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
</span><span class='line'><span class="mi">27</span>
</span><span class='line'><span class="mi">28</span>         <span class="n">result</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
</span><span class='line'><span class="mi">29</span>         <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">30</span>         <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="mi">31</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">32</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>遗憾的是，这个无锁栈充满的错误：</p>

<h3>Segfault</h3>

<p>Push操作分配内存保存节点信息，Pop操作释放这些内存。然而，线程T1在顺序执行22行和26行之间的时间里，另一个线程T2可能已经释放了这个节点，然后程序Crash了。</p>

<h3>Corruption</h3>

<p>仅仅对比新值与老值是否相等，<code>CompareAndSwap</code>方法并不能保证是否值发生了变化。假如快照在22行的值，被修改了，然后又被恢复了，然后<code>CompareAndSwap</code>会成功。这就是著名的<strong>ABA问题</strong>。假如栈中前两个节点是A和C，如果以下面的序列操作：</p>

<ul>
<li>线程1执行Pop，并在22行读到了m_head(<strong>A</strong>)，在26行读到了old_head->next(<strong>C</strong>)，然后突然阻塞在执行在<code>CompareAndSwap</code>之前。</li>
<li>线程2执行pop，删掉节点<strong>A</strong>。</li>
<li>线程2调用push，push了一个新节点<strong>B</strong>。</li>
<li>线程2又调用一次push，这次push的新节点正好占用了原来节点<strong>A</strong>的内存。</li>
<li>线程1被唤醒，调用<code>CompareAndSwap</code>。</li>
</ul>


<p>然后26行的<code>CompareAndSwap</code>会成功，虽然m_head已经被改变3次了，因为它只检测old_head是否等于m_head。这是有问题的，因为新的栈顶本应指向<strong>B</strong>，然而却指向了<strong>C</strong>。</p>

<h3>Not lock-free</h3>

<p>C++标准并不保证new和delete是lock-free的。一个无锁的数据结构去调用非无锁的库函数不是什么好主意，所以我们需要一个无锁的内存分配子。</p>

<h3>Data races</h3>

<p>当一个线程向内存中写入数据，而另一个线程同时从相同的内存读数据时，所产生的结果是未定义的，除非使用std::atomic。读和写操作都必须是原子的。在C++11以前一个通用的方法是使用<strong>volatile</strong>关键字来生命原子变量，然而这个关键字有很大的<a href="http://software.intel.com/en-us/blogs/2007/11/30/volatile-almost-useless-for-multi-threaded-programming">缺陷</a>。</p>

<p>在我们的例子中，多个线程读栈顶指针可能会引起竞争，push和pop操作都有可能，因为其它线程可能在修改他。</p>

<h3>Memory reordering</h3>

<p>印象中，代码会按照我们指定的顺序执行，最少也会满足”<a href="http://en.wikipedia.org/wiki/Happened-before">happens before</a>“关系。不幸的是，不管理论还是实际上，下面代码的执行可能出现x,y都是0的结果。:</p>

<p><img class="pull-right" src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/memory-reordering.png"></p>

<p>C++11以前标准对于多线程是讳莫如深的，所以编译器的优化是着眼于单线程的。上面的代码，交换执行顺序，并不会影响单线程中程序的语义。所以可能会产生这种结果。</p>

<h2>如何写正确的lock-free栈</h2>

<p>上面大部分问题都有多种解决方案，这里我会把自己工作中使用的方法描述出来。</p>

<h3>Segfault</h3>

<p>解引用节点之前，必须确保该节点没有被删掉。每一个线程都有一个全局可见的&#8221;hazard pointer&#8221;。当访问一个节点之前，会先设置Hazard pointer执行这个节点。只要设置过Hazard pointer就可以保证这个节点此时还是栈顶节点。如果其它线程此时移除这个栈顶节点，要检测没有Hazard pointer指向这个节点才能清除节点的内存。</p>

<h3>Corruption</h3>

<p>解决ABA问题的一个方法是确保栈顶不会有同样的值两次。我们使用“tagged pointers”来确保栈头值的唯一。一个“tagged pointers”包含一个指针和64位计数器。每当栈顶变化，计数器加一。</p>

<h3>Not lock-free</h3>

<h3>Data races</h3>

<p>我们目前使用的是boost::atomic。现在我们使用gcc4.6也已经支持std::atomic，但实现的效率没有boost高。在gcc4.6中，所有需要原子操作的地方都被应用了memory barriers，即使本不必使用的地方。</p>

<h3>Memory reordering</h3>

<p>C++11为原子操作提供了一种新的内存模型和内存序语义，以解决乱序的问题。CompareAndSwap需要顺序一致性(sequentially consistent)的语义保证。顺序一致性意味着所有的线程以一种一致的次序执行操作。事实证明hazard pointers也一样需要顺序一致性保证内存语义。
如果不使用内存一致性，下面这种情况下会有问题：</p>

<ul>
<li>线程1准备Pop操作，读取了栈顶节点</li>
<li>线程1将当前节点写到hazard pointer中</li>
<li>线程1再次读取栈顶指针</li>
<li>线程2将栈顶指针移走，并传递到垃圾收集线程</li>
<li>垃圾收集器扫描所有的hazard pointer节点，因为没有顺序一致性，可能看不到线程1的hazard pointer已经指向了这个节点</li>
<li>垃圾收集器删除了这个节点</li>
<li>线程1解引用这个节点，然后程序Crash</li>
</ul>


<p>而如果有顺序一致性应用到hazard pointer的赋值和节点的修改，竞争就不会发生了。因为任意两个操作，所有线程看到的顺序都是一样的。如果线程2先移除这个节点，那么线程1第二次读时会看到一个不同的节点，也就不会去解引用它。假如线程1先将节点写到hazard pointer中，则垃圾收集器肯定可以看到这个值而不会去删除它。</p>

<h2>性能</h2>

<p>到现在我们解决了所有的问题。让我们看一下性能。测试使用的是一台8核Intel&reg; Xeon&reg; 处理器。每个线程的工作是随机的执行数量几乎相等的Push和Pop操作。每个线程不加限制的执行机器可以处理的操作。</p>

<p><img class="pull-right" src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/chart.svg"></p>

<p>我们修改栈顶的次数越多，CompareAndSwap失败的次数也会越多。一个简单有效的减少失败的方法是失败后Sleep一下，这可以调节Stack可以高效的处理数据。下面是每次失败后Sleep(250)的数据：</p>

<p><img class="pull-right" src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/chart1.svg"></p>

<p>太好了，增加Sleep后栈的吞吐量增加了7倍。并且Sleep减少的处理器的消耗。让我们看一下处理器的使用情况：</p>

<p>加锁的栈：</p>

<p><img class="pull-right" src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/htop_mutex.png"></p>

<p>无锁的栈，不加Sleep:</p>

<p><img class="pull-right" src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/htop_lockfree.png"></p>

<p>无锁的栈，Sleep(250):</p>

<p><img class="pull-right" src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/htop_usleep.png"></p>

<p>看起来无锁更好？等等，锁一样可以达到好的性能，我们不用std::mutex，我们使用Sleep(250)的自旋锁：
<img class="pull-right" src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/chart2.svg"></p>

<h2>结果</h2>

<p>大量数据时，额外的线程会降低吞吐量。Sleep可以降低操作冲突，增加吞吐量的同时减小处理器消耗。3个线程以上的性能没有变化。单线程是性能最佳的。</p>

<h2>结论</h2>

<p>无锁不会阻碍进度，但也并不会提高效率。当你想在你的项目中使用无锁算法时，切记要衡量值不值的-性能还有复杂度。</p>

<h2>代码</h2>

<p>加锁的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'> <span class="mi">1</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span>
</span><span class='line'> <span class="mi">2</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stack</span><span class="o">&gt;</span>
</span><span class='line'> <span class="mi">3</span>
</span><span class='line'> <span class="mi">4</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span><span class='line'> <span class="mi">5</span> <span class="k">class</span> <span class="nc">LockedStack</span><span class="p">{</span>
</span><span class='line'> <span class="mi">6</span> <span class="k">public</span><span class="o">:</span>
</span><span class='line'> <span class="mi">7</span>     <span class="kt">void</span> <span class="n">Push</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">entry</span><span class="p">){</span>
</span><span class='line'> <span class="mi">8</span>         <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
</span><span class='line'> <span class="mi">9</span>         <span class="n">m_stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
</span><span class='line'><span class="mi">10</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">11</span>
</span><span class='line'><span class="mi">12</span>     <span class="c1">// For compatability with the LockFreeStack interface,</span>
</span><span class='line'><span class="mi">13</span>     <span class="c1">// add an unused int parameter.</span>
</span><span class='line'><span class="mi">14</span>     <span class="c1">//</span>
</span><span class='line'><span class="mi">15</span>     <span class="n">T</span><span class="o">*</span> <span class="n">Pop</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
</span><span class='line'><span class="mi">16</span>         <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
</span><span class='line'><span class="mi">17</span>         <span class="nf">if</span><span class="p">(</span><span class="n">m_stack</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span><span class='line'><span class="mi">18</span>             <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'><span class="mi">19</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">20</span>         <span class="n">T</span><span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">m_stack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span><span class='line'><span class="mi">21</span>         <span class="n">m_stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'><span class="mi">22</span>         <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="mi">23</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">24</span>
</span><span class='line'><span class="mi">25</span> <span class="k">private</span><span class="o">:</span>
</span><span class='line'><span class="mi">26</span>     <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">m_stack</span><span class="p">;</span>
</span><span class='line'><span class="mi">27</span>     <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_mutex</span><span class="p">;</span>
</span><span class='line'><span class="mi">28</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lock-Free的：
(垃圾收集相关的代码没贴出来）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'> <span class="mi">1</span> <span class="k">class</span> <span class="nc">LockFreeStack</span><span class="p">{</span>
</span><span class='line'> <span class="mi">2</span> <span class="k">public</span><span class="o">:</span>
</span><span class='line'> <span class="mi">3</span>     <span class="c1">// The elements we wish to store should inherit Node</span>
</span><span class='line'> <span class="mi">4</span>     <span class="c1">//</span>
</span><span class='line'> <span class="mi">5</span>     <span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
</span><span class='line'> <span class="mi">6</span>         <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">next</span><span class="p">;</span>
</span><span class='line'> <span class="mi">7</span>     <span class="p">};</span>
</span><span class='line'> <span class="mi">8</span>
</span><span class='line'> <span class="mi">9</span>     <span class="c1">// Unfortunately, there is no platform independent way to</span>
</span><span class='line'><span class="mi">10</span>     <span class="c1">// define this class.  The following definition works in</span>
</span><span class='line'><span class="mi">11</span>     <span class="c1">// gcc on x86_64 architectures</span>
</span><span class='line'><span class="mi">12</span>     <span class="c1">//</span>
</span><span class='line'><span class="mi">13</span>     <span class="k">class</span> <span class="nc">TaggedPointer</span><span class="p">{</span>
</span><span class='line'><span class="mi">14</span>     <span class="k">public</span><span class="o">:</span>
</span><span class='line'><span class="mi">15</span>         <span class="n">TaggedPointer</span><span class="p">()</span><span class="o">:</span> <span class="n">m_node</span><span class="p">(</span><span class="n">nullptr</span><span class="p">),</span> <span class="n">m_counter</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="mi">16</span>
</span><span class='line'><span class="mi">17</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">GetNode</span><span class="p">(){</span>
</span><span class='line'><span class="mi">18</span>             <span class="k">return</span> <span class="n">m_node</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class='line'><span class="mi">19</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">20</span>
</span><span class='line'><span class="mi">21</span>         <span class="kt">uint64_t</span> <span class="n">GetCounter</span><span class="p">(){</span>
</span><span class='line'><span class="mi">22</span>             <span class="k">return</span> <span class="n">m_counter</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class='line'><span class="mi">23</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">24</span>
</span><span class='line'><span class="mi">25</span>         <span class="kt">bool</span> <span class="n">CompareAndSwap</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">oldNode</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">oldCounter</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">newCounter</span><span class="p">){</span>
</span><span class='line'><span class="mi">26</span>             <span class="kt">bool</span> <span class="n">cas_result</span><span class="p">;</span>
</span><span class='line'><span class="mi">27</span>             <span class="n">__asm__</span> <span class="n">__volatile__</span>
</span><span class='line'><span class="mi">28</span>             <span class="p">(</span>
</span><span class='line'><span class="mi">29</span>                 <span class="s">&quot;lock;&quot;</span>           <span class="c1">// This makes the following instruction atomic (it is non-blocking)</span>
</span><span class='line'><span class="mi">30</span>                 <span class="s">&quot;cmpxchg16b %0;&quot;</span>  <span class="c1">// cmpxchg16b sets ZF on success</span>
</span><span class='line'><span class="mi">31</span>                 <span class="s">&quot;setz       %3;&quot;</span>  <span class="c1">// if ZF set, set cas_result to 1</span>
</span><span class='line'><span class="mi">32</span>
</span><span class='line'><span class="mi">33</span>                 <span class="o">:</span> <span class="s">&quot;+m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="s">&quot;+a&quot;</span> <span class="p">(</span><span class="n">oldNode</span><span class="p">),</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">oldCounter</span><span class="p">),</span> <span class="s">&quot;=q&quot;</span> <span class="p">(</span><span class="n">cas_result</span><span class="p">)</span>
</span><span class='line'><span class="mi">34</span>                 <span class="o">:</span> <span class="s">&quot;b&quot;</span> <span class="p">(</span><span class="n">newNode</span><span class="p">),</span> <span class="s">&quot;c&quot;</span> <span class="p">(</span><span class="n">newCounter</span><span class="p">)</span>
</span><span class='line'><span class="mi">35</span>                 <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span>
</span><span class='line'><span class="mi">36</span>             <span class="p">);</span>
</span><span class='line'><span class="mi">37</span>             <span class="k">return</span> <span class="n">cas_result</span><span class="p">;</span>
</span><span class='line'><span class="mi">38</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">39</span>     <span class="k">private</span><span class="o">:</span>
</span><span class='line'><span class="mi">40</span>         <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">m_node</span><span class="p">;</span>
</span><span class='line'><span class="mi">41</span>         <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">m_counter</span><span class="p">;</span>
</span><span class='line'><span class="mi">42</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">43</span>     <span class="c1">// 16-byte alignment is required for double-width</span>
</span><span class='line'><span class="mi">44</span>     <span class="c1">// compare and swap</span>
</span><span class='line'><span class="mi">45</span>     <span class="c1">//</span>
</span><span class='line'><span class="mi">46</span>     <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
</span><span class='line'><span class="mi">47</span>
</span><span class='line'><span class="mi">48</span>     <span class="kt">bool</span> <span class="nf">TryPushStack</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">entry</span><span class="p">){</span>
</span><span class='line'><span class="mi">49</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
</span><span class='line'><span class="mi">50</span>         <span class="kt">uint64_t</span> <span class="n">oldCounter</span><span class="p">;</span>
</span><span class='line'><span class="mi">51</span>
</span><span class='line'><span class="mi">52</span>         <span class="n">oldHead</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetNode</span><span class="p">();</span>
</span><span class='line'><span class="mi">53</span>         <span class="n">oldCounter</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetCounter</span><span class="p">();</span>
</span><span class='line'><span class="mi">54</span>         <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'><span class="mi">55</span>         <span class="k">return</span> <span class="n">m_head</span><span class="p">.</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">oldCounter</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">oldCounter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="mi">56</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">57</span>
</span><span class='line'><span class="mi">58</span>     <span class="kt">bool</span> <span class="nf">TryPopStack</span><span class="p">(</span><span class="n">Node</span><span class="o">*&amp;</span> <span class="n">oldHead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threadId</span><span class="p">){</span>
</span><span class='line'><span class="mi">59</span>         <span class="n">oldHead</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetNode</span><span class="p">();</span>
</span><span class='line'><span class="mi">60</span>         <span class="kt">uint64_t</span> <span class="n">oldCounter</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetCounter</span><span class="p">();</span>
</span><span class='line'><span class="mi">61</span>         <span class="k">if</span><span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">){</span>
</span><span class='line'><span class="mi">62</span>             <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="mi">63</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">64</span>         <span class="n">m_hazard</span><span class="p">[</span><span class="n">threadId</span><span class="o">*</span><span class="mi">8</span><span class="p">].</span><span class="n">store</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
</span><span class='line'><span class="mi">65</span>         <span class="k">if</span><span class="p">(</span><span class="n">m_head</span><span class="p">.</span><span class="n">GetNode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">oldHead</span><span class="p">){</span>
</span><span class='line'><span class="mi">66</span>             <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'><span class="mi">67</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">68</span>         <span class="k">return</span> <span class="n">m_head</span><span class="p">.</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">oldCounter</span><span class="p">,</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">),</span> <span class="n">oldCounter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="mi">69</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">70</span>
</span><span class='line'><span class="mi">71</span>     <span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">entry</span><span class="p">){</span>
</span><span class='line'><span class="mi">72</span>         <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span><span class='line'><span class="mi">73</span>             <span class="k">if</span><span class="p">(</span><span class="n">TryPushStack</span><span class="p">(</span><span class="n">entry</span><span class="p">)){</span>
</span><span class='line'><span class="mi">74</span>                 <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="mi">75</span>             <span class="p">}</span>
</span><span class='line'><span class="mi">76</span>             <span class="n">usleep</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
</span><span class='line'><span class="mi">77</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">78</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">79</span>
</span><span class='line'><span class="mi">80</span>     <span class="n">Node</span><span class="o">*</span> <span class="nf">Pop</span><span class="p">(</span><span class="kt">int</span> <span class="n">threadId</span><span class="p">){</span>
</span><span class='line'><span class="mi">81</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'><span class="mi">82</span>         <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span><span class='line'><span class="mi">83</span>             <span class="k">if</span><span class="p">(</span><span class="n">TryPopStack</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">threadId</span><span class="p">)){</span>
</span><span class='line'><span class="mi">84</span>                 <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'><span class="mi">85</span>             <span class="p">}</span>
</span><span class='line'><span class="mi">86</span>             <span class="n">usleep</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
</span><span class='line'><span class="mi">87</span>         <span class="p">}</span>
</span><span class='line'><span class="mi">88</span>     <span class="p">}</span>
</span><span class='line'><span class="mi">89</span>
</span><span class='line'><span class="mi">90</span> <span class="k">private</span><span class="o">:</span>
</span><span class='line'><span class="mi">91</span>     <span class="n">TaggedPointer</span> <span class="n">m_head</span><span class="p">;</span>
</span><span class='line'><span class="mi">92</span>     <span class="c1">// Hazard pointers are separated into different cache lines to avoid contention</span>
</span><span class='line'><span class="mi">93</span>     <span class="c1">//</span>
</span><span class='line'><span class="mi">94</span>     <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">m_hazard</span><span class="p">[</span><span class="n">MAX_THREADS</span><span class="o">*</span><span class="mi">8</span><span class="p">];</span>
</span><span class='line'><span class="mi">95</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>硬件相关，Windows已提供函数InterlockedCompareExchange<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2014/07/21/review-xzjy/">读《寻找家园》</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-07-21T23:51:23+00:00" pubdate data-updated="true">2014-07-21</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>诚然，这是一本文辞优美的自传集。自以为博学杂收，但此前竟从未听说过高尔泰，概和主流媒介打压有关。80后的我，有幸避过了那段岁月，所以对于书中，高先生凄苦的人生，只能报以同情，很难产生共鸣。高先生悲惨的际遇和余华《活着》中的福贵的一生很像，波诡云谲的时代，至亲“莫名其妙”的离去，种种不公平待遇，最后还活着，随波逐流。</p>

<p>但逆水的鱼，这是天生的命运。高先生最终去了标榜自由平等的米国，广阔天地，但难以大有作为，老来无依，故国不堪回首，所以整理出这<a href='http://www.amazon.cn/gp/product/B00K0E4NFO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00K0E4NFO&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>寻找家园</a>来。</p>

<p>读此书，看高尔泰传奇一生，随便拈来一件小事都是我们当代常人一生难逢的际遇，而且即使选中了你我，也并非你我可以承受。反观我们的生活，钢筋水泥的城市，一成不变的工作，三两个不勾心斗角的同事，做着不着调的工作，两点一线，直至老去，有幸的留下荒冢一堆，无运的骨灰都不是自己的！</p>

<p>都市中渺小的我，搞不清高尔泰追求的自由为何物，自由和活着孰重孰轻。年轻的高尔泰似乎没有追求自由的能力，只能任命运摆弄，想着往上爬的，却成了别人的梯子，80年代后，环境宽松，如果懂的迎合，以他的名望和学识，想必日子不会艰难，也不会老来流落米国。</p>

<p>在我看来，自由是，不妨碍他人的前提下，随意做自己想做的事情。所以活着是自由的前提，“不自由，毋宁死”，死了不还是得不到自由！如果高尔泰可以顺从，是否可以摆脱暴力的关照，安心做自己喜欢的事情呢，这不就实现了他的自由了吗？</p>

<p>这种想法有些小人之心度君子之腹了，高尔泰是不会仰人鼻息的!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2014/07/08/evil-refactor/">关于重构的一些想法</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-07-08T00:26:25+00:00" pubdate data-updated="true">2014-07-08</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>很早之前听说过这样一个故事：</p>

<blockquote><p>一个漂亮的女子与马戏团的小丑坠入爱河，并迅速结婚。小丑十分珍惜得来的幸福，努力挣钱，瞒着女子做了整容手术，为了给女子惊喜。整容后的小丑出现在女子眼前时，女子提出离婚，因为他喜欢的是原来长的并不帅的小丑。</p></blockquote>

<p>一个项目重构的动机(目的)无外乎两种：1. 给用户带来更好的体验、2. 项目代码失控（难以维护、添加新特性）。重构必然导致变化，用户接受现在的产品，重构后的版本并不一定喜欢。至于极端，哪怕重构后的版本比老版本好的多，也会有用户高声喊：给我老版本。这和小丑的故事一样了，哪怕整容帅的像郭德纲一样，女子照样甩一甩衣袖走了。</p>

<p>现实生活中的重构往往是程序员自己发起的，Martin Fowler都有一本书起名为《重构》，并被许多程序员奉为圭臬。程序员的初衷是好的，但往往会低估重构的难度，项目越大耦合越多，往往牵一发而动全身，当老板跑过来问你进度时，你只能回以尴尬的笑，因为进度会进入无法掌控的地步。最近自己差点陷入这种进退维谷的境地，还好项目比较小，最后算是挺了过来。</p>

<p>但大的项目移筋动骨的重构就真的很难成功了。记得在核新软件的时候，项目庞大臃肿，添加新功能困难，软件的开发与执行效率都很低。记得一段时间内，大家重构的呼声很高，不过最后不了了之，因为工程浩大、重构后的兼容性、重构后软件多长时间可以稳定、重构后版本的测试等等需要考虑的各种问题已不单单是几个开发可以掌控的了的。而同时产品的需求还是不会减少，因为产品根本不关心软件的技术架构、可靠性、可维护性等等。</p>

<p>产品不关心重构是正常的。确实，一个可以正常运行，用户没有太多投诉、谨慎的编码也不会出太大问题的项目为什么要重构呢？假如某地发现了一个煤矿，第一批人来开采，一年时间采掉了50%的煤; 第二批人来了，煤已不那么好采，必须小心谨慎的对待，因为矿难不断，不过还好花了两年时间采到了30%的煤; 第三批人来了，矿上留下的全是前人留下的坑，无处落脚，须将前面的坑填掉，才能保证采得到煤，先花费了三年填坑，最后又花了一年时间采到了10%的煤。软件开发也一样，软件的生命期有限，是否需要花费人力将软件重构的完美值得商榷，可能重构完成之日，为项目终结之时，留下完美的架构与设计又有何用呢？</p>

<p>既然程序员呼吁重构的理由是，项目代码难以维护，那为什么不从一开始写出易维护的代码？</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/archlinux-trim/">Linux下开启TRIM</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-06-28T21:55:12+00:00" pubdate data-updated="true">2014-06-28</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>新买得一块SSD，听说开启TRIM才能更好的发挥SSD的性能，Linux并没有默认开启TRIM，但开启还是比较简单。</p>

<p>首先要检测SSD是否支持TRIM:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo hdparm -I /dev/sda <span class="p">|</span> grep <span class="s2">&quot;TRIM supported&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果支持则会出现：&#8221;Data Set Management TRIM supported&#8221;</p>

<p>如果SSD支持TRIM, 则可以开启TRIM了, 这里介绍常用的两种方法。</p>

<h3>方法1：修改<a href="http://en.wikipedia.org/wiki/Fstab">fstab</a>, 添加discard属性</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo vim /etc/fstab
</span></code></pre></td></tr></table></div></figure>


<p>下面是我机器上fstab的配置</p>

<blockquote><p>UUID=27dd31b4-8aa4-4043-b921-540a312c056c       /               ext4            rw,relatime,data=ordered,<strong>discard</strong>        0 1</p>

<p>UUID=42f79958-0776-4b2f-8aa3-db827bf257b6       /home           ext4            rw,relatime,data=ordered,<strong>discard</strong>        0 2</p></blockquote>

<h3>方法2：使用fstrim定期执行trim任务</h3>

<p>以我用的archlinux为例，首先安装并运行<a href="http://en.wikipedia.org/wiki/Cron">cron</a>服务：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo pacman -S cronie
</span><span class='line'>sudo systemctl start cronie
</span><span class='line'>sudo systemctl <span class="nb">enable </span>cronie
</span></code></pre></td></tr></table></div></figure>


<p>然后创建一个任务配置:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo gedit /etc/cron.daily/trim
</span></code></pre></td></tr></table></div></figure>


<p>并将下面的内容拷贝到里面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'><span class="nv">LOG</span><span class="o">=</span>/var/log/trim.log
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;*** $(date -R) ***&quot;</span> &gt;&gt; <span class="nv">$LOG</span>
</span><span class='line'>fstrim -v / &gt;&gt; <span class="nv">$LOG</span>
</span><span class='line'>fstrim -v /home &gt;&gt; <span class="nv">$LOG</span>
</span></code></pre></td></tr></table></div></figure>


<p>参考：</p>

<ol>
<li><p><a href="http://www.webupd8.org/2013/01/enable-trim-on-ssd-solid-state-drives.html">http://www.webupd8.org/2013/01/enable-trim-on-ssd-solid-state-drives.html</a></p></li>
<li><p><a href="https://wiki.archlinux.org/index.php/Solid_State_Drives">https://wiki.archlinux.org/index.php/Solid_State_Drives</a></p></li>
</ol>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/12/07/windbg-dump-asso/">Windbg关联dmp文件</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/22/windbg-memory-leak/">Windbg定位内存泄露的一种简单方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/15/api-design-for-c-plus-plus-notes/">C++API设计 - 笔记</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/26/shop-class-as-soulcraft-notes/">读《摩托车修理店的未来工作哲学》</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/31/24-hour-stand-by/">互联网公司“24小时待命”的陋习</a>
      </li>
    
  </ul>
</section>
<section>
  <h2>文章分类</h2>
    <ul id="category-list"><li><a href='/blog/categories/blog'>blog (1)</a></li><li><a href='/blog/categories/c-plus-plus'>c++ (18)</a></li><li><a href='/blog/categories/c-plus-plus-11'>c++11 (7)</a></li><li><a href='/blog/categories/c-plus-plus-14'>c++14 (1)</a></li><li><a href='/blog/categories/linux'>linux (2)</a></li><li><a href='/blog/categories/octopress'>octopress (2)</a></li><li><a href='/blog/categories/openshift'>openshift (1)</a></li><li><a href='/blog/categories/python'>python (1)</a></li><li><a href='/blog/categories/ruby'>ruby (1)</a></li><li><a href='/blog/categories/windbg'>windbg (1)</a></li><li><a href='/blog/categories/windows'>windows (7)</a></li><li><a href='/blog/categories/shu-xie'>书写 (1)</a></li><li><a href='/blog/categories/chan-pin'>产品 (1)</a></li><li><a href='/blog/categories/ren-sheng-gui-ji'>人生轨迹 (1)</a></li><li><a href='/blog/categories/hui-yi'>回忆 (5)</a></li><li><a href='/blog/categories/gong-zuo'>工作 (2)</a></li><li><a href='/blog/categories/gong-ju'>工具 (1)</a></li><li><a href='/blog/categories/bing-fa'>并发 (1)</a></li><li><a href='/blog/categories/zong-jie'>总结 (3)</a></li><li><a href='/blog/categories/cheng-xu-ren-sheng'>程序人生 (12)</a></li><li><a href='/blog/categories/xing-dong'>行动 (1)</a></li><li><a href='/blog/categories/ji-lu'>记录 (2)</a></li><li><a href='/blog/categories/du-shu'>读书 (1)</a></li><li><a href='/blog/categories/du-hou-gan'>读后感 (4)</a></li><li><a href='/blog/categories/yue-du'>阅读 (6)</a></li></ul>
</section>
<section>
  <h2>每日必读</h2>
   <ul>
    <li>
    <a href="http://news.ycombinator.com/">Hacker News</a>
    </li>
    <li>
    <a href="http://www.reddit.com/r/programming/">/r/programming</a>
    </li>
   </ul>
  <h2>关注博客</h2>
  <ul>
    <li>
      <a href="http://coolshell.cn/">酷壳</a>
    </li>
    <li>
      <a href="http://mindhacks.cn/">Mind Hacks</a>
    </li>
  </ul>
  <h2>友情链接</h2>
  <ul>
    <li>
      <a href="http://bestcbooks.com">计算机书籍控</a>
    </li>
  </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - ToWriting <br/>
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a>, customized with <a href="https://github.com/mjhea0/whiterspace">whiterspace</a>.</span>
</p>

<p>
  <span class="credit">本站内容采用<a rel="license" href="http://creativecommons.org/licenses/by/3.0/cn/">知识共享署名 3.0 中国大陆许可协议</a>进行许可</span>
</p></footer>
  











</body>
</html>
