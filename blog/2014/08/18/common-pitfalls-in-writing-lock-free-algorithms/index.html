<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>实现无锁算法的常见陷阱 - 书写|记下人生痕迹</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="bugliu" /><meta name="description" content="实现无锁算法的常见陷阱" /><meta name="keywords" content="阅读, 思考, 书写, 程序员, C&#43;&#43;" />






<meta name="generator" content="Hugo 0.88.1 with theme even" />


<link rel="canonical" href="http://towriting.com/blog/2014/08/18/common-pitfalls-in-writing-lock-free-algorithms/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.154ed883776547b0e136be39b3037f61350da06f888d0868d1756a9463cd9520.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="实现无锁算法的常见陷阱" />
<meta property="og:description" content="实现无锁算法的常见陷阱" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://towriting.com/blog/2014/08/18/common-pitfalls-in-writing-lock-free-algorithms/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2014-08-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2014-08-18T00:00:00+00:00" />

<meta itemprop="name" content="实现无锁算法的常见陷阱">
<meta itemprop="description" content="实现无锁算法的常见陷阱"><meta itemprop="datePublished" content="2014-08-18T00:00:00+00:00" />
<meta itemprop="dateModified" content="2014-08-18T00:00:00+00:00" />
<meta itemprop="wordCount" content="3864">
<meta itemprop="keywords" content="无锁编程," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="实现无锁算法的常见陷阱"/>
<meta name="twitter:description" content="实现无锁算法的常见陷阱"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">towriting</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/blog/2013/07/20/the-books-i-have-read">
        <li class="mobile-menu-item">Books</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">towriting</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/blog/2013/07/20/the-books-i-have-read">Books</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">实现无锁算法的常见陷阱</h1>

      <div class="post-meta">
        <span class="post-time"> 2014-08-18 </span>
        <div class="post-category">
            <a href="/categories/%E7%BF%BB%E8%AF%91/"> 翻译 </a>
            </div>
          <span class="more-meta"> 3864 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#翻译自common-pitfalls-in-writing-lock-free-algorithms1">翻译自：<a href="http://blog.memsql.com/common-pitfalls-in-writing-lock-free-algorithms/">Common Pitfalls in Writing Lock-Free Algorithms</a></a>
          <ul>
            <li><a href="#segfault">Segfault</a></li>
            <li><a href="#corruption">Corruption</a></li>
            <li><a href="#not-lock-free">Not lock-free</a></li>
            <li><a href="#data-races">Data races</a></li>
            <li><a href="#memory-reordering">Memory reordering</a></li>
            <li><a href="#segfault-1">Segfault</a></li>
            <li><a href="#corruption-1">Corruption</a></li>
            <li><a href="#not-lock-free-1">Not lock-free</a></li>
            <li><a href="#data-races-1">Data races</a></li>
            <li><a href="#memory-reordering-1">Memory reordering</a></li>
          </ul>
        </li>
        <li><a href="#结果">结果</a></li>
        <li><a href="#结论">结论</a></li>
        <li><a href="#代码">代码</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="翻译自common-pitfalls-in-writing-lock-free-algorithms1">翻译自：<a href="http://blog.memsql.com/common-pitfalls-in-writing-lock-free-algorithms/">Common Pitfalls in Writing Lock-Free Algorithms</a></h2>
<p>通常，只要两个操作之间的步骤是有穷的，一个多线程算法就认为可以实现为无锁(lock-free)。理论上无锁算法也早已被证明，看起来实现一个无锁算法也很简单。但其实不然，每一步都隐藏着陷阱：并发的线程可以修改共享的对象，甚至在执行一个操作时线程可以突然暂停或中止，而这是另一个线程当作好像若无其事。</p>
<p>线程同步是多线程程序设计的核心，传统的做法上就是代码临界区上加锁。锁可以防止多个线程同一时间进入临界区代码。在高度并发的程序里，锁可能成为严重的性能瓶颈。无锁编程的目标是不用锁也能解决并发问题。无锁编程一般依赖的是原子操作，比如“compare-and-swap”<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>原子的执行下面的操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="mi">1</span> <span class="kt">bool</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="n">Value</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">Value</span> <span class="n">oldVal</span><span class="p">,</span> <span class="n">Value</span> <span class="n">newVal</span><span class="p">){</span>
<span class="mi">2</span>     <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span> <span class="o">==</span> <span class="n">oldVal</span><span class="p">){</span>
<span class="mi">3</span>         <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">newVal</span><span class="p">;</span>
<span class="mi">4</span>         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">5</span>     <span class="p">}</span><span class="k">else</span><span class="p">{</span>
<span class="mi">6</span>         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">7</span>     <span class="p">}</span>
<span class="mi">8</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用无锁算法的最大缺陷是：</p>
<ul>
<li>无锁算法并不总是可实现的</li>
<li>无锁算法的代码很难写</li>
<li>写出正确的无锁算法代码更是难如登天</li>
</ul>
<p>为了证明以上三点，我们来看一个错误实现的一个无锁栈(lock-free stack)，可能大部分人第一次都会写出这样保护这些错误无锁栈。这个无锁栈算法主要是使用一个链表(linked-list)来存放节点，并用<code>CompareAndSwap</code>来修改链表的表头。 Push一个元素时，我们首先创建一个节点保存数据，并将这个节点设为栈顶，并使用<code>CompareAndSwap</code>将原栈顶指向新的元素。<code>CompareAndSwap</code>操作保证只有我们的新节点指向老的栈顶节点，才会替换老的栈顶（因为多线程可能改变老的栈顶）。当Pop一个元素时，我们快照当前的栈顶节点，然后替换当前的栈顶节点到下一个节点。我们再一次使用<code>CompareAndSwap</code>保证替换的节点等于快照的节点。</p>
<p>C++代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp">
 <span class="mi">1</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Entry</span><span class="o">&gt;</span>
 <span class="mi">2</span> <span class="k">class</span> <span class="nc">LockFreeStack</span><span class="p">{</span>
 <span class="mi">3</span>     <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
 <span class="mi">4</span>         <span class="n">Entry</span><span class="o">*</span> <span class="n">entry</span><span class="p">;</span>
 <span class="mi">5</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
 <span class="mi">6</span>     <span class="p">};</span>
 <span class="mi">7</span> 
 <span class="mi">8</span>     <span class="n">Node</span><span class="o">*</span> <span class="n">m_head</span><span class="p">;</span>
 <span class="mi">9</span> 
<span class="mi">10</span>     <span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">Entry</span><span class="o">*</span> <span class="n">e</span><span class="p">){</span>
<span class="mi">11</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span>
<span class="mi">12</span>         <span class="n">n</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
<span class="mi">13</span>         <span class="k">do</span><span class="p">{</span>
<span class="mi">14</span>             <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">;</span>
<span class="mi">15</span>         <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_head</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
<span class="mi">16</span>     <span class="p">}</span>
<span class="mi">17</span> 
<span class="mi">18</span>     <span class="n">Entry</span><span class="o">*</span> <span class="nf">Pop</span><span class="p">(){</span>
<span class="mi">19</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">old_head</span><span class="p">;</span>
<span class="mi">20</span>         <span class="n">Entry</span><span class="o">*</span> <span class="n">result</span><span class="p">;</span>
<span class="mi">21</span>         <span class="k">do</span><span class="p">{</span>
<span class="mi">22</span>             <span class="n">old_head</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">;</span>
<span class="mi">23</span>             <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
<span class="mi">24</span>                 <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="mi">25</span>             <span class="p">}</span>
<span class="mi">26</span>         <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_head</span><span class="p">,</span> <span class="n">old_head</span><span class="p">,</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
<span class="mi">27</span> 
<span class="mi">28</span>         <span class="n">result</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
<span class="mi">29</span>         <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>
<span class="mi">30</span>         <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="mi">31</span>     <span class="p">}</span>
<span class="mi">32</span> <span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>遗憾的是，这个无锁栈充满的错误：</p>
<h3 id="segfault">Segfault</h3>
<p>Push操作分配内存保存节点信息，Pop操作释放这些内存。然而，线程T1在顺序执行22行和26行之间的时间里，另一个线程T2可能已经释放了这个节点，然后程序Crash了。</p>
<h3 id="corruption">Corruption</h3>
<p>仅仅对比新值与老值是否相等，<code>CompareAndSwap</code>方法并不能保证是否值发生了变化。假如快照在22行的值，被修改了，然后又被恢复了，然后<code>CompareAndSwap</code>会成功。这就是著名的<strong>ABA问题</strong>。假如栈中前两个节点是A和C，如果以下面的序列操作：</p>
<ul>
<li>线程1执行Pop，并在22行读到了m_head(<strong>A</strong>)，在26行读到了old_head-&gt;next(<strong>C</strong>)，然后突然阻塞在执行在<code>CompareAndSwap</code>之前。</li>
<li>线程2执行pop，删掉节点<strong>A</strong>。</li>
<li>线程2调用push，push了一个新节点<strong>B</strong>。</li>
<li>线程2又调用一次push，这次push的新节点正好占用了原来节点<strong>A</strong>的内存。</li>
<li>线程1被唤醒，调用<code>CompareAndSwap</code>。</li>
</ul>
<p>然后26行的<code>CompareAndSwap</code>会成功，虽然m_head已经被改变3次了，因为它只检测old_head是否等于m_head。这是有问题的，因为新的栈顶本应指向<strong>B</strong>，然而却指向了<strong>C</strong>。</p>
<h3 id="not-lock-free">Not lock-free</h3>
<p>C++标准并不保证new和delete是lock-free的。一个无锁的数据结构去调用非无锁的库函数不是什么好主意，所以我们需要一个无锁的内存分配子。</p>
<h3 id="data-races">Data races</h3>
<p>当一个线程向内存中写入数据，而另一个线程同时从相同的内存读数据时，所产生的结果是未定义的，除非使用std::atomic。读和写操作都必须是原子的。在C++11以前一个通用的方法是使用<strong>volatile</strong>关键字来生命原子变量，然而这个关键字有很大的<a href="http://software.intel.com/en-us/blogs/2007/11/30/volatile-almost-useless-for-multi-threaded-programming">缺陷</a>。</p>
<p>在我们的例子中，多个线程读栈顶指针可能会引起竞争，push和pop操作都有可能，因为其它线程可能在修改他。</p>
<h3 id="memory-reordering">Memory reordering</h3>
<p>印象中，代码会按照我们指定的顺序执行，最少也会满足”<a href="http://en.wikipedia.org/wiki/Happened-before">happens before</a>“关系。不幸的是，不管理论还是实际上，下面代码的执行可能出现x,y都是0的结果。:</p>
<div class='align-center'>
<p><img src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/memory-reordering.png" alt="image"></p>
</div>
<p>C++11以前标准对于多线程是讳莫如深的，所以编译器的优化是着眼于单线程的。上面的代码，交换执行顺序，并不会影响单线程中程序的语义。所以可能会产生这种结果。</p>
<p>##如何写正确的lock-free栈</p>
<p>上面大部分问题都有多种解决方案，这里我会把自己工作中使用的方法描述出来。</p>
<h3 id="segfault-1">Segfault</h3>
<p>解引用节点之前，必须确保该节点没有被删掉。每一个线程都有一个全局可见的&quot;hazard pointer&quot;。当访问一个节点之前，会先设置Hazard pointer执行这个节点。只要设置过Hazard pointer就可以保证这个节点此时还是栈顶节点。如果其它线程此时移除这个栈顶节点，要检测没有Hazard pointer指向这个节点才能清除节点的内存。</p>
<h3 id="corruption-1">Corruption</h3>
<p>解决ABA问题的一个方法是确保栈顶不会有同样的值两次。我们使用“tagged pointers”来确保栈头值的唯一。一个“tagged pointers”包含一个指针和64位计数器。每当栈顶变化，计数器加一。</p>
<h3 id="not-lock-free-1">Not lock-free</h3>
<h3 id="data-races-1">Data races</h3>
<p>我们目前使用的是boost::atomic。现在我们使用gcc4.6也已经支持std::atomic，但实现的效率没有boost高。在gcc4.6中，所有需要原子操作的地方都被应用了memory barriers，即使本不必使用的地方。</p>
<h3 id="memory-reordering-1">Memory reordering</h3>
<p>C++11为原子操作提供了一种新的内存模型和内存序语义，以解决乱序的问题。CompareAndSwap需要顺序一致性(sequentially consistent)的语义保证。顺序一致性意味着所有的线程以一种一致的次序执行操作。事实证明hazard pointers也一样需要顺序一致性保证内存语义。
如果不使用内存一致性，下面这种情况下会有问题：</p>
<ul>
<li>线程1准备Pop操作，读取了栈顶节点</li>
<li>线程1将当前节点写到hazard pointer中</li>
<li>线程1再次读取栈顶指针</li>
<li>线程2将栈顶指针移走，并传递到垃圾收集线程</li>
<li>垃圾收集器扫描所有的hazard pointer节点，因为没有顺序一致性，可能看不到线程1的hazard pointer已经指向了这个节点</li>
<li>垃圾收集器删除了这个节点</li>
<li>线程1解引用这个节点，然后程序Crash</li>
</ul>
<p>而如果有顺序一致性应用到hazard pointer的赋值和节点的修改，竞争就不会发生了。因为任意两个操作，所有线程看到的顺序都是一样的。如果线程2先移除这个节点，那么线程1第二次读时会看到一个不同的节点，也就不会去解引用它。假如线程1先将节点写到hazard pointer中，则垃圾收集器肯定可以看到这个值而不会去删除它。</p>
<p>##性能
到现在我们解决了所有的问题。让我们看一下性能。测试使用的是一台8核Intel(R) Xeon(R) 处理器。每个线程的工作是随机的执行数量几乎相等的Push和Pop操作。每个线程不加限制的执行机器可以处理的操作。</p>
<div class='align-center'>
<p><img src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/chart.svg" alt="image"></p>
</div>
<p>我们修改栈顶的次数越多，CompareAndSwap失败的次数也会越多。一个简单有效的减少失败的方法是失败后Sleep一下，这可以调节Stack可以高效的处理数据。下面是每次失败后Sleep(250)的数据：</p>
<div class='align-center'>
<p><img src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/chart1.svg" alt="image"></p>
</div>
<p>太好了，增加Sleep后栈的吞吐量增加了7倍。并且Sleep减少的处理器的消耗。让我们看一下处理器的使用情况：</p>
<p>加锁的栈：</p>
<div class='align-center'>
<p><img src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/htop_mutex.png" alt="image"></p>
</div>
<p>无锁的栈，不加Sleep:</p>
<div class='align-center'>
<p><img src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/htop_lockfree.png" alt="image"></p>
</div>
<p>无锁的栈，Sleep(250):</p>
<div class='align-center'>
<p><img src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/htop_usleep.png" alt="image"></p>
</div>
<p>看起来无锁更好？等等，锁一样可以达到好的性能，我们不用std::mutex，我们使用Sleep(250)的自旋锁：</p>
<div class='align-center'>
<p><img src="/images/posts/common-pitfalls-in-writing-lock-free-algorithms/chart2.svg" alt="image"></p>
</div>
<h2 id="结果">结果</h2>
<p>大量数据时，额外的线程会降低吞吐量。Sleep可以降低操作冲突，增加吞吐量的同时减小处理器消耗。3个线程以上的性能没有变化。单线程是性能最佳的。</p>
<h2 id="结论">结论</h2>
<p>无锁不会阻碍进度，但也并不会提高效率。当你想在你的项目中使用无锁算法时，切记要衡量值不值的-性能还有复杂度。</p>
<h2 id="代码">代码</h2>
<p>加锁的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"> <span class="mi">1</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span>
 <span class="mi">2</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stack</span><span class="o">&gt;</span>
 <span class="mi">3</span> 
 <span class="mi">4</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
 <span class="mi">5</span> <span class="k">class</span> <span class="nc">LockedStack</span><span class="p">{</span>
 <span class="mi">6</span> <span class="k">public</span><span class="o">:</span>
 <span class="mi">7</span>     <span class="kt">void</span> <span class="n">Push</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">entry</span><span class="p">){</span>
 <span class="mi">8</span>         <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
 <span class="mi">9</span>         <span class="n">m_stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="mi">10</span>     <span class="p">}</span>
<span class="mi">11</span> 
<span class="mi">12</span>     <span class="c1">// For compatability with the LockFreeStack interface,
</span><span class="c1"></span><span class="mi">13</span>     <span class="c1">// add an unused int parameter.
</span><span class="c1"></span><span class="mi">14</span>     <span class="c1">//
</span><span class="c1"></span><span class="mi">15</span>     <span class="n">T</span><span class="o">*</span> <span class="n">Pop</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
<span class="mi">16</span>         <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
<span class="mi">17</span>         <span class="nf">if</span><span class="p">(</span><span class="n">m_stack</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
<span class="mi">18</span>             <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="mi">19</span>         <span class="p">}</span>
<span class="mi">20</span>         <span class="n">T</span><span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">m_stack</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<span class="mi">21</span>         <span class="n">m_stack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="mi">22</span>         <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="mi">23</span>     <span class="p">}</span>
<span class="mi">24</span> 
<span class="mi">25</span> <span class="k">private</span><span class="o">:</span>
<span class="mi">26</span>     <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">m_stack</span><span class="p">;</span>
<span class="mi">27</span>     <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_mutex</span><span class="p">;</span>
<span class="mi">28</span> <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>Lock-Free的：
(垃圾收集相关的代码没贴出来）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"> <span class="mi">1</span> <span class="k">class</span> <span class="nc">LockFreeStack</span><span class="p">{</span>
 <span class="mi">2</span> <span class="k">public</span><span class="o">:</span>
 <span class="mi">3</span>     <span class="c1">// The elements we wish to store should inherit Node
</span><span class="c1"></span> <span class="mi">4</span>     <span class="c1">//
</span><span class="c1"></span> <span class="mi">5</span>     <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
 <span class="mi">6</span>         <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">next</span><span class="p">;</span>
 <span class="mi">7</span>     <span class="p">};</span>
 <span class="mi">8</span> 
 <span class="mi">9</span>     <span class="c1">// Unfortunately, there is no platform independent way to
</span><span class="c1"></span><span class="mi">10</span>     <span class="c1">// define this class.  The following definition works in
</span><span class="c1"></span><span class="mi">11</span>     <span class="c1">// gcc on x86_64 architectures
</span><span class="c1"></span><span class="mi">12</span>     <span class="c1">//
</span><span class="c1"></span><span class="mi">13</span>     <span class="k">class</span> <span class="nc">TaggedPointer</span><span class="p">{</span>
<span class="mi">14</span>     <span class="k">public</span><span class="o">:</span>
<span class="mi">15</span>         <span class="n">TaggedPointer</span><span class="p">()</span><span class="o">:</span> <span class="n">m_node</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">m_counter</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="mi">16</span> 
<span class="mi">17</span>         <span class="n">Node</span><span class="o">*</span> <span class="nf">GetNode</span><span class="p">(){</span>
<span class="mi">18</span>             <span class="k">return</span> <span class="n">m_node</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
<span class="mi">19</span>         <span class="p">}</span>
<span class="mi">20</span> 
<span class="mi">21</span>         <span class="kt">uint64_t</span> <span class="nf">GetCounter</span><span class="p">(){</span>
<span class="mi">22</span>             <span class="k">return</span> <span class="n">m_counter</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
<span class="mi">23</span>         <span class="p">}</span>
<span class="mi">24</span> 
<span class="mi">25</span>         <span class="kt">bool</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">oldNode</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">oldCounter</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">newCounter</span><span class="p">){</span>
<span class="mi">26</span>             <span class="kt">bool</span> <span class="n">cas_result</span><span class="p">;</span>
<span class="mi">27</span>             <span class="n">__asm__</span> <span class="n">__volatile__</span>
<span class="mi">28</span>             <span class="p">(</span>
<span class="mi">29</span>                 <span class="s">&#34;lock;&#34;</span>           <span class="c1">// This makes the following instruction atomic (it is non-blocking)
</span><span class="c1"></span><span class="mi">30</span>                 <span class="s">&#34;cmpxchg16b %0;&#34;</span>  <span class="c1">// cmpxchg16b sets ZF on success
</span><span class="c1"></span><span class="mi">31</span>                 <span class="s">&#34;setz       %3;&#34;</span>  <span class="c1">// if ZF set, set cas_result to 1
</span><span class="c1"></span><span class="mi">32</span> 
<span class="mi">33</span>                 <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="s">&#34;+a&#34;</span> <span class="p">(</span><span class="n">oldNode</span><span class="p">),</span> <span class="s">&#34;+d&#34;</span> <span class="p">(</span><span class="n">oldCounter</span><span class="p">),</span> <span class="s">&#34;=q&#34;</span> <span class="p">(</span><span class="n">cas_result</span><span class="p">)</span>
<span class="mi">34</span>                 <span class="o">:</span> <span class="s">&#34;b&#34;</span> <span class="p">(</span><span class="n">newNode</span><span class="p">),</span> <span class="s">&#34;c&#34;</span> <span class="p">(</span><span class="n">newCounter</span><span class="p">)</span>
<span class="mi">35</span>                 <span class="o">:</span> <span class="s">&#34;cc&#34;</span><span class="p">,</span> <span class="s">&#34;memory&#34;</span>
<span class="mi">36</span>             <span class="p">);</span>
<span class="mi">37</span>             <span class="k">return</span> <span class="n">cas_result</span><span class="p">;</span>
<span class="mi">38</span>         <span class="p">}</span>
<span class="mi">39</span>     <span class="k">private</span><span class="o">:</span>
<span class="mi">40</span>         <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">m_node</span><span class="p">;</span>
<span class="mi">41</span>         <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">m_counter</span><span class="p">;</span>
<span class="mi">42</span>     <span class="p">}</span>
<span class="mi">43</span>     <span class="c1">// 16-byte alignment is required for double-width
</span><span class="c1"></span><span class="mi">44</span>     <span class="c1">// compare and swap
</span><span class="c1"></span><span class="mi">45</span>     <span class="c1">//
</span><span class="c1"></span><span class="mi">46</span>     <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
<span class="mi">47</span> 
<span class="mi">48</span>     <span class="kt">bool</span> <span class="nf">TryPushStack</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">entry</span><span class="p">){</span>
<span class="mi">49</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
<span class="mi">50</span>         <span class="kt">uint64_t</span> <span class="n">oldCounter</span><span class="p">;</span>
<span class="mi">51</span> 
<span class="mi">52</span>         <span class="n">oldHead</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetNode</span><span class="p">();</span>
<span class="mi">53</span>         <span class="n">oldCounter</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetCounter</span><span class="p">();</span>
<span class="mi">54</span>         <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
<span class="mi">55</span>         <span class="k">return</span> <span class="n">m_head</span><span class="p">.</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">oldCounter</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">oldCounter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">56</span>     <span class="p">}</span>
<span class="mi">57</span> 
<span class="mi">58</span>     <span class="kt">bool</span> <span class="nf">TryPopStack</span><span class="p">(</span><span class="n">Node</span><span class="o">*&amp;</span> <span class="n">oldHead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threadId</span><span class="p">){</span>
<span class="mi">59</span>         <span class="n">oldHead</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetNode</span><span class="p">();</span>
<span class="mi">60</span>         <span class="kt">uint64_t</span> <span class="n">oldCounter</span> <span class="o">=</span> <span class="n">m_head</span><span class="p">.</span><span class="n">GetCounter</span><span class="p">();</span>
<span class="mi">61</span>         <span class="k">if</span><span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">){</span>
<span class="mi">62</span>             <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">63</span>         <span class="p">}</span>
<span class="mi">64</span>         <span class="n">m_hazard</span><span class="p">[</span><span class="n">threadId</span><span class="o">*</span><span class="mi">8</span><span class="p">].</span><span class="n">store</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
<span class="mi">65</span>         <span class="k">if</span><span class="p">(</span><span class="n">m_head</span><span class="p">.</span><span class="n">GetNode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">oldHead</span><span class="p">){</span>
<span class="mi">66</span>             <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">67</span>         <span class="p">}</span>
<span class="mi">68</span>         <span class="k">return</span> <span class="n">m_head</span><span class="p">.</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">oldCounter</span><span class="p">,</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">),</span> <span class="n">oldCounter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="mi">69</span>     <span class="p">}</span>
<span class="mi">70</span> 
<span class="mi">71</span>     <span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">entry</span><span class="p">){</span>
<span class="mi">72</span>         <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
<span class="mi">73</span>             <span class="k">if</span><span class="p">(</span><span class="n">TryPushStack</span><span class="p">(</span><span class="n">entry</span><span class="p">)){</span>
<span class="mi">74</span>                 <span class="k">return</span><span class="p">;</span>
<span class="mi">75</span>             <span class="p">}</span>
<span class="mi">76</span>             <span class="n">usleep</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
<span class="mi">77</span>         <span class="p">}</span>
<span class="mi">78</span>     <span class="p">}</span>
<span class="mi">79</span> 
<span class="mi">80</span>     <span class="n">Node</span><span class="o">*</span> <span class="nf">Pop</span><span class="p">(</span><span class="kt">int</span> <span class="n">threadId</span><span class="p">){</span>
<span class="mi">81</span>         <span class="n">Node</span><span class="o">*</span> <span class="n">res</span><span class="p">;</span>
<span class="mi">82</span>         <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
<span class="mi">83</span>             <span class="k">if</span><span class="p">(</span><span class="n">TryPopStack</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">threadId</span><span class="p">)){</span>
<span class="mi">84</span>                 <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="mi">85</span>             <span class="p">}</span>
<span class="mi">86</span>             <span class="n">usleep</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
<span class="mi">87</span>         <span class="p">}</span>
<span class="mi">88</span>     <span class="p">}</span>
<span class="mi">89</span> 
<span class="mi">90</span> <span class="k">private</span><span class="o">:</span>
<span class="mi">91</span>     <span class="n">TaggedPointer</span> <span class="n">m_head</span><span class="p">;</span>
<span class="mi">92</span>     <span class="c1">// Hazard pointers are separated into different cache lines to avoid contention
</span><span class="c1"></span><span class="mi">93</span>     <span class="c1">//
</span><span class="c1"></span><span class="mi">94</span>     <span class="n">boost</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">m_hazard</span><span class="p">[</span><span class="n">MAX_THREADS</span><span class="o">*</span><span class="mi">8</span><span class="p">];</span>
<span class="mi">95</span> <span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>硬件相关，Windows已提供函数InterlockedCompareExchange&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

    </div>

    <div class="post-copyright">
  
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license" href="http://creativecommons.org/licenses/by/3.0/cn/">知识共享署名 3.0 中国大陆许可协议</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B/">无锁编程</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/blog/2014/08/25/cpp-14-dessert/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43;14-大餐后的甜点</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/blog/2014/07/21/review-xzjy/">
            <span class="next-text nav-default">读《寻找家园》</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="http://towriting.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2013 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>bugliu 2020</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-42601840-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
