<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Windows | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/windows/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2013-09-29T17:30:47+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[创建支持拖拽的进程]]></title>
    <link href="http://towriting.com/blog/2013/08/06/process-can-drag-drop/"/>
    <updated>2013-08-06T22:48:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/06/process-can-drag-drop</id>
    <content type="html"><![CDATA[<p>Win7下管理员权限的进程一般不支持拖拽，除非启动一个管理员权限的Explorer。前一段时间，同事给我提出一个需求：管理员权限进程创建非管理员权限进程，方法很简单，见前面的文章：<a href="/blog/2013/07/31/de-elevate-start-process/">降权启动进程</a>。</p>

<p>而后的一次交谈，才知道同事的真正目的是，创建出的进程支持拖拽。我只是创建出了非管理员的进程，而是否管理员与支持拖拽并没有直接联系，决定拖拽的是<strong>User Interface Privilege Isolation</strong> (<a href="http://en.wikipedia.org/wiki/User_Interface_Privilege_Isolation">UIPI</a>)特性。</p>

<p>根据UIPI，低Integrity的进程无法向高Integrity的进程发送任意消息，这导致高Integrity看起来不支持拖拽。所以要使创建的进程支持拖拽，要满足Integrity低于或等于Explorer进程的Integrity值。</p>

<p>前面文章<a href="/blog/2013/07/31/de-elevate-start-process/">降权启动进程</a>中，我们通过函数CreateNormalUserToken取得了受限的Token，只要修改此Token的Integrity即可使创建的进程拥有合适的Integrity，我们实现一个修改TokenIntegrity值的函数：
```cpp
BOOL ChangeTokenIntegrity(HANDLE &amp;hToken)
{</p>

<pre><code>SID_IDENTIFIER_AUTHORITY MLAuthority = SECURITY_MANDATORY_LABEL_AUTHORITY;  
PSID pIntegritySid = NULL;  
if (!AllocateAndInitializeSid(&amp;MLAuthority, 1, SECURITY_MANDATORY_MEDIUM_RID, 
                              0, 0, 0, 0, 0, 0, 0, &amp;pIntegritySid))  
{   
    return FALSE;  
}  
TOKEN_MANDATORY_LABEL tml = {0};  
tml.Label.Attributes = SE_GROUP_INTEGRITY;  
tml.Label.Sid = pIntegritySid;

const BOOL bRet = SetTokenInformation(hToken, TokenIntegrityLevel, &amp;tml, 
                                      (sizeof(tml) + GetLengthSid(pIntegritySid)));  
if (pIntegritySid)  
{   
    FreeSid(pIntegritySid);  
}  
return bRet; 
</code></pre>

<p>}
```
上面第五行AllocateAndInitializeSid函数的第三个参数，这里取值SECURITY_MANDATORY_MEDIUM_RID是因为Explorer进程的Integrity一般是Medium。当然如果有必要也可以根据获取的Explorer进程的Integrity设置这个值。</p>

<p>参考：<a href="http://msdn.microsoft.com/en-us/library/bb625963.aspx">Windows Integrity Mechanism Design</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降权启动进程]]></title>
    <link href="http://towriting.com/blog/2013/07/31/de-elevate-start-process/"/>
    <updated>2013-07-31T22:01:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/31/de-elevate-start-process</id>
    <content type="html"><![CDATA[<p>Win7下有些进程需要以管理员权限启动，比如安装程序。但又需要这个具有管理员权限的进程启动一个非管理员权限的进程。要实现这一点，方法很简单，首先得到受限的Token，然后由这个Token调用<a href="http://msdn.microsoft.com/en-us/library/ms682429.aspx">CreateProcessAsUser</a>。</p>

<p>{% include_code  WIN7/VS2010 cpp/de_elevate_start_process.cpp %}</p>

<h3>需要创建出的进程支持拖拽的看这里：<a href="/blog/2013/08/06/process-can-drag-drop/">创建支持拖拽的进程</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[获取进程打开的互斥量]]></title>
    <link href="http://towriting.com/blog/2013/07/25/mutexs-owned-by-process/"/>
    <updated>2013-07-25T21:36:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/25/mutexs-owned-by-process</id>
    <content type="html"><![CDATA[<p>最近有个任务涉及到区分【同进程名进程】，所以想到了用进程"拥有"的互斥量来区分这些进程。所以下面实现了获取指定进程"拥有"哪些互斥量的方法，当然这种方法也适合各种内核对象（FILE、REG&hellip;)。</p>

<pre><code>1. 使用NtQuerySystemInformation检索SystemHandleInformation(16)即可获得系统中所有的句柄信息：
</code></pre>

<p>通过SystemHandleInformation检索到的系统中所有句柄的数据结构是这样定义的：
{% codeblock lang:cpp %}
typedef struct _SYSTEM_HANDLE_INFORMATION
{</p>

<pre><code>ULONG HandleCount; 
SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
</code></pre>

<p>} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;
{% endcodeblock%}</p>

<p>其中SYSTEM_HANDLE_TABLE_ENTRY_INFO是一个句柄信息的数据结构
{% codeblock lang:cpp %}
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{</p>

<pre><code>ULONG ProcessId;
BYTE ObjectTypeNumber;
BYTE Flags;
USHORT Handle;
PVOID Object;
ACCESS_MASK GrantedAccess;
</code></pre>

<p>} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;
{% endcodeblock%}</p>

<pre><code>2. 将句柄复制到当前进程
</code></pre>

<p>想要获取一个句柄的详细信息，必须将其拷贝到当前进程，对于一个句柄数据类型：SYSTEM_HANDLE_TABLE_ENTRY_INFO，我们可以使用其第四个成员Handle，然后使用DuplicateHandle将这个句柄复制到当前进程。</p>

<pre><code>3. 获取句柄的类型信息
</code></pre>

<p>由2中获取的复制到当前进程的句柄，调用函数NtQueryObject，指定获取ObjectNameInformation(1)即可获取句柄的类型信息，获取到的句柄的类型信息结构是这样的：
{% codeblock lang:cpp %}
typedef struct _OBJECT_TYPE_INFORMATION
{</p>

<pre><code>UNICODE_STRING TypeName;
ULONG TotalNumberOfObjects;
ULONG TotalNumberOfHandles;
ULONG TotalPagedPoolUsage;
ULONG TotalNonPagedPoolUsage;
ULONG TotalNamePoolUsage;
ULONG TotalHandleTableUsage;
ULONG HighWaterNumberOfObjects;
ULONG HighWaterNumberOfHandles;
ULONG HighWaterPagedPoolUsage;
ULONG HighWaterNonPagedPoolUsage;
ULONG HighWaterNamePoolUsage;
ULONG HighWaterHandleTableUsage;
ULONG InvalidAttributes;
GENERIC_MAPPING GenericMapping;
ULONG ValidAccessMask;
BOOLEAN SecurityRequired;
BOOLEAN MaintainHandleCount;
ULONG PoolType;
ULONG DefaultPagedPoolCharge;
ULONG DefaultNonPagedPoolCharge;
</code></pre>

<p>} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;
{% endcodeblock%}
其中第一个成员TypeName即是句柄类型的类型名</p>

<!--more-->


<pre><code>4. 获取句柄的名字
</code></pre>

<p>调用函数NtQueryObject，指定获取ObjectNameInformation即可获取句柄的类型信息，获取到的句柄的名字数据结构是UNICODE_STRING类型。</p>

<pre><code>5. 找到当前进程占有的互斥量
</code></pre>

<p>由获取的句柄的类型信息和句柄所在的进程ID，即可找到当前进程拥有的互斥量，同时我们也得到了互斥量的名字。</p>

<h3>完整代码如下：</h3>

<p>{% include_code  WIN7/VS2010 cpp/get_process_mutex.cpp %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smart GetProcAddress之实现]]></title>
    <link href="http://towriting.com/blog/2013/07/20/smart-getprocaddress/"/>
    <updated>2013-07-20T22:36:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/20/smart-getprocaddress</id>
    <content type="html"><![CDATA[<p>Windows下有过编程经验的朋友肯定用过这个函数：<a href="http://msdn.microsoft.com/en-us/library/ms683212%28v=vs.85%29.aspx">GetProcAddress</a>，作用呢，就是从加载的动态库中获取指定函数名的函数入口地址，函数使用方法简单，一般是如下流程：</p>

<p>{%codeblock DLL导出函数的头文件:dll.h lang:cpp%}
void WINAPI func1(int);
void WINAPI func2(int,int);
{%endcodeblock%}</p>

<p>{%codeblock 动态加载DLL调用上面两个函数 lang:cpp%}
typedef void (WINAPI <em>FUNC1)(int);
typedef void (WINAPI </em>FUNC2)(int,int);
FUNC1 func1 = (FUNC1)GetProcAddress(hDLL, <em>T(&ldquo;func1&rdquo;);
FUNC2 func2 = (FUNC2)GetProcAddress(hDLL, </em>T(&ldquo;func2&rdquo;);
func1(1);
func2(1, 2);
{%endcodeblock%}</p>

<p>以上是主流的代码写法，但其实稍有问题：
1. 要定义一套函数类型，且违反DRY，枯燥乏味，影响代码美观
2. 隐式类型转换是魔鬼，如果DLL实现变化，则调用出错，比如：
{%codeblock DLL导出函数的头文件：fun2的参数变成了三个，调用非出错不可 lang:cpp%}
void WINAPI func1(int);
void WINAPI func2(int,int,int);
{%endcodeblock%}</p>

<p>好，问题来了，如何避免：
{%codeblock 方案1：使用模板 lang:cpp%}
// 封装一个智能GetProcAddress
template<typename T>
T SmartGetProcAddress(HModule hModule, TChar* pFuncName, T)
{</p>

<pre><code>return (T)GetProcAddress(hModule, pFuncName);
</code></pre>

<p>}</p>

<p>// 使用方法如下：注意1. 要引用对应头文件，2. auto（自动类型推导）关键字从VS2010开始支持
auto func1 = SmartGetProcAddress(hDLL, _T(&ldquo;func1&rdquo;), &amp;func1);
{%endcodeblock%}
看起来我们解决了DRY问题，也不用写繁琐的typedef了，于是我们开始Build，很快你就发现Link错误，unresolved external symbol，没注意取地址&amp;func1，已静态依赖于DLL，看来此路不通。取地址的目的是从头文件中获取函数的类型，还有什么方法可以获取函数的类型呢？
{%codeblock 方案2：使用decltype lang:cpp%}
// 封装一个智能GetProcAddress
template<typename T>
T SmartGetProcAddress(HModule hModule, TChar* pFuncName)
{</p>

<pre><code>return (T)GetProcAddress(hModule, pFuncName);
</code></pre>

<p>}</p>

<p>// 使用方法如下：
auto func1 = SmartGetProcAddress&lt;decltype(func1)>(hDLL, _T(&ldquo;func1&rdquo;));
{%endcodeblock%}</p>

<p>使用decltype可以解决，函数取地址（&amp;)会静态依赖DLL问题，这里的关键是decltype(func1)这种写法的支持，最初这种写法在g++4.7测试是支持的，不过后来再VS2012、VS2010上测试好像都不支持，所以SmartGetProcAddress只能存在于理论阶段了。</p>
]]></content>
  </entry>
  
</feed>
