<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: windows | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/windows/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2015-09-10T23:46:30+00:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Windbg关联dmp文件]]></title>
    <link href="http://towriting.com/blog/2014/12/07/windbg-dump-asso/"/>
    <updated>2014-12-07T22:58:38+00:00</updated>
    <id>http://towriting.com/blog/2014/12/07/windbg-dump-asso</id>
    <content type="html"><![CDATA[<p>最近一段时间和Crash斗争，每天必不可少的事情是分析dump，每天少则分析几个，多则分析几十个是常有的。而打开dump到进入windbg cmd窗口输入!analyze -v命令是机械枯燥的事情。Windbg是没有默认关联.dmp文件的，只能自己动手了。分享关联方法之前，看下我现在dump文件的打开方式：</p>

<p>{% img /images/posts/windbg-dump-asso/windbg_dmp.png  %}</p>

<p>我设置了三种打开方式：</p>

<ul>
<li>直接使用Windbg打开dump</li>
<li>使用windbg打开dump并进行分析</li>
<li>使用windbg打开dump，切换到32位，然后分析（针对加载的wow64)</li>
</ul>


<h3>配置dmp关联的方法</h3>

<h4>1. 设置dmp文件的关联</h4>

<p>Windows下文件的关联指的是在explorer下，双击或通过右键打开文件时选择指定程序打开。文件的关联方式可以通过注册表进行配置，在HKEY_CLASSES_ROOT、HKEY_CURRENT_USER\Software\Classes、HKEY_LOCAL_MACHINE\Software\Classes有以 &ldquo;.文件格式&rdquo; 命名的键和另一个自定义的键里面保存具体的配置，用来配置这个文件格式的关联，比如我们要配置的dmp文件的关联，最终会是这样：
```
HKEY_CURRENT_USER\Software\Classes
   dmpfile</p>

<pre><code> DefaultIcon
   default = "C:\Program Files (x86)\Debugging Tools for Windows (x86)\windbg.exe",0
 shell
   Analyze with windbg
       command
          default=C:\Program Files (x86)\Debugging Tools for Windows (x86)\windbg.exe" -c "!analyze -v" -z "%1\"
   Analyze with windbg - wow64
       command
          default="C:\Program Files (x86)\Debugging Tools for Windows (x86)\windbg.exe" -c "!wow64exts.sw; !analyze -v" -z "%1"
   open
       command
          default="C:\Program Files (x86)\Debugging Tools for Windows (x86)\windbg.exe" -z "%1"
</code></pre>

<p>   .dmp</p>

<pre><code> default = dmpfile
</code></pre>

<p>```</p>

<p>当然，更改HKEY_CURRENT_USER是对当前用户有效，HKEY_LOCAL_MACHINE是对所有用户有效，而HKEY_CLASSES_ROOT是兼容的产物，不推荐在直接配置HKEY_CLASSES_ROOT。</p>

<h4>2. 去除用户自定义的打开方式-自定义程序</h4>

<p> 如果你设置过打开方式里面的自定义程序，必须先删除这一项，否则我们上一步设置的文件关联将不会生效，打开方式自定义程序的配置也是保存在注册表中，具体位置在：</p>

<p> <code>
 HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.dmp\UserChoice
</code></p>

<p>将这个UserChoice键删除即可。</p>

<h4>3. 到这里就讲完了，最后奉上一个bat:</h4>

<p>{% include_code script/windbg-dump-asso.bat %}</p>

<p>参考：</p>

<p><a href="http://msdn.microsoft.com/en-us/library/cc144158%28VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/cc144158%28VS.85%29.aspx</a></p>

<p><a href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff561306.aspx">http://msdn.microsoft.com/en-us/library/windows/hardware/ff561306.aspx</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows提供的INI接口不是线程安全的]]></title>
    <link href="http://towriting.com/blog/2013/12/17/ini-muti-thread/"/>
    <updated>2013-12-17T23:28:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/17/ini-muti-thread</id>
    <content type="html"><![CDATA[<p>INI是Windows系统下人们喜闻乐见的一种配置存储方式。Windows提供了一套简单的接口操作INI文件，但它们并不是线程安全的，对于这一点，这些函数比如<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms725501(v=vs.85).aspx">WritePrivateProfileString</a>的文档中并没有提到。
据<a href="http://mfctips.com/tag/getprivateprofilestring/">这篇文章</a>介绍:</p>

<h2>WritePrivateProfileString:</h2>

<ul>
<li>WritePrivateProfileString内部使用NtCreateFile访问文件，共享方式设置为：FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE。使用NtLockFile，FailImmediately设置为False，ExlusiveLock设置为True来锁定文件。</li>
<li>这意味着WritePrivateProfileString是非线程安全的，是进程安全的（非远程机器）。</li>
</ul>


<p>我们目前的软件有大量的并发操作INI的行为，没出现过什么问题只能说是幸运了（亦或是不幸）。同事并不太相信以上结论，让我们用事实证明，写一段并发操作INI的代码：</p>

<p>```cpp</p>

<h1>include &ldquo;stdafx.h&rdquo;</h1>

<h1>include &lt;Windows.h></h1>

<h1>include <vector></h1>

<h1>include <string></h1>

<h1>include &lt;process.h></h1>

<h1>include <cassert></h1>

<p>std::wstring GetIniName()
{</p>

<pre><code>std::wstring strIniName;
strIniName.resize(MAX_PATH);
strIniName.resize(GetModuleFileName(NULL, const_cast&lt;TCHAR*&gt;(strIniName.data()), strIniName.size()));
strIniName += _T(".ini");
return strIniName;
</code></pre>

<p>}</p>

<p>void WriteIniInThread(void* pText)
{</p>

<pre><code>const TCHAR *pSec = (TCHAR*)pText;
assert(pSec);

std::wstring strVal;
std::wstring strIni = GetIniName();
for (int i=0; i&lt;1000; ++i)
{
    strVal = std::to_wstring(_Longlong(i));
    WritePrivateProfileString(pSec, strVal.data(), strVal.data(), strIni.data());
}
</code></pre>

<p>}</p>

<p>int <em>tmain(int argc, </em>TCHAR* argv[])
{</p>

<pre><code>std::vector&lt;std::wstring&gt; threadTexts;
std::vector&lt;HANDLE&gt; threadHandles;
for (int i = 0; i&lt;60; ++i)
{
    std::wstring strText = _T("Thread");
    strText += std::to_wstring(_Longlong(i));
    threadTexts.push_back(strText);
    threadHandles.push_back(HANDLE(_beginthread(WriteIniInThread, 0, (void*)threadTexts[i].data())));
}

WaitForMultipleObjects(threadHandles.size(), threadHandles.data(), TRUE, INFINITE);
return 0;
</code></pre>

<p>}</p>

<p>```
代码很简单，开60个线程同时往一个INI文件里写东西，让我们对比一下多线程操作INI和非多线程操作的结果，左侧是不使用多线程操作的结果（只贴出前50行）：</p>

<p>{% img pull-left /images/posts/ini-muti-thread/result.png %}</p>

<p>{% img pull-left /images/posts/ini-muti-thread/error_result.png %}</p>

<p></br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br></p>

<p>结果一目了然。（多线程同时操作INI时，每次的结果可能都不一样的）。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建支持拖拽的进程]]></title>
    <link href="http://towriting.com/blog/2013/08/06/process-can-drag-drop/"/>
    <updated>2013-08-06T22:48:00+00:00</updated>
    <id>http://towriting.com/blog/2013/08/06/process-can-drag-drop</id>
    <content type="html"><![CDATA[<p>Win7下管理员权限的进程一般不支持拖拽，除非启动一个管理员权限的Explorer。前一段时间，同事给我提出一个需求：管理员权限进程创建非管理员权限进程，方法很简单，见前面的文章：<a href="/blog/2013/07/31/de-elevate-start-process/">降权启动进程</a>。</p>

<p>而后的一次交谈，才知道同事的真正目的是，创建出的进程支持拖拽。我只是创建出了非管理员的进程，而是否管理员与支持拖拽并没有直接联系，决定拖拽的是<strong>User Interface Privilege Isolation</strong> (<a href="http://en.wikipedia.org/wiki/User_Interface_Privilege_Isolation">UIPI</a>)特性。</p>

<p>根据UIPI，低Integrity的进程无法向高Integrity的进程发送任意消息，这导致高Integrity看起来不支持拖拽。所以要使创建的进程支持拖拽，要满足Integrity低于或等于Explorer进程的Integrity值。</p>

<p>前面文章<a href="/blog/2013/07/31/de-elevate-start-process/">降权启动进程</a>中，我们通过函数CreateNormalUserToken取得了受限的Token，只要修改此Token的Integrity即可使创建的进程拥有合适的Integrity，我们实现一个修改TokenIntegrity值的函数：
```cpp
BOOL ChangeTokenIntegrity(HANDLE &amp;hToken)
{</p>

<pre><code>SID_IDENTIFIER_AUTHORITY MLAuthority = SECURITY_MANDATORY_LABEL_AUTHORITY;  
PSID pIntegritySid = NULL;  
if (!AllocateAndInitializeSid(&amp;MLAuthority, 1, SECURITY_MANDATORY_MEDIUM_RID, 
                              0, 0, 0, 0, 0, 0, 0, &amp;pIntegritySid))  
{   
    return FALSE;  
}  
TOKEN_MANDATORY_LABEL tml = {0};  
tml.Label.Attributes = SE_GROUP_INTEGRITY;  
tml.Label.Sid = pIntegritySid;

const BOOL bRet = SetTokenInformation(hToken, TokenIntegrityLevel, &amp;tml, 
                                      (sizeof(tml) + GetLengthSid(pIntegritySid)));  
if (pIntegritySid)  
{   
    FreeSid(pIntegritySid);  
}  
return bRet; 
</code></pre>

<p>}
```
上面第五行AllocateAndInitializeSid函数的第三个参数，这里取值SECURITY_MANDATORY_MEDIUM_RID是因为Explorer进程的Integrity一般是Medium。当然如果有必要也可以根据获取的Explorer进程的Integrity设置这个值。</p>

<p>参考：<a href="http://msdn.microsoft.com/en-us/library/bb625963.aspx">Windows Integrity Mechanism Design</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[暴力禁止windows自动安装驱动]]></title>
    <link href="http://towriting.com/blog/2013/08/03/forbid-auto-install-driver/"/>
    <updated>2013-08-03T22:24:00+00:00</updated>
    <id>http://towriting.com/blog/2013/08/03/forbid-auto-install-driver</id>
    <content type="html"><![CDATA[<p>{% img right /images/posts/forbid-auto-install-driver/auto_install_driver_tip.png &lsquo;windows自动安装驱动&rsquo; &lsquo;windows系统有时候给人的感觉很智能，很勤快，比如插入一个手机，它会自动帮你安装上相应驱动（前提是它能找到对应驱动）。但这种殷勤的行为不是人人都需要的，而且这时候你又找不到制止这种行为的入口，你一定很窝火。&rsquo; %}</p>

<p>前两天我需要手动安装一个手机的根节点驱动，这个驱动属于系统基础驱动，所以一插入手机windows就帮你装上了，这不是我想要的。当我用遍了google、yahoo、ixquick、duckduckgo、baidu、soso各种搜索引擎仍然没有找到有效的禁用windows自动安装驱动的办法后，我只好尝试暴力对抗了。</p>

<p>很快用ProcessMonitor定位到安装驱动的进程：
{% img right /images/posts/forbid-auto-install-driver/auto_install_driver.png %}</p>

<p>不想让系统自动安装驱动，破坏drvinst进程就可以达到。写个简单的脚本，插入手机前跑起来就OK了（win7系统开启UAC则需管理员权限运行）：
{% include_code python/forbid_auto_install_driver.py %}
<strong>注意：</strong>如果破坏drvinst进程后发现系统对新插入的设备不再自动安装驱动，则设备管理器中扫描检测硬件改动即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降权启动进程]]></title>
    <link href="http://towriting.com/blog/2013/07/31/de-elevate-start-process/"/>
    <updated>2013-07-31T22:01:00+00:00</updated>
    <id>http://towriting.com/blog/2013/07/31/de-elevate-start-process</id>
    <content type="html"><![CDATA[<p>Win7下有些进程需要以管理员权限启动，比如安装程序。但又需要这个具有管理员权限的进程启动一个非管理员权限的进程。要实现这一点，方法很简单，首先得到受限的Token，然后由这个Token调用<a href="http://msdn.microsoft.com/en-us/library/ms682429.aspx">CreateProcessAsUser</a>。</p>

<p>{% include_code  WIN7/VS2010 cpp/de_elevate_start_process.cpp %}</p>

<h3>需要创建出的进程支持拖拽的看这里：<a href="/blog/2013/08/06/process-can-drag-drop/">创建支持拖拽的进程</a></h3>
]]></content>
  </entry>
  
</feed>
