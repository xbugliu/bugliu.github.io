<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2015-09-10T23:46:30+00:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++API设计 - 笔记]]></title>
    <link href="http://towriting.com/blog/2014/11/15/api-design-for-c-plus-plus-notes/"/>
    <updated>2014-11-15T20:24:38+00:00</updated>
    <id>http://towriting.com/blog/2014/11/15/api-design-for-c-plus-plus-notes</id>
    <content type="html"><![CDATA[<p>{% aproduct B00EE13U30*C++ API设计%}从书名看是关于设计C++接口的书，内容却不仅仅是关于C++接口设计。书还算实用，但如果看过代码大全和Effective系列的话，可以不用在看这本书了。</p>

<h2>笔记</h2>

<p>P91 重构就像汽车高速行驶时更换引擎，但还不能停车</p>

<p>P103 API的第一个发行版本很重要</p>

<p>P115 LISKOV替换原则指出，如果S是T的子类，那么在行为上，S不需要修改就可以替换T类型的对象</p>

<p>P117 私有继承、Was-a的关系</p>

<p>P119 开发封闭原则是一种启发式的原则，则不是必须遵守的</p>

<p>P121 一个好的名字往往可以表达类的意图，如果一个类难以命名，这往往是缺乏设计的信号</p>

<p>P122 函数尽量使用正面的概念命名，比如IsConnect而不是IsUnConnect</p>

<p>P132 C API比C++ API具有更好的二进制兼容性</p>

<p>P140 可以使用预处理器技术模拟模板</p>

<p>P176 避免使用友元，这往往意味这糟糕的设计</p>

<p>P182 如果没有必要使用Dynamic_Cast则常见的做法是关闭运行时信息生成</p>

<p>P182 不要猜测性能瓶颈的位置</p>

<p>P183 传值可能会导致对象切割而引起莫名其妙的问题</p>

<p>P185 不应该前置声明STL的类型</p>

<p>P192 C++11中一个构造函数可以调用其他的构造函数</p>

<p>P192 对象越小，就越适合缓存</p>

<p>P197 Donald Knuth有句名言：过早优化是万恶之源</p>

<p>P211 Linux 的奇数版本号代表开发版本</p>

<p>P216 如果确实需要做二进制不兼容，则需要考虑给信库起个新名字。比如zlib.dll &ndash;> zlib1.dll</p>

<p>P225 弃用标记：__declspec(deprecated)</p>

<p>P250 时间驱动、质量驱动和功能驱动</p>

<p>P257 性能测试的结果是实数而不是简单的真和假</p>

<p>P264 驱动测试开发的好处是推动你考虑接口会被如何调用</p>

<p>P286 SWIG</p>

<p>P286 任何脚本绑定技术都是建立在适配器模式上的</p>

<p>P286 Boost.Python支持Boost和Python的互相交互</p>

<p>P265 模拟对象又可以简单称为MOCK</p>

<p>P339 每个DLL有相应的到入库lib文件，虽然静态库和导入库的格式都是lib但他们的文件类型是不同的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谁在用C++ STL？]]></title>
    <link href="http://towriting.com/blog/2014/04/18/who-use-stl/"/>
    <updated>2014-04-18T23:39:00+00:00</updated>
    <id>http://towriting.com/blog/2014/04/18/who-use-stl</id>
    <content type="html"><![CDATA[<p>C++用了四年了，这两天才把{% aproduct B00DGLU91K*Effective STL%}看了一遍。此书作为C++经典书系Effective三部曲之一，知名度与所受褒扬远不及另两本，个中缘由是否因为STL地位不济。所以今日以自己鄙陋的经历来谈一谈当前STL在C++程序员中的地位和使用状况。</p>

<p>大家知道STL中三大法宝：容器、迭代器和算法。我所经历的公司/团队STL的使用情况：</p>

<hr />

<table border="1">
<tr><th>序号</th><th>团队规模</th><th>项目规模</th><th>容器</th><th>迭代器</th><th>高级迭代器</th><th>算法</th><th>高级算法</th><th>funtional</th></tr>
<tr><th>1</th><td>5人以下,平均2年经验</td><td>10万以下</td><td>基本没有</td><td>基本没有</td><td>基本没有</td><td>基本没有</td><td>无</td><td>无</td></tr>
<tr><th>2</th><td>10人,平均2年经验</td><td>100万</td><td>较多</td><td>较多</td><td>较少</td><td>较少</td><td>极少</td><td>几无</td></tr>
<tr><th>3</th><td>10人,平均4年经验</td><td>100万</td><td>较多</td><td>较多</td><td>较少</td><td>极少</td><td>较少</td><td>有</td></tr>
</table>


<p>（注：表中迭代器是指通过begin和end获取interator，而高级迭代器指back_inserter等迭代器生成器和内置迭代器;算法指sort,foreach, 高级算法指算法带if的形式）</p>

<hr />

<p><strong>看来，STL并不受大家欢迎，至少在我所呆过的团队里是这样的，为何如此？</strong></p>

<h3>洪水猛兽 （守旧）</h3>

<p>容器（最简单的vector）几乎是大部分C++程序员最开始接触的STL组件，我也不例外。那是10年自己刚毕业那会儿，在一家公司实习，实现一个简单的图像显示和处理的Demo程序。里面图像数据最初是存储在原始的数组（char [])中。那一阵子在狂啃《C++ Primer》，里面提到C++程序员不应该使用这些原生的数组，应该用vector代替，于是自己将程序中的char []替换成了vector<char>。而后发现一些图像算法执行慢了好多，遂请教mentor，mentor是名校的doctor，不编程久已，他并没用过STL，但提出不要用STL，不要追时髦、偷懒，老老实实的写“C”代码就好了。</p>

<p>舔着第一次用STL的伤口，念着mentor的教诲，在这家公司的第一年里自己后来好像就不再关注和使用STL。同期的C++ Programmer共四人，一个工作1年，另两个更久些，那时我们在“不赶时髦”上很团结，大家愉快的使用着VC6，且都不使用STL。</p>

<p>这就是某些老式小型软件公司一些C++程序员对待STL的态度：排斥守旧，其中缘由高校的计算机教育脱不了干系。</p>

<p>当然有个人和特殊业务场景也会排斥STL：<a href="http://www.zhihu.com/question/20201972">为何某些公司不容许使用C++ STL</a>。</p>

<h3>玄之又玄 （畏惧）</h3>

<p>C++本来有有很多不易掌握的细节。而STL同样如此，简单强大，但有微妙的陷阱。就拿Effective STL来说，条款1：慎重的选择容器类型中，就有大量自己不曾掌握模棱两可的点：</p>

<ul>
<li>string的swap会导致迭代器失效</li>
<li>容器的内部可能有引用计数</li>
<li>插入、删除操作的回滚能力</li>
</ul>


<p>当然有些细节无需掌握，但就我接触到的C++程序员大都使用STL的最简单用法: 使用vector和map存储一些数据，而对稍微高级点的STL用法麻木无知或畏惧使用：</p>

<ol>
<li>各种容器的区别，如何使用容器兼容C接口</li>
<li>for_each等函数存在的意义，如何写出函数式风格的代码</li>
<li>类的成员函数和同名全局函数的区别，比如set::find与std::find，map::remove与std::remove等等</li>
<li>xxx_if函数的使用，如何写predicate</li>
<li>function&lt;>, bind函数的使用</li>
<li>一些惯用法，比如erase-remove</li>
</ol>


<p>以上是我认为一个合格的C++开发应掌握的STL技巧。而掌握这些技巧，却是需要一段时间的练习，是否这一原因导致了一部分人对STL的无爱？因为即使不掌握这些技巧，功能是同样可以完成的。</p>

<h3>曲高和寡 （风气)</h3>

<p>语言的出现提高了人们交流的效率，设计模式的出现提高了软件人员的交流效率，但前提是交流的双方都懂才行。STL同样如此，我之蜜糖彼之砒霜，在一个不了解STL的团队中大量使用STL尤其是一些稍微“高级另类”的用法，难免遭人排斥。而且别人很难看懂你写的代码，指责你的代码难于维护，这并不是谁的错，这是一个道不同不幸与某的问题。</p>

<p>在一个不用、不了解STL的团队，喜爱STL之人会克制使用STL！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《C++标准库第二版 上册》笔记]]></title>
    <link href="http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1/"/>
    <updated>2013-12-18T23:27:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1</id>
    <content type="html"><![CDATA[<p>p63 a pair&lt;> using a type that has only a nonconstant copy constructor will no longer compile.</p>

<p>p64 std::piecewise_construct is passed as the first argument is class Foo forced to use a constructor that takes the elements of the tuple rather than a tuple as a whole.</p>

<p>p65 The make_pair() function template enables you to create a value pair without writing the types explicitly.</p>

<p>p67 pair used in functions that return two values.</p>

<p>p68 tuples extend the concept of pairs to an arbitrary number.we can access elements with the get&lt;>() function template.</p>

<p>p70 A tuple type can be a reference. For example:</p>

<p><code>cpp
string s;
tuple&lt;string&amp;&gt; t(s);
</code></p>

<p>For element access, you must know the index of element at complier time.It is also a complier error if you pass a invalid index.
Make_tuple can create tuple without special the type of element.
By using references with make_tuple(), you can extract values of a tuple back to some other variables. e.g.</p>

<p><code>cpp
std::tuple&lt;int, float&gt; t(1, 1.5);
int i = 0;
float f = 2.0;
make_tuple(std::ref(i), std::ref(f)) = t;
</code></p>

<p>p72 std::tie() creates a tuple of references. the use of std::ignore allows ignoring tuple elements while parsing with tie()</p>

<p>p75 You can initialize a two-element tuple with a pair.Also, you can assign a pair to a two-element tuple.</p>

<p>p76 Tow types of smart pointer:</p>

<ul>
<li>shared_ptr. Multiple smart pointer can refer to the same object.</li>
<li>unique_ptr. only one smart pointer can refer to this object at a time.</li>
</ul>


<p>p77 shared_ptr. you can define other ways to clean up object.</p>

<p>p78 shared_ptr can&rsquo;t assign a new ordinary pointer. but can use reset function to reset the pointer.</p>

<p>p79 assigning a nullptr to a shared_ptr would delete the ownship.</p>

<p>p80 Smart pointer, when use new[] to create an array of object, you must define your own deleter.</p>

<p>p85 weak_ptr allows sharing but not owning an object.</p>

<p>p90 You should always directly initialize a smart pointer the moment you create the object with its associated resource.</p>

<p>p95 Aliasing constructor,The constructor taking another shared_pointer and an additional raw pointer.</p>

<p>p96 shared pointers are not thread safe.</p>

<p>p101 You can&rsquo;t copy or assgin a unique pointer if you use the ordinary copy semantics, but can use move semantics.</p>

<p>p102 assgining nullptr is also possible, which has the same effect as calling reset().</p>

<p>p103 The Reason that no std::move is necessary in the return statement of source() is than according to the language rules of c++11, the compiler will try a move automaticallly.</p>

<p>p105 The c++ stl provides a partial spartial specialization of class unique_ptr for array: std::unique_ptr<code>&lt;std::string[]&gt;</code></p>

<p>p110 unique_ptr not necessarily defined as T*</p>

<p>p115 The new concept of numeric limits has two advantages: first, it offers more type safety. second, it enables a programmer to write templates that evaluate these limits.</p>

<p>p119 all members of numeric_limits are declared as constexpr.</p>

<p>p121 you can query for any arbitrary type whether or not it has numeric limits defined.</p>

<p>p125 Type Traits:</p>

<ul>
<li>Type Predicates</li>
<li>Type Relations</li>
<li>Type Modifiers</li>
</ul>


<p>p130 A reference to a constant type is not constant</p>

<p>p136 Note that swap provides an exception specification</p>

<p>p158 Not that time_t usually is just the number of seconds since the UNXI epoch. bu this is not guaranteed.</p>

<p>p166 The marjor advantage of iterators is that they offer a small but common interface for any arbitrary container type.</p>

<p>p166 The concept of STL is base on a separation of data and operations. The data is managed by container classes, and the operations are defined by configurable algorithms. iterators are the glue between these two components.</p>

<p>p167 There are three general kinds of containers:</p>

<ul>
<li>Sequence contains are ordered collections in which every element has a certain postion.</li>
<li>Associative containers are sorted collections in which the postion of an element depends on its value due to a certain sorting criterion: set multiset map multimap.</li>
<li>Unorderd containers. neither the order of insertion nor the value of the inserted element has an influence on the postion of the element, and the position might change over the lifetime of the container: unordered_set,undered_multiset,undered_map,undered_multimap.</li>
</ul>


<p>p170 size() is provided for any container class execept singly linked lists(class forward_list)</p>

<p>p170 deque rhymes with &ldquo;check&rdquo;</p>

<p>p171 the push_front is not provided for vectors, because it would have a bad runtime for vectors, but is is possible to insert an element at the beginning of a vector.</p>

<p>p171 using array. with a safer and more convenient interface.</p>

<p>p176 forward_list is in principle just a limited list.</p>

<p>p177 The major advantage of associative containers is that finding an element with a specific value is rather fast.</p>

<p>p177 you can consider a set as a special kind of map, in which the value is identical to the key. in fact, all these are implemented by using the same basic implementation of a binary tree.</p>

<p>p180 C++11 guarantees that newly inserted elements are inserted at the end of equivalent elements that multisets and multimaps already contain.</p>

<p>p180 unordered containers are typically implemented as a hash table. the goal is that each element has its own position so that you have fast access to each element.</p>

<p>p185 associative array: an array whose index is not an integer value.</p>

<p>p188 an iterator is an object that can iterate over elements. iterators share the same interface but have different types.</p>

<p>p189 every container defines two iterator types:</p>

<ul>
<li>container::iterator is provided to iterator over elements in read/write mode</li>
<li>container::const_iterator is provided to iterator over elements in read mode</li>
</ul>


<p>p199 To write generic code you should not use special operations for random-access iterators.</p>

<p>p199 Algorithms are not member functions of the container classer but instead are global functions that operator wich iterators. this concept reduces the amount of code and increases the power and the flexibility of the library.</p>

<p>p208 Multiple Ranges, make sure that the second and additional ranges have at least as many elements as the first range.</p>

<p>p209 associative and unordered containers cannot be used as a destination for overwriting algorithms.</p>

<p>p210 Interator Adapters</p>

<p>p210 Insert Interators solve the problem of algorithms that write to destination that does not have enough room.</p>

<p>p212 general insertor call insert()</p>

<p>p213 <code>istream_iterator&lt;string&gt;()</code> calls the default constructor of iterators that creates a so-called end-of-stream iterator.</p>

<p>p214 reverse iterators rbegin()\rend()</p>

<p>p220 distance if iterator were random-access, you could with &ldquo;&ndash;&rdquo;</p>

<p>p221 to make agorithms as flexible as possible there are good reason not requrie that interator know their container.</p>

<p>p223 a container might have member functions that provide much better performance that algorithms</p>

<p>p226 predicates must stateless</p>

<p>p232 Lambda no default constructor and no assignment operator.</p>

<p>p235 function object are functions with states</p>

<ul>
<li>fnctction object has its own type</li>
<li>function object may faster than ordinary functions.</li>
</ul>


<p>p241 Binder to combine predefined function objects with other values or use special cases.</p>

<p>p248 it&rsquo;s turns out that exception specifications could cause performance penalties, so they were replaced by noexcept with c++11.</p>

<p>p249 if you need a transaction-safe container, you should use a list.</p>

<p>p254 container&rsquo;s operators are not safe in the sense that they check for every possible error.</p>

<p>p257 since c++11 you can use move constructor</p>

<p>p258 Move Sytax: The contents of the container on the right-hand side are undefined afterwared:</p>

<p>p258 forware_list not provided size()</p>

<p>p260 all containers except vectors and deques guarantee that iterators an references to elements remianing valid if other elemenets are deleteed.</p>

<p>p262 array&lt;> default initialized.</p>

<p>p267 array you must not pass an iterator as the address of the first element.</p>

<p>p271 vectors： capacity(), which returns the number of elements a vector could contain in its actual memory.</p>

<p>p271 If the only reason for initialization is to reserve memory, you should use reserve()</p>

<p>p271 it is not possible to call reserve for vectors to shrink the capacity.</p>

<p>p282 For vector<bool> the return type of subscript operator is an auxiliary class.</p>

<p>p283 Deque is typically implemented as a bunch of individual blocks.</p>

<p>p284 Deque provide no support to control the capacity and the momnet of reallocation.Howerer reallocation may perform better than for vectors because according to their typical internal structure, deques don&rsquo;t have to copy all elemenets on reallocation.</p>

<p>p284 Blocks of memory might get freed when they are no longer used(implementation specific)</p>

<p>p286 You could say that lists are transaction safe.</p>

<p>p301 The design goal to have &ldquo;zero space or time overhead relative to a hand-written C-stype single linked list.</p>

<p>p303 forward_list provide no support size(), but you can use std::distance(list.begin(),list.end())</p>

<p>p315 you cant change set&rsquo;s value from interator</p>

<p>p316 not that the sorting criterion is also used to check for equivalence of two elements in the same container.</p>

<p>p338 std::for_each(coll.begin(), coll.end(), [] (decltype(coll)::value_type &amp;elem) {}
p342 piecewise_construct emplace.</p>

<p>p345 [] is slower than the insert()</p>

<p>p366 unorder container</p>

<p>p366 unorder containers are optimized for fast searching of elements</p>

<p>p386 using the noninvasive approach is simple, you need only objects that are able to iterate over the elements of an array by using the STL iterator interface.</p>

<p>p386 Any Thing that behaves like an iterator is an iterator.</p>

<p>p437 forward iterators, it is guaranteed that for two forward iterators that refor to the same elemnet, operator == yields true and that they will refer to the same value after both are incremented.</p>

<p>p442 to be able to change container and iterator types, you should use advance</p>

<p>p460 for insert iterator, a bad hint might even be worse than no hint.</p>

<p>p471 writing user-defined iterators</p>

<p>p476 each function object has its own type</p>

<p>p479 by default, function objects are passed by value rather than by reference.</p>

<p>p483 for_each can return a value</p>

<p>p485 a predicate should always be stateless. you should declare operator() as const. but lambda not exist this problem.</p>

<p>p494 bind also could bind data member.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boost.Lambda与C++11.Lambda的用法对比]]></title>
    <link href="http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda/"/>
    <updated>2013-12-13T22:38:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda</id>
    <content type="html"><![CDATA[<p>我们知道C++11已经支持了Lambda表达式，大部分新的编译器都已支持Lambda。但boost里面的Lambda还是有存在的必要，因为并不是每个人都有选择自己编译环境的权利。</p>

<p>让我们通过几个例子对比C++11.Lambda来学习一下boost.Lambda的用法，详细的C++11.Lambda用法可以看这里：<a href="/blog/2013/08/11/lambda-closures/">C++11系列-Lambda表达式</a></p>

<h3>1.a boost.Lambda：构造一个functor</h3>

<p>boost.Lambda的使用是基于placeholder: <code>boost::Lambda::_1</code>,<code>boost::Lambda::_2</code>,<code>boost::Lambda::_3</code>可以理解为Lambda表达式的第一、第二、第三个参数。Lambda的出现利索地解决了STL算法库函数的使用不便。让我们首先看一个最简单的boost.Lambda与std::for_each结合的例子:</p>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin values in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;&ldquo;,&rdquo;);
std::cout&lt;&lt;std::endl;
```</p>

<p>上面的例子，使用std::for_each遍历vector中的元素并打印内容。boost::Lambda::_1这个占位符表示for_each遍历时传进来的第一个参数，<code>std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;","</code>可以理解为临时创建出来的匿名函数，函数的定义是<code>void(int)</code>。</p>

<p>让我们对比一下C++11标准的写法:</p>

<h3>1.b C++11.Lambda：构造一个functor</h3>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin value in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), <a href="const%20int%20&amp;%20val"></a>
{
std::cout&lt;&lt;val&lt;&lt;&ldquo;,&rdquo;;
});
std::cout&lt;&lt;std::endl;
```
一眼望去竟是boost的Lambda用法简洁。</p>

<h3>2.a boost.Lambda：修改参数的内容</h3>

<p>上面的例子，我们使用Lambda表达式，借助于for_each，对vector中的元素进行了访问，那我们可以修改vector的内容吗？</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), boost::Lambda::_1 *= boost::Lambda::_1);
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;",");//打印
std::cout&lt;&lt;std::endl;
</code>
上面的例子，功能是对vecIn中的值求平方。占位符boost::Lambda::_1直接用引用的方式得到了传入的参数（vecIn的元素），结果直接改写进了vecIn。</p>

<h3>2.b C++11.Lambda：修改参数的内容</h3>

<p>修改1.b函数定义为引用即可</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [](int &amp; val)
{
val *= val;
});
//打印：
std::for_each(vecIn.begin(), vecIn.end(), [](const int &amp; val)
{
std::cout&lt;&lt;val&lt;&lt;",";
});
std::cout&lt;&lt;std::endl;
</code></p>

<h3>3.a boost.Lambda：变量捕获</h3>

<p>boost.Lambda可以很方便的以引用的方式捕获local变量，看例子：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), sum += boost::Lambda::_1);
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>3.b C++11.Lambda：变量捕获</h3>

<p>C++11捕获变量，可控性更强，我们可以指定捕获方式：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [&amp;sum](int &amp; val)
{
sum += val;
});
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>4.a boost.Lambda：返回值</h3>

<p>有时需要匿名函数返回结果，比如作为std::find_if类似函数的Predicate函数时，这种能力boost.Lambda当然也是胜任的，整个Lambda表达式的结果，即是函数的返回值。</p>

<p>```cpp
boost::function&lt;bool(int)> IsOdd = boost::Lambda::_1 % 2 != 0;</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```
上面的例子创建了一个检测参数是否是奇数的匿名函数，并保存到IsOdd对象中，然后对其进行了调用。例子同样演示了如何将一个boost.Lambda表达式存储起来，后续使用的方法。</p>

<h3>4.b C++11.Lambda：返回值</h3>

<p>C++11的返回值，必须使用return语句，返回值的类型有些时候也需要显示指定。
```cpp
std::function&lt;bool(int)> IsOdd = (std::function&lt;bool(int)>)<a href="int%20val"></a>{return val % 2 != 0;};</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```</p>

<h3>5. 上面四个例子的运行结果</h3>

<pre><code>the orgin values in vecIn：
1,2,3,
the values in vecIn after Square：
1,4,9,
the sum of values in vecIn：
14
100 is Odd？ false
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[那些C++牛人的博客]]></title>
    <link href="http://towriting.com/blog/2013/12/12/cpp-blogs/"/>
    <updated>2013-12-12T20:57:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/12/cpp-blogs</id>
    <content type="html"><![CDATA[<p>现整理收集C++世界里那些“牛人”的个人博客。凡三类：一是令人高山仰止的大牛，对C++语言本身产生过深远的影响的人；二是C++运用炉火纯青的高手，有原创性的技术干货；三是中文世界里的C++牛人。</p>

<h2>C++大牛的博客</h2>

<p>{% img pull-right /images/posts/cpp-blogs/BjarneStroustrup.jpg 120 150%}</p>

<ul>
<li><strong>Bjarne Stroustrup的博客</strong>: <a href="http://www.stroustrup.com/">Bjarne Stroustrup&rsquo;s Homepage</a></li>
</ul>


<p>Bjarne Stroustrup，不认识的可以去面壁了，没有他，就没有我们现在的饭碗。Bjarne Stroustrup是丹麦人，目前任教于<a href="http://en.wikipedia.org/wiki/Texas_A%26M_University">TAMU</a>。他的Homepage和他的书籍{% aproduct B003EIKI0C*The C++ Programming Language%}一样，都是百科全书级的，如果你认真研究，你也会成为你同事或周围人的C++之父。</p>

<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/ScottMeyers.jpg 120 150%}</p>

<ul>
<li><strong>Scott Meyers的博客</strong>: <a href="http://scottmeyers.blogspot.com/">The View from Aristeia</a></li>
</ul>


<p>Scott Meyers，不多介绍，世界上几乎每个C++程序员都应该知道的名字，畅销书：{% aproduct B004G72P24<em>Effective C++</em>B004IP8BD6*More Effective C++%}的作者。博客长期更新，就凭Scott Meyers这个名字，就值得一读。</p>

<br/>


<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/stan_lippman.jpg 120 150%}</p>

<ul>
<li><strong>Stanley B.Lippman的博客</strong>: <a href="http://blogs.msdn.com/b/slippman/">Stan Lippman&rsquo;s BLog</a></li>
</ul>


<p>Lippman，C++第一个编译器<a href="http://en.wikipedia.org/wiki/Cfront">Cfront</a>的实现者，最大的贡献是凭借其著作{% aproduct B00ESUIL0O<em>C++ Primer%}在世界范围内普及了C++。Lippman本人算是个励志故事，父母是蓝领移民，他为了融入美国主流社会而努力工作，终于取得了今日的成就，他的另一本书{% aproduct B006QXQXTM</em>Inside The C++ Object Model%}让我知道了C++代码编译后的样子，不过我不知他写该书时发生了什么事情，因为书中有大量的低级错误，与前一本书的严谨截然相反。列出他的博客，更多的是因为他是C++牛人中无法绕过的一个，而其博客久不更新，早已荒芜，而且是MSDN上的专栏，可能不太能提起人多大兴趣去读。</p>

<p>{% img pull-right /images/posts/cpp-blogs/HerbSutter.jpg 120 150%}</p>

<ul>
<li><strong>Herb Sutter的博客</strong>: <a href="http://herbsutter.com/">Sutter’s Mill: Herb Sutter on software, hardware, and concurrency</a></li>
</ul>


<p>Herb Sutter, C++标准委员会主席，目前就职于微软。代表作为C++ Exceptional系列：{% aproduct B008CGKUBS<em>Exceptional C++</em>B004IUISIO<em>More Exceptional C++</em>B00114BFTO*Exceptional C++ Style%}, 因封面头像蓄须，被国人称“小胡子”，不过貌似现在刮干净了。博客更新很快，内容杂乱，有技术亦有资讯，gotw系列个人感觉不错。</p>

<br/>


<p>{% img pull-right /images/posts/cpp-blogs/AndreiAlexandrescu.jpg 120 150%}</p>

<ul>
<li><strong>Andrei Alexandrescu的博客</strong>: <a href="http://erdani.com/index.php/articles/">Official website of Andrei Alexandrescu</a></li>
</ul>


<p>Andrei Alexandrescu，罗马尼亚人，目前任职于FaceBook, C++天书{% aproduct 0201704315*Modern C++ Design: Generic Programming and Design Patterns Applied %}的作者，凭借此书使C++社区认识到模板编程鬼斧神工之力。后来不满C++而转投D语言，是D语言的主要开发者。不过他的博客貌似好久不更新了，内容也大多学术气息浓厚。</p>

<br/>


<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/dave_abrahams.jpg 120 150%}</p>

<ul>
<li><strong>David Abrahams的博客</strong>: <a href="http://daveabrahams.com/">Dave Abrahams: Home Page | Stuff I wrote, things I did, etc</a>[已失效]</li>
</ul>


<p>David Abrahams，美国人，C++标准委员会成员，将exception-safety加入标准，Boost.org的联合创始人，{% aproduct B002WB1J0U*C++ Template Metaprogramming%}的作者。但博客内容一般，最后一篇内容更新时间是12年的，内容不多，也没有太多亮点，不过笑容却是感染了我。</p>

<br/>


<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/BartoszMilewski.jpg 120 150%}</p>

<ul>
<li><strong>Bartosz Milewski的博客</strong>：<a href="http://bartoszmilewski.com/">Bartosz Milewski&rsquo;s Programming Cafe：Concurrency, Multicore, C++, Haskell</a></li>
</ul>


<p>Bartosz Milewski，波兰人，物理系毕业的计算机大牛，曾就职于微软。{% aproduct B009TB3ZBW*c++ in action%}的作者。博客更新频繁，内容密实，观点前卫，对C++的不满流露于字里行间，多以Haskell对比C++的不足，然后实现一些函数式编程风格的C++代码。</p>

<p>不才曾翻译过他的文章：<a href="/blog/2013/09/23/edward-chands/">C++手爱德华</a></p>

<br/>


<p>{% img pull-right /images/posts/cpp-blogs/anthony_williams.jpg 120 150%}</p>

<ul>
<li><strong>Anthony Williams的博客</strong>：<a href="http://www.justsoftwaresolutions.co.uk/blog/">Just Software Solutions</a></li>
</ul>


<p>Anthony Williams，英国人，一个记事起就开始写程序的人。<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html">Boost.Thread</a>的作者，参与了C++11 Thread的标准化工作。博客有一部分技术文章，也有一些标准化和他自己维护的一些库的记录，对C++多线程感兴趣的可以读一下他的书：{% aproduct 1933988770*C++ Concurrency in Action%}，市面上第一本讲解C++11并发的权威书籍。</p>

<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/AlexanderStepanov.jpg 120 150%}</p>

<ul>
<li><strong>Alexander A. Stepanov的博客</strong>：<a href="http://www.stepanovpapers.com/">Collected Papers of Alexander A. Stepanov</a></li>
</ul>


<p>Alexander A. Stepanov，出生于莫斯科，STL之父，{% aproduct B006P7V73G*编程原本%}的作者。Alexander A. Stepanov的这个博客如其名，是他个人学术论文的整理，学术价值应该是蛮高吧，不过像我这种低级程序员只能远观了。</p>

<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/austern.jpg 120 150%}</p>

<ul>
<li><strong>Matt Austern的博客</strong>: <a href="http://lafstern.org/matt/">Matt Austern&rsquo;s Home Page</a></li>
</ul>


<p>Matt Austern, 现任职于Google, 前C++标准委员会主席，SCG STL的最初实现者，{% aproduct 0201309564*Generic Programming and the STL%}的作者。Matt Austern的这个博客其实是个人主页，没有太多技术东西，只是一些生平和生活照片，无聊的看一下倒还行。</p>

<br/>


<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/pjp.jpg 120 150%}</p>

<ul>
<li><strong>P.J. Plauger的博客</strong>：<a href="http://www.stepanovpapers.com/">Collected Papers of Alexander A. Stepanov</a></li>
</ul>


<p>P.J. Plauger，这个名字可能不是每个人都听说过，但在Windows平台开发的同学肯定都用过他写的代码，他就是MS VC STL库的实现者。本来他的博客，只是个人主页并且上面没什么内容，不过看到他的履历里面完成了13部科幻小说的编写，拿来勉励大家吧。</p>

<br/>


<br/>


<h2>C++高手的博客</h2>

<p>{% img pull-right /images/posts/cpp-blogs/akrzemi1.jpeg 120 150%}</p>

<ul>
<li><strong>Andrzej Krzemieński的博客</strong>：<a href="http://akrzemi1.wordpress.com/">Andrzej&rsquo;s C++ blog Guidelines and thoughts about C++</a></li>
</ul>


<p>Andrzej Krzemieński，从名字看是波兰人，近期博客更新较快，表达清晰，行文流畅，内容难度不高，有C++11内容，是像我这样的初级并且语言控的C++程序员的福音。</p>

<br/>


<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/SumantTambe.jpg 120 150%}</p>

<ul>
<li><strong>Sumant Tambe的博客</strong>： <a href="http://cpptruths.blogspot.com/">c++ truths</a></li>
</ul>


<p>Sumant Tambe，印度人，美国范德堡大学的计算机博士，技术涉猎广泛，同时也是著名的<a href="http://en.wikibooks.org/wiki/More_C++_Idioms">More C++ Idioms</a>创建者。博客一直更新，内容面向中高级C++程序员，最新文章涉及C++11的“高级Idioms”，比如13年10月的一篇文章主题是：创建递归的lambda表达式。</p>

<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/JeffPreshing.jpg 120 150%}</p>

<ul>
<li><strong>Jeff Preshing的博客</strong>: <a href="http://preshing.com/">Preshing on Programming</a></li>
</ul>


<p>Jeff Preshing，加拿大人，自称游戏行业开发10数年，C++功力自是深厚。博客每年更新十数篇，C++相关文章内容上进，直面工程上的难题：并发，而不是在C++本身上打转转。且行为流畅，图文并茂，深入浅出，是C++工程控的福音。</p>

<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/Joaqu.jpg 120 150%}</p>

<ul>
<li><strong>Joaquín M López Muñoz的博客</strong>: <a href="http://bannalia.blogspot.com/">Bannalia: trivial notes on themes diverse</a></li>
</ul>


<p>Joaquín M López Muñoz，西班牙人。Boost.MultiIndex的实现者。博客长期更新，内容偏向算法，文章中有大量的公式推演和曲线图表，估计大部分中国开发者对这种内容是不感冒的。计算机或数学系的研究生，并以后打算从事算法相关工作的，推荐阅读。从这个西班牙男人身上，也可以看到老牌欧洲资本主义国家，教育水平的强悍，尤其是基础学科。</p>

<ul>
<li><strong>Daniel Park的博客</strong>: <a href="http://functionalcpp.wordpress.com/">functionalcpp-Abusing the type system like never before</a></li>
</ul>


<p>Daniel Park，喜欢用昵称whanhee，身世不知。一个注重实干的C++狂热分子，正如其博客简介所说，不想接着讲那些被讲烂掉的函数式编程概念，要用C++来实现这些概念。博客是一个关于函数式编程概念如何用C++实现的一个系列文章，作者采用的是C++11乃至C++14的特性，所以对C++高级函数式实现思想感兴趣的不容错过。近期博客更新也较快的。</p>

<ul>
<li><strong>Agustín Bergé的博客</strong>: <a href="http://talesofcpp.fusionfenix.com/">talesofcpp</a></li>
</ul>


<p>Agustín Bergé，86年生阿根廷人，可能是这里面最年轻的，stackoverflow目前排名708。作者想用自己的博客探索永无边界的C++世界，尤其是那些前人未涉足的犄角旮旯，所以C++中毒颇深者可以看看。</p>

<ul>
<li><strong>Chris Kohlhoff的博客</strong>: <a href="http://blog.think-async.com/">Thinking Asynchronously in C++</a></li>
</ul>


<p>Chris Kohlhoff，澳大利亚人，Boost.asio作者。博客更新到10年，内容主要涉及网络，asio相关，使用asio的可以去看看。</p>

<h2>中文C++名博</h2>

<p>{% img pull-right /images/posts/cpp-blogs/liuweipeng.jpg 120 150%}</p>

<ul>
<li><strong>刘未鹏的博客</strong>：<a href="http://mindhacks.cn/">MindHacks-思维改变生活</a></li>
</ul>


<p>刘未鹏，84年生人，现就职于微软，{% aproduct B008A4Y2R0<em>Imperfect C++</em>B00114BFTO*Exceptional C++ Style%}译者，大学时对C++有极大的学习兴趣，曾与C++之父邮件往来，记录在另一个博客<a href="http://blog.csdn.net/pongba/">C++的卢浮宫</a>上。据闻刘未鹏现忙于育儿与心理学，所以博客更新较慢，但以往博客含金量高，很值得一读。博客内容偏重于学习方法，纯技术的C++文章少些。</p>

<br/>


<p>{% img pull-right /images/posts/cpp-blogs/chenhao.jpg 120 150%}</p>

<ul>
<li><strong>陈皓的博客</strong>：<a href="http://coolshell.cn/">酷壳-享受编程和技术所带来的快乐</a></li>
</ul>


<p>陈皓，不认为自己是牛人的牛人，现就职于阿里巴巴。<a href="http://coolshell.cn/articles/4990.html">程序员技术练级攻略</a>这篇博文足以奠定其江湖地位。陈皓自称有技术焦虑症，所以博客更新频繁，内容大量涉及C++及一切劝人上进的观点和方法，也有不少网友的高质量投稿，涉及软件开发的方方面面。</p>

<br/>


<br/>


<p>{% img pull-right /images/posts/cpp-blogs/chenshuo.jpg 120 150%}</p>

<ul>
<li><strong>陈硕的博客</strong>：<a href="http://blog.csdn.net/solstice/">陈硕的Blog</a></li>
</ul>


<p>陈硕，国内少有的C++工程功底深厚，作风严谨且乐于分享的人。Muduo开源库的作者，有干货著作{% aproduct B00AYS2KL0*Linux多线程服务端编程:使用muduo C++网络库%}一本，译注若干。</p>
]]></content>
  </entry>
  
</feed>
