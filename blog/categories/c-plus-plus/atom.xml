<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2013-09-08T00:17:20+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[熟悉的陌生人-this指针(1)]]></title>
    <link href="http://towriting.com/blog/2013/09/01/this-pointer/"/>
    <updated>2013-09-01T00:22:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/01/this-pointer</id>
    <content type="html"><![CDATA[<p>this指针想必每个C++程序员都是再熟悉不过的了，我们每天的编程工作都会用到它，我们以为它是最忠实的朋友，不会给我们惹麻烦，但其实它可能不是你想象的样子！</p>

<h2>this指针的偏移 &ndash; 某次强制转化引发的血案</h2>

<p>这是一个真实的案例，发生在12年6月份，让我用简单的例子还原一下现场。假设有一组派生关系的类CBrid继承于CAnimal，我们构造一个CBrid对象并赋值到CAnimal指针，然后由于某些原因需要把这个基类CAnimal指针强制转化成void*(真实情况是Windows下的LPARAM），然后再强制转化回CBrid指针：
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>例1</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CAnimal
</span><span class='line'>{
</span><span class='line'>public:
</span><span class='line'>CAnimal(){}
</span><span class='line'>~CAnimal(){}
</span><span class='line'>protected:
</span><span class='line'>string m_strName; &lt;br/>
</span><span class='line'>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class CBird: public CAnimal
</span><span class='line'>{
</span><span class='line'>public:
</span><span class='line'>CBird(): m_bCanFly(true)
</span><span class='line'>{
</span><span class='line'>m_strName = &ldquo;Bird&rdquo;;
</span><span class='line'>}
</span><span class='line'>~CBird(){}
</span><span class='line'>virtual void Fly()
</span><span class='line'>{
</span><span class='line'>cout&lt;&lt;&ldquo;type: &rdquo;&lt;&lt;m_strName&lt;&lt;std::endl;
</span><span class='line'>cout&lt;&lt;&ldquo;is fly: &rdquo;&lt;&lt;m_bCanFly&lt;&lt;std::endl;
</span><span class='line'>}
</span><span class='line'>protected:
</span><span class='line'>bool m_bCanFly;
</span><span class='line'>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//主函数
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'> CAnimal&lt;em> pAnimal = new CBird;
</span><span class='line'> void&lt;/em> pCmd = (void&lt;em>)pAnimal;
</span><span class='line'> //一些操作
</span><span class='line'> CBird&lt;/em> pBird = (CBird&lt;em>)pCmd;&lt;br/>
</span><span class='line'> if (pBird != nullptr)
</span><span class='line'> {
</span><span class='line'>   pBird->Fly();
</span><span class='line'> }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div>
上面代码36行，pBrid要飞，但没飞起来，在我的开发环境下，程序挂在了这一行。那天是一个刚毕业很聪明的小伙子发现的这个问题，他还尝试过这样调用：
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>例2</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CAnimal&lt;/em> pAnimal = new CMammal;
</span><span class='line'>CBird&lt;em> pBird = (CBird&lt;/em>)pAnimal;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>if (pBird != nullptr)
</span><span class='line'>{
</span><span class='line'>  pBird->Fly();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div>
这样调用确是没有问题的，和第一个例子唯一的差别就是没有中间的Void*转化。
记得当时是我们周会的时间，于是拿出来和大家讨论，惭愧的是我们十几个人，竟然没人能说出其中原因，要知道我们中也有三个工作5年左右的同事。后来我打开调试器，跟踪了一下这两段代码的汇编代码，终于发现了蛛丝马迹：
<code>c
CBird* pBird = (CBird*)pAnimal;
cmp         dword ptr [pAnimal],0  
je          main+1C1h (33F681h)  
mov         eax,dword ptr [pAnimal]  
sub         eax,4  
mov         dword ptr [ebp-178h],eax  
jmp         main+1CBh (33F68Bh)  
mov         dword ptr [ebp-178h],0  
mov         ecx,dword ptr [ebp-178h]  
mov         dword ptr [pBird],ecx  
</code>
猫腻就在第5行，编译器先取基类指针pAnimal的值然后减了4，赋值给了派生类指针pBird，看到这里我才隐隐约约感觉是虚表的问题，CBird有一个虚函数，而基类CAnimal没有。当时我还没看《深度探索C++对象模型》，相信看过这本书的人一眼就能看出端倪，接着我验证一下我的猜想：
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>例3</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lass CAnimal
</span><span class='line'>{
</span><span class='line'>public:
</span><span class='line'>CAnimal(){}
</span><span class='line'>~CAnimal(){}
</span><span class='line'>protected:
</span><span class='line'>string m_strName; &lt;br/>
</span><span class='line'>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class CMammal: public CAnimal
</span><span class='line'>{
</span><span class='line'>public:
</span><span class='line'>CMammal()
</span><span class='line'>{
</span><span class='line'>m_strName = &ldquo;Mammal&rdquo;;
</span><span class='line'>}
</span><span class='line'>void IsEatMeat() const
</span><span class='line'>{
</span><span class='line'>cout&lt;&lt;&ldquo;type: &rdquo;&lt;&lt;m_strName&lt;&lt;std::endl;
</span><span class='line'>cout&lt;&lt;&ldquo;is eat meat: &rdquo;&lt;&lt;std::boolalpha&lt;&lt;m_bEatMeat&lt;&lt;std::endl;
</span><span class='line'>}
</span><span class='line'>private:
</span><span class='line'>bool m_bEatMeat;
</span><span class='line'>};&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>int main()
</span><span class='line'>{
</span><span class='line'> CAnimal&lt;em> pAnimal = new CMammal;
</span><span class='line'> void&lt;/em> pCmd = (void&lt;em>)pAnimal;
</span><span class='line'> CMammal&lt;/em> pMammal = (CMammal*)pCmd;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p> if (pMammal != nullptr)
</span><span class='line'> {
</span><span class='line'>  pMammal->IsEatMeat();
</span><span class='line'> }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div>
上面的代码运行正常，和例1的区别就是CMamal没有虚函数，而CBrid有。所以说，<strong>沿着继承链类型转化时，this指针可能会发生偏移，以确保this指针总能指向subobject</strong>。而强转中如果中间有void*这种没有类型信息的东西，会使编译器丢失这种偏移。</p>

<p><strong>this指针说白了就是对象基址，角色是成员变量寻址基址，偏移的目的是为了使成员变量寻址正确</strong>，影响对像内存布局的东西都可能使this指针偏移（具体编译器可能不同）：</p>

<ol>
<li>虚表，子类有而派生类没有</li>
<li>多重继承，子类与第n(n>1)个派生类</li>
<li>虚继承</li>
</ol>


<p>待续：this指针的偏移策略</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[const 二三事]]></title>
    <link href="http://towriting.com/blog/2013/08/21/things-of-const/"/>
    <updated>2013-08-21T23:36:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/21/things-of-const</id>
    <content type="html"><![CDATA[<p>相信任何一个C++程序员都听说并使用过const。const在最初的C语言中是没有的，后来Bjarne Stroustrup和Dennis Ritchie讨论提出了Readonly机制，最初的Readonly机制简单的就是想利用操作系统的能力，提供一种可以使变量是只读的能力。Readonly通过被加进C语言的决议，并命名为const，但可能是标准委员会的官僚导致这项决议迟迟没有执行。后来Bjarne Stroustrup就自己把const加入进C++中（当时还不叫C++），并逐渐演变成现在的样子。</p>

<p>窃以为尽一切可能的使用const是任何一个合格的C++程序员应该遵守的事情，就像开车要系安全带一样。但好像人们并不喜欢用const，在我有限的C++编程生涯中，我接触到的有意识的会尽量用const的，除了我好像只有一人。不喜欢用const的结果同样可能会和开车不系安全带是一样的，希望你不会出事！</p>

<h2>const的作用</h2>

<ul>
<li>避免魔数</li>
</ul>


<p><code>cpp
const int max_path = 260;
char [max_path];
</code>
使用自解释的变量名声明const变量，代替魔数，会增加代码的可维护性，勿以善小而不为呀！</p>

<ul>
<li><p>内存优化 对于POD类型的变量，const往往能将其优化到只读内存存储</p></li>
<li><p>降低API的复杂度</p></li>
</ul>


<p>比如有下面这样一个类
```cpp
class Array
{
  public:</p>

<pre><code>int getCount() const;
</code></pre>

<p>  private:</p>

<pre><code>//etc
</code></pre>

<p>};
```
将成员函数getCount指定为const（const不能修饰非成员函数和static成员函数），可以使调用它的客户端代码相信Array的对象是没有变化的，函数的调用不会产生副作用。</p>

<p>或者：
```cpp
int getMaxValue(const std::vector<int>&amp; srcVec);</p>

<p>void fun()
{</p>

<pre><code>std::vector&lt;int&gt; vec;
vec.push_back(1);
vec.push_back(2);
vec.push_back(3);

int maxVal = getMaxValue(vec);    

//继续使用vec
auto size = vec.size();
</code></pre>

<p>}
```
参数使用const修饰，可以逻辑上保证参数不会被调用的函数修改，一样是降低复杂度</p>

<ul>
<li>防止错误的发生</li>
</ul>


<p>看下面的例子：
```cpp
int getMaxVal()
{</p>

<pre><code>const int maxVal = getMaxVal();
int maxCacheVal = 0;
if (NeedFetchCache())
{
    //etc
    maxVal = getCacheMaxVal();//拼写错误，本来该是maxCacheVal
}

return max(maxCacheVal, maxVal);
</code></pre>

<p>}
```</p>

<p>如果不用const，例子里拼写错误导致的bug只能留待自测、QA或用户来发现了，如果maxVal是const，那编译器不会让你通过的，这样const帮助我们将这种错误绞杀于萌芽。</p>

<h2>两种const</h2>

<ul>
<li>物理const</li>
</ul>


<p>物理const是Bjarne Stroustrup最初想要实现的Readonly。目的是把POD类型的变量存储进只读存储区，比如：
<code>cpp
 const int i = 200;
</code>
i将被优化进只读内存，效果相当于C语言中的宏。</p>

<ul>
<li>逻辑const</li>
</ul>


<p>逻辑const，一般修饰成员函数，表明调用函数不用引起对象逻辑上的变化：
```cpp
class Array
{
  public:</p>

<pre><code>size_t size() const
{
    ++m_calledCount;//无法修改
    return m_size;    
}
</code></pre>

<p>  private:</p>

<pre><code>size_t m_size;
int m_calledCount;
</code></pre>

<p>};
```
上面例子中的size()函数修饰为const，则表明调用它的过程中，对象一般是不能变化的，所以无法改变成员变量的值。</p>

<p>逻辑const也指修饰非POD类型的变量，主要帮助编译器做语法检测：
<code>cpp
const std::string str1 = "towriting.com";
auto size = str1.size();
str1.push_back("!"); //无法调用非const成员函数
</code>
const的对象只能调用const版的成员函数。例子中的str1调用了非const函数push_back会引起编译错误，因为const对象不应该改变对象的“值"。</p>

<h2>鲜为人知的特性</h2>

<ul>
<li>内部链接</li>
</ul>


<p>大家知道全局变量的定义必须是唯一的，但const修饰的变量具有内部链接的属性，比如有两个编译单元文件test_const_one.cpp和test_const_ohter.cpp分别定义了全局变量g_var：
```cpp
//test_const_one.cpp</p>

<p>const int g_var = 1;
int main()
{
  //something
}</p>

<p>//test_const_other.cpp
const int g_var = 2;
int testconst
{
  //something
}</p>

<p><code>
但编译是没有问题的，因为g_var只在本编译单元可见
</code>cpp
towriting.com@debian:~/workspace/snippets/cpp$g++ test_const_one.cpp test_const_other.cpp
```</p>

<ul>
<li>影响虚函数的覆盖</li>
</ul>


<p>比如有两个类，CSuperButton继承CButton，并且子类“重写”了基类的GetWidth()函数：
```cpp
class CButton
{
  public:
   virtual int GetWidth() const {return 100;}
};</p>

<p>class CSuperButton: public CButton
{
  public:
   virtual int GetWidth() {return 0;}
};</p>

<p>int main()
{
  CButton *pBtn = new CSuperButton();
  std::cout&lt;&lt;pBtn->GetWidth()&lt;&lt;std::endl;
  return 0;
}
```</p>

<p>如果这是一道面试题，问输出的结果是多少时，我相性不少人会答错。不卖关子，结果是100，因为子类的GetWidth没有用const修饰而基类使用了const，所以无法覆盖。</p>

<ul>
<li>影响函数的重载</li>
</ul>


<p>影响函数的重载有两种，一种是通过const修饰成员函数，比如：</p>

<p><code>cpp
class CIntArray
{
public:
  int&amp; At(int index);
  const int&amp; At(int index) const;
};
</code>
CIntArray原本提供了一个非const的At函数用于获取内容，并且可以通过引用的返回值修改对象。但同时也要提供一个const版的At供const对象使用（如果返回成员变量，返回值也要用const）。</p>

<p>另一种影响重载的是，通过修饰参数，比如：
<code>cpp
void doSomething(int i);
void doSomething(const int&amp; i);
</code></p>

<ul>
<li>&ldquo;浅"const</li>
</ul>


<p>我们前面讲了成员const函数无法修改成员变量，但指针的成员变量为什么好像会被修改？
```cpp
class CObj
{
public:
  void doSomething() const
  {</p>

<pre><code> *m_pointer = 1;
</code></pre>

<p>  }
private:
  int *m_pointer;
};
```
上面的代码编译是没有问题的，const的成员函数doSomething好像"修改"了成员变量的值。指针的成员变量有什么特殊的吗，为什么可以这样？原因很简单，doSomething并没有修改m_pointer的值，m_pointer是指针，只是修改了指针指向的内容而已。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-区间迭代]]></title>
    <link href="http://towriting.com/blog/2013/08/20/ranged-for-loop/"/>
    <updated>2013-08-20T22:50:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/20/ranged-for-loop</id>
    <content type="html"><![CDATA[<p>在我前面<a href="/blog/2013/08/01/what-is-cpp11/">介绍C++11</a>的文章中，我提到C++11将会带来一些实用的改进。我的意思是它将移除一些不必要的打字和其它影响快速编码的壁垒。我前面讲过的<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">auto关键字</a>就是一个例子；现在我想讲一下区间迭代（range-based for loop）。</p>

<h2>区间迭代的基本语法</h2>

<p>近来，基本上所有现代编程语言都有一种对一个区间写for循环的便捷方式。最终，C++也有了相同的概念；你可以给循环提供一个容器，它帮你迭代。前面我们已经在<a href="/blog/2013/08/01/what-is-cpp11/">什么是C++11</a>中看到了一些简单的例子。让我们回忆一下区间迭代的样子：
```cpp
vector<int> vec;
vec.push_back( 10 );
vec.push_back( 20 );</p>

<p>for (int i : vec )
{</p>

<pre><code>cout &lt;&lt; i;
</code></pre>

<p>}
<code>
上面代码打印一个名叫vec的vector的内容，用i去捕获vector里面的值，直至vector的最后。你也可以用auto代替类型便利的迭代复杂的数据结构。例如，迭代一个map:
</code>cpp
map&lt;string, string> address_book;
for ( auto address_entry : address_book )
{</p>

<pre><code>        cout  &lt;&lt; address_entry.first &lt;&lt; " &lt; " &lt;&lt; address_entry.second &lt;&lt; "&gt;" &lt;&lt; endl;
</code></pre>

<p>}
```</p>

<h2>修改vector的值</h2>

<p>假如你想修改你正在迭代的容器的值，或者你想避免拷贝大对象，你可以用引用的变量遍历。比如，下面的迭代对一个整形vector中每个元素的值加1。
```cpp
vector<int> vec;
vec.push_back( 1 );
vec.push_back( 2 );</p>

<p>for (int&amp; i : vec )
{</p>

<pre><code>i++; // increments the value in the vector
</code></pre>

<p>}
for (int i : vec )
{</p>

<pre><code>// show that the values are updated
cout &lt;&lt; i &lt;&lt; endl;
</code></pre>

<p>}
```</p>

<h2>区间意味着什么？</h2>

<p>Strings,arrays,和所有的STL容器可以被新的区间迭代方式迭代。但是如果你想让你自己的数据结构使用这个新语法怎么办？</p>

<p>为了使这个数据结构可迭代，它必须类似于STL迭代器。</p>

<ul>
<li>这个数据结构必须要有begin和end方法，成员方法和独立函数都行，这两个方法分别返回开始和结束的迭代器</li>
<li>迭代器支持*操作符、!=操作符、++方法（前缀形式，成员函数和独立函数都行）</li>
</ul>


<p>就这些！实现这五个函数，你就可以有一个支持区间迭代的数据结构。因为begin、end可以是非成员函数，你甚至可以适配现有数据结构而不用实现STL风格的迭代器。所有你要做的是创建你自己的支持*、前缀++和!=的迭代器，并且定义好自己的begin、end。</p>

<p>区间迭代如此NICE。所以我怀疑大部分还不支持STL迭代模型的容器都会想添加某种适配方式以支持区间迭代。这里有一个小程序演示创建一个支持区间迭代的迭代器。这个例子里，我创建了一个固定Size是100的IntVector，并且可以被一个叫做Iter的类迭代。
```cpp</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>class IntVector;</p>

<p>class Iter
{</p>

<pre><code>public:
Iter (const IntVector* p_vec, int pos)
    : _pos( pos )
    , _p_vec( p_vec )
{ }

// 这三个方法组成支持区间迭代的迭代器的基础
bool
operator!= (const Iter&amp; other) const
{
    return _pos != other._pos;
}

int operator* () const;

const Iter&amp; operator++ ()
{
    ++_pos;
    return *this;
}

private:
int _pos;
const IntVector *_p_vec;
</code></pre>

<p>};</p>

<p>class IntVector
{</p>

<pre><code>public:
IntVector ()
{
}

int get (int col) const
{
    return _data[ col ];
}
Iter begin () const
{
    return Iter( this, 0 );
}

Iter end () const
{
    return Iter( this, 100 );
}

void set (int index, int val)
{
    _data[ index ] = val;
}

private:
</code></pre>

<p>   int _data[ 100 ];
};</p>

<p>int
Iter::operator* () const
{</p>

<pre><code> return _p_vec-&gt;get( _pos );
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>IntVector v;
for ( int i = 0; i &lt; 100; i++ )
{
    v.set( i , i );
}
for ( int i : v ) { cout &lt;&lt; i &lt;&lt; endl; }
</code></pre>

<p>}
```
注意这段代码中区间迭代时，不允许以引用修改IntVector中的元素。这是为了不使代码变长而影响代码的主要结构，所以并没添加返回引用类型的函数。</p>

<h2>区间迭代提升性能？</h2>

<p>在我使用GCC4.6的有限的测试中，我并没看到区间迭代相对于标准STL迭代的性能提升，但好像可以和STL中的for_each拥有同样的性能。</p>

<h2>编译器支持</h2>

<p>不幸的是，区间迭代的编译器支持的不好。MSVC11以后开始支持，GCC是4.6以后支持。</p>

<p>下一篇：静态表达式</p>

<p>上一篇：<a href="/blog/2013/08/11/lambda-closures/">lambda表达式</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-ranged-for-loop.html">Range-Based For Loops in C++11 &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-lambda函数]]></title>
    <link href="http://towriting.com/blog/2013/08/11/lambda-closures/"/>
    <updated>2013-08-11T22:45:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/11/lambda-closures</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/posts/lambda-closures/lambda.png" width="66" height="90" title="&lsquo;lambda&rsquo; &lsquo;C++11一个最激动人心的特性是支持创建lambda函数（有时称为闭包）。这意味着什么？一个Lambda函数是一个可以内联写在你代码中的函数（通常也会传递给另外的函数，类似于仿函数或函数指针）。使用Lambda，创建机动函数会更简单，而以前你必须创建一个有名函数。在这篇文章中，我先用一些例子解释为什么lambda很酷，然后我会讲解可能会用到的关于lambda的所有细节。&rsquo;" ></p>

<h2>为什么Lambda很酷</h2>

<p>想象你有一个地址簿类，并且你想要提供一个可供检索的函数。你可能会提供一个简单的函数，接受一个字符串然后返回满足所有字符串的地址。有时有些用户可能希望这样。不过假如他们只是想检索域名或者检索用户名并且忽略域名结果；或者检索出现在其他列表中的所有Email地址。这里可能有许多可能的检索方式。除了类中集成所有这些搜索选项，提供一个通用的查找方法，这个方法接受一个查找规则的函数，这样不是更好些吗？让我们叫这个函数findMatchingAddresses，它接受一个函数或仿函数对象。
```cpp</p>

<h1>include <string></h1>

<h1>include <vector></h1>

<p>class AddressBook
{</p>

<pre><code>public:
// 使用模板可以是我们忽略函数、仿函数和Lambda的不同
template&lt;typename Func&gt;
std::vector&lt;std::string&gt; findMatchingAddresses (Func func)
{ 
    std::vector&lt;std::string&gt; results;
    for ( auto itr = _addresses.begin(), end = _addresses.end(); itr != end; ++itr )
    {
        // 调用传递到findMatchingAddresses的函数并检测是否匹配规则
        if ( func( *itr ) )
        {
            results.push_back( *itr );
        }
    }
    return results;
}

private:
std::vector&lt;std::string&gt; _addresses;
</code></pre>

<p>};
```
任何人可以传递一个包含地址查找逻辑的函数给findMatchingAddresses。假如这个函数返回真，则得到相应的地址，地址将被返回。这种方式在以前的C++中一样支持，不过却遭遇一个致命缺陷：创建函数非常不方便。你必须先在其他地方定义好函数，你才能使用它。这就是Lambda出现的原因。</p>

<h2>基本Lambda语法</h2>

<p>在我们解决这个问题之前，让我们看一下真实的lambda基本语法。
```cpp</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>int main()
{</p>

<pre><code>auto func = [] () { cout &lt;&lt; "Hello world"; };
func(); // now call the function
</code></pre>

<p>}
```
好，你找到lambda了吗？它以[]开始。这个标识，叫做捕获指定器，它告诉编译器我们要创建一个lambda表达式。你将看到[](或者里面有变量）在每一个lambda函数的开始。</p>

<p>接着，像其他函数一样，我们需要一个参数列表：()。返回值呢？答案是我们不需要指定。在C++11中，假如编译器可以推导lambda函数的返回值，它将帮你做这件事而不需你显式指定。在这个例子里，编译器知道函数没有返回值。我们只是有一个打印“hello world"的函数体。这一行事实上不会触发关于打印的任何事：我们仅仅是创建了一个函数在这里。基本上相当于定义了一个普通函数。</p>

<p>我们在下面一行调用了这个lambda函数：func()，像调用其它普通函数一样。顺便看到，配合auto做这些事情是多么简单！你不用担心函数指针的丑陋语法。</p>

<h2>在我们的例子中应用Lambda</h2>

<p>让我们看看怎样将lambda应用到我们地址簿例子里，首先我们创建一个查找包含“.org"的email地址的简单函数。
```cpp
AddressBook global_address_book;</p>

<p>vector<string> findAddressesFromOrgs ()
{</p>

<pre><code>return global_address_book.findMatchingAddresses( 
    // we're declaring a lambda here; the [] signals the start
    [] (const string&amp; addr) { return addr.find( ".org" ) != string::npos; } 
);
</code></pre>

<p>}
```</p>

<!-- more -->


<p>再一次，我们以捕获指示符[]开始，但这一次我们有一个参数：地址，并且我们检测地址中是否含有“.org"。再一次说明，lambda的函数体并没有在这里执行；它只会在函数findMatchingAddresses内，当函数变量被使用时，lambda中的代码才会执行。换句话说，findMatchingAddresses的每个循环中会调用lambda函数，并传给它一个地址作为参数，然后这个函数检测地址是否包含“.org"。</p>

<h2>变量捕获</h2>

<p>虽然这些简单的lambda用法也不错，但变量捕获才是成就lambda卓越的秘方。假如你想创建一个查找包含指定名字的短函数。如果可以写出这样的代码是不是非常不错？
```cpp
// read in the name from a user, which we want to search
string name;
cin>> name;
return global_address_book.findMatchingAddresses(</p>

<pre><code>// 注意lambda函数使用了变量 'name'
[&amp;] (const string&amp; addr) { return addr.find( name ) != string::npos; } 
</code></pre>

<p>);
```
可以证明示例代码是合法的，并且它展现了lambda函数的价值。我们可以获取声明在lambda函数之外的变量(name)，并在lambda之内使用。当findMatchingAddresses调用我们的lambda函数，函数体会被执行，当addr.find被调用，它处理用户代码传进的name。为了使这可以运行的唯一要做的事是捕获变量。我用[&amp;]捕获指示做这件事，而不是用[]。[]是告诉编译器不捕获任何变量，而[&amp;]是告诉编译器去捕获变量。</p>

<p>是不是不可思议？我们创建了一个简单的可以捕获变量的函数，并将它传给find函数，所有这些只用了几行代码。如果不用C++11实现这些，我们需要创建一个仿函数或者给AddressBook类添加一个特殊方法。用C++11，我们可以轻易实现一个简单的接口函数，但支持各种检索的功能。</p>

<p>只是好玩，我们想查找email地址小于某个特殊长度的地址。我们可以再一次轻松实现：
<code>cpp
int min_len = 0;
cin &gt;&gt; min_len;
return global_address_book.find( [&amp;] (const string&amp; addr) { return addr.length() &gt;= min_len; } );
</code>
你将习惯于"})&ldquo;，这是lambda结束的标准语法，你开始阅读lambda相关代码或在你自己的代码中使用lambda越多，你将越多的看到这个小的代码片段。</p>

<h2>Lambda和STL</h2>

<p>毋庸质疑，lambda最大的一个优势是在使用STL中的算法(algorithms)库时。以前使用像for_each这样的算法是个体力活。然而现在使用for_each或其他STL算法就好像自己写普通循环一样。对比一下：
```cpp
vector<int> v;
v.push_back( 1 );
v.push_back( 2 );
//&hellip;
for ( auto itr = v.begin(), end = v.end(); itr != end; itr++ )
{</p>

<pre><code>cout &lt;&lt; *itr;
</code></pre>

<p>}
<code>
和：
</code>cpp
vector<int> v;
v.push_back( 1 );
v.push_back( 2 );
//&hellip;
for_each( v.begin(), v.end(), [] (int val)
{</p>

<pre><code>cout &lt;&lt; val;
</code></pre>

<p>} );
```
要我说后一种代码更漂亮，好在它的可读性和结构，也像个普通循环，并且可以利用上for_each可以提供的普通循环没有的一些优势，比如保证你有正确的结束条件。现在你可能会想，这会不会影响性能？意想不到的结论是for_each和普通循环有一样的性能，有时甚至更快（原因是循环展开）。</p>

<p>我希望STL的例子告诉你lambda不仅仅是创建函数的一种简便方式，它创造了一种新的编码方式，当你的代码作为数据处理函数时，你可以抽象处理特殊数据结构的方式。for_each适用于List，但是如果有处理“树”的类似函数是不是很酷？所有你要做的只是写处理每个节点的代码，而无需关心遍历算法。这种一个函数管理数据，将具体的数据处理过程委托到另一个函数的分解方式很有用。使用lambda，C++允许我们这种新的编程方式。这是我们以前没有的，但for_each不是新的，只不过以前我们不想用罢了。</p>

<h2>继续新的lambda语法</h2>

<p>其实参数列表像返回值一样都是可选的，如果你想创建一个不带参数的函数的话。或许最短的lambda是这样的：
<code>cpp
[]{}
</code>
这是一个即没有参数又什么也不干的函数。一个稍有内容的函数：
```cpp
using namespace std;</p>

<h1>include <iostream></h1>

<p>int main()
{</p>

<pre><code>[] { cout &lt;&lt; "Hello, my Greek friends"; }();
</code></pre>

<p>}
```
个人来讲，我不认可省略参数列表的价值。我认为[]和()的组合结构帮助lambda函数在代码上更出色。</p>

<h3>返回值</h3>

<p>如果你的lambda函数没有return语句，则默认返回void。假如你有一个简单的返回语句，编译器将推导返回值的类型：
<code>cpp
[](){return 1;} //编译器知道这是返回一个整型
</code>
假如你写一个更复杂些的lambda函数，不止一个返回值，你应该指定返回类型（有些编译器，像GCC，即使你有多于一个返回值也不需要你这样做，但标准不保证这一点）。
Lambda函数利用<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">C++11可选的新返回值语法</a>将返回值放在函数的后边。事实上假如你想指定返回类型，你一定要这样做。这里有一个显式指定返回值类型的简单例子：
<code>cpp
[] () -&gt; int { return 1; } // 现在你告诉编译器你想要什么
</code></p>

<h3>抛异常指示（throw)</h3>

<p>虽然C++标准委员会决定不赞成使用throw指示符，但throw还没被移除C++。这里有许多检测throw指示符的静态代码检测工具，像PC link。假如你使用这些工具中的一个去进行编译时异常检测，你肯定想知道你的lambda函数会抛出什么异常。这样做的主要原因可能是当你传递一个lambda函数到另一个函数中，而这个函数期望你的lambda只能抛出指定的异常。给你的lambda函数添加一个异常指示，将允许PC link这样的工具去帮你检测。如果你想这样做是可以的。这有一个无参且不抛出异常的lambda函数：
<code>cpp
[] () throw () { /* 你不希望抛出异常*/ }
</code></p>

<h2>Lambda函数是如何实现的？</h2>

<p>变量捕获的魔法是如何运作的？其实lambda实现的方法是创建一个简略的类。这个类重载了operator()，所以表现的像个普通函数。一个lambda函数是这个类的实例。当这个类构造的时候，所有捕获的变量被传送到类中并保存为成员变量。事实上这类似于以前就支持的functor。C++11的优势是这一切都变得非常简单。你可以在任意时候使用它，而不仅仅是极少的特殊场合去写一整个的类。</p>

<p>C++为性能计，实际上提供了好几种灵活的捕捉变量的方式，所有这些都是靠捕捉指示控制的[]。你已经看到了两种情况，[]中什么也没有则不捕获变量，用&amp;则变量以引用捕获。如果你创建了一个空[]的lambda函数，C++将创建一个普通的函数而不是类。这里有完整的捕获选项：</p>

<pre><code>[]  不捕获任何变量
[&amp;] 以引用方式捕获所有变量
[=] 用值的方式捕获所有变量（可能被编译器优化为const &amp;)
[=, &amp;foo] 以引用捕获foo, 但其余变量都靠值捕获
[bar] 以值方式捕获bar; 不捕获其它变量
[this] 捕获所在类的this指针
</code></pre>

<p>注意最后一个捕获选项，如果你已经指定了一个默认的捕获（=或者&amp;）那么也包含this。但是能捕获this指针的能力非常重要，这意味着写函数时你不需要区分局部变量和类属性的不同，两者都可以获取到。酷的是你不需显式指定this指针。它真的像你在写一个内联函数。
```cpp
class Foo
{
public:</p>

<pre><code>Foo () : _x( 3 ) {}
void func ()
{
    // a very silly, but illustrative way of printing out the value of _x
    [this] () { cout &lt;&lt; _x; } ();
}
</code></pre>

<p>private:</p>

<pre><code>    int _x;
</code></pre>

<p>};</p>

<p>int main()
{</p>

<pre><code>Foo f;
f.func();
</code></pre>

<p>}
```</p>

<h3>捕获引用的优缺点</h3>

<p>以引用捕获变量时，可以在lambda函数内修改局部变量的值。这也意味着从一个函数中返回一个lambda函数，你不能以引用捕获变量，因为引用的值在函数返回时已经无效了。</p>

<h2>lambda函数的类型是什么？</h2>

<p>创建lambda函数的一个原因是有些人创建了一个希望接受lambda函数的函数。我们已经看到了我们使用模板去接收lambda函数作为参数，并且使用auto去接这个lambda函数作为一个局部变量。但是你如何命名指定的lambda函数？因为像前面看到的一样，每一个lambda函数都实现为一个独立的类，所以即使是拥有相同类型和返回值的lambda函数也是不同的类型。但C++11提供了一个便捷的外敷类去存储任何类型的函数，lambda函数、仿函数和函数指针。</p>

<h3>std::function</h3>

<p>新的std::function是传递lambda函数的最好的方式，不管是传递参数还是返回值。它允许你在模板中指定参数列表和返回值的确切类型。这里有AddressBook的例子，这次我们使用std::function代替模板。注意我们用到了'functional'头文件。
```cpp</p>

<h1>include <functional></h1>

<h1>include <vector></h1>

<p>class AddressBook
{</p>

<pre><code>public:
std::vector&lt;string&gt; findMatchingAddresses (std::function&lt;bool (const string&amp;)&gt; func)
{ 
    std::vector&lt;string&gt; results;
    for ( auto itr = _addresses.begin(), end = _addresses.end(); itr != end; ++itr )
    {
        // 调用传递到findMatchingAddresses的函数并检测是否匹配规则
        if ( func( *itr ) )
        {
            results.push_back( *itr );
        }
    }
    return results;
}

private:
std::vector&lt;string&gt; _addresses;
</code></pre>

<p>};
```
std::function较模板的一大优势是，使用模板你必须将整个函数放到头文件中，而std::function则不用。当你的代码变化频繁并且被好多代码文件引用时，这会非常有用。</p>

<p>假如你想检测std::function是否含有一个有效的函数，把它当作boolean就可以了：
```cpp
std::function<int ()> func;
// 检测是否包含函数
if ( func )
{</p>

<pre><code>// if we did have a function, call it
func();
</code></pre>

<p>}
```</p>

<h3>关于函数指针的提示</h3>

<p>在最终的C++11标准中，假如你有一个指定空捕获列表的lambda函数，那它将像普通函数一样并可以被赋值到一个函数指针。这有一个作为指针使用空捕获列表lambda的例子：
<code>cpp
typedef int (*func)();
func f = [] () -&gt; int { return 2; };
f();
</code>
这样是可以的，因为lambda函数没有捕获组，那也就不需要自己的类。它可以被编译成普通函数，运行被传递给普通函数。不幸的是这个特性没有被包含到MSVC10中，它被加入到标准的时间太晚了。</p>

<h2>使用Lambda实现委托</h2>

<p>让我们在看一个lambda函数的例子，这次我们创建一个委托。当调用一个普通函数时，你只需要知道这个函数。而调用类的成员函数时，你需要知道两件东西：成员函数和类对象。这是func()和obj.method()的不同。要调用一个成员方法，你需要两者，仅仅将函数地址传进去是不够的，你需要一个对象去调用这个函数。</p>

<p>让我们看一个例子：
```cpp</p>

<h1>include <functional></h1>

<h1>include <string></h1>

<p>class EmailProcessor
{
public:</p>

<pre><code>void receiveMessage (const std::string&amp; message)
{
    if ( _handler_func ) 
    {
        _handler_func( message );
    }
    // other processing
}
void setHandlerFunc (std::function&lt;void (const std::string&amp;)&gt; handler_func)
{
    _handler_func = handler_func;
}
</code></pre>

<p>private:</p>

<pre><code>    std::function&lt;void (const std::string&amp;)&gt; _handler_func;
</code></pre>

<p>};
<code>
这是注册回调函数到类里的很典型的模式，当感兴趣的事情发生时会调用回调函数。接着我们希望另一个类负责跟踪最长的消息（为什么这么做，或许你是一个无聊的管理员）。总之我们创建了如下的类：
</code>cpp</p>

<h1>include <string></h1>

<p>class MessageSizeStore
{</p>

<pre><code>MessageSizeStore () : _max_size( 0 ) {}
void checkMessage (const std::string&amp; message ) 
{
    const int size = message.length();
    if ( size &gt; _max_size )
    {
        _max_size = size;
    }
}
int getSize ()
{
    return _max_size;
}
</code></pre>

<p>private:</p>

<pre><code>int _max_size;
</code></pre>

<p>};
<code>
如果我们想让checkMessage在消息来时被调用，我们该怎么做？我们不能只传进checkMessage自己。它是个成员方法，所以它需要一个对象。
</code>cpp
EmailProcessor processor;
MessageSizeStore size_store;
processor.setHandlerFunc( checkMessage ); // 这行不通
<code>
我们需要绑定setHandleFunc和size_store变量的方法。恩，听起来是lambda的拿手好戏！
</code>cpp
EmailProcessor processor;
MessageSizeStore size_store;
processor.setHandlerFunc(</p>

<pre><code>    [&amp;] (const std::string&amp; message) { size_store.checkMessage( message ); } 
</code></pre>

<p>);
```
够酷吧，我们这里把lambda使成了胶水代码，允许我们传递普通函数到setHandleFunc，实际上调用的还是委托类的成员函数。</p>

<h2>总结</h2>

<p>lambda函数会不会出现在C++代码的各种地方？我觉得会。我开始使用lambda函数在更富生产力的代码中，它们出现在所有的地方：一些为精简代码、一些为支持单元测试、一些代替以前用宏实现的代码。Year，我想lambda比其它希腊字母要酷。</p>

<p>下一篇：<a href="/blog/2013/08/20/ranged-for-loop/">区间迭代</a></p>

<p>上一篇：<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html">C++11 &ndash; Lambda Closures, the Definitive Guide &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-改进的类型推导：auto、decltype和新的函数语法]]></title>
    <link href="http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11/"/>
    <updated>2013-08-08T00:18:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11</id>
    <content type="html"><![CDATA[<p>C++11引入了一些新的实用的类型推导能力，这意味着你可以花费更少的时间去写那些编译器已经知道的东西。当然有些时候你需要帮助编译器或者你的编程伙伴。但是C++11，你可以在一些乏味的东西上花更少的时间，而多去关注逻辑本身。</p>

<h2>auto之乐</h2>

<p>我们先快速回顾一下auto，万一你没有读<a href="/blog/2013/08/01/what-is-cpp11/">第一篇C++11文章</a>中关于auto的部分。在C++11中，如果编译器在定义一个变量的时候可以推断出变量的类型，不用写变量的类型，你只需写auto即可。
<code>cpp
int x = 4;
</code>
现在可以这样写：
<code>cpp
auto x = 4;
</code>
这当然不是auto预期的用途！它会在模板和迭代器的配合使用中闪耀光芒：
<code>cpp
vector&lt;int&gt; vec;
auto itr = vec.iterator();
</code>
其它时候auto也会非常有用。比如，你有一些下面格式的代码：
```cpp
template <typename BuiltType, typename Builder>
void
makeAndProcessObject (const Builder&amp; builder)
{</p>

<pre><code>BuiltType val = builder.makeObject();
// do stuff with val
</code></pre>

<p>}
<code>
上面的代码，我们看到这里需要两个模板参数：一个是Builder对象的类型，另一个是Builder创建出的对象的类型。糟糕的是创建出的类型无法被推导出，所以每次你必须这样调用：
</code>cpp
MyObjBuilder builder;
makeAndProcessObject<MyObj>( builder );
<code>
但是auto立即将丑陋的代码一扫无余，当Builder创建对象时不用写特殊代码了，你可以让C++帮你做：
</code>cpp
template <typename Builder>
void
makeAndProcessObject (const Builder&amp; builder)
{</p>

<pre><code>auto val = builder.makeObject();
// do stuff with val
</code></pre>

<p>}
<code>
现在你仅需一个模板参数，而且这个参数可以在函数调用的时候轻松推导：
</code>cpp
MyObjBuilder builder;
makeAndProcessObject( builder );
```
这样更易调用了，并且没丢失可读性，却更清晰了。</p>

<h2>decltype和新的返回值语法</h2>

<p>现在你可能会说auto就这样吗，假如我想返回Builder创建的对象怎么办？我还是需要提供一个模板参数作为返回值的类型。好！这充分证明了标准委员有一群聪明的家伙，对这个问题他们早想好了一个完美的解决方案。这个方案由两部分组成：decltype和新的返回值语法。</p>

<h3>新的返回值语法</h3>

<p>让我们讲一下新的返回值语法，这个语法还能看到auto的另一个用处。在以前版本的C和C++中，返回值的类型必须写在函数的前面：
<code>cpp
int multiply(int x, int y);
</code>
在C++11中，你可以把返回类型放在函数声明的后面，用auto代替前面的返回类型，像这样：
<code>cpp
auto multiply(int x, int y) -&gt; int;
</code>
但是为什么我要这样用？让我们看一个证明这个语法好处的例子。一个包含枚举的类：
```cpp
class Person
{
public:</p>

<pre><code>enum PersonType { ADULT, CHILD, SENIOR };
void setPersonType (PersonType person_type);
PersonType getPersonType ();
</code></pre>

<p>private:</p>

<pre><code>PersonType _person_type;
</code></pre>

<p>};
<code>
我们写了一个简单的类，里面有一个类型PersonType表明Person是小孩、成人和老人。不做特殊考虑，我们定义这些成员方法时会发生什么？
第一个设置方法，很简单，你可以使用枚举类型PersonType而不会有错误：
</code>cpp
void Person::setPersonType (PersonType person_type)
{</p>

<pre><code>_person_type = person_type;
</code></pre>

<p>}
<code>
而第二个方法却是一团糟。简单的代码却编译不过：
</code>cpp
// 编译器不知道PersonType是什么，因为PersonType会在Person类之外使用
PersonType Person::getPersonType ()
{</p>

<pre><code>return _person_type;
</code></pre>

<p>}
<code>
你必须要这样写，才能使返回值正常工作
</code>cpp
Person::PersonType Person::getPersonType ()
{</p>

<pre><code>return _person_type;
</code></pre>

<p>}
```
这可能不算大问题，不过会容易出错，尤其是牵连进模板的时候。</p>

<p>这就是新的返回值语法引进的原因。因为函数的返回值出现在函数的最后，而不是前面，你不需要补全类作用域。当编译器解析到返回值的时候，它已经知道返回值属于Person类，所以它也知道PersonType是什么。
```cpp
auto Person::getPersonType () &ndash;> PersonType
{</p>

<pre><code>return _person_type;
</code></pre>

<p>}
```
好，这确实不错，但它真的能帮助我们什么吗？我们还不能使用新的返回值语法去解决我们之前的问题，我们能吗？不能，让我们介绍新的概念：decltype。</p>

<h2>decltype</h2>

<p>decltype是auto的反面兄弟。auto让你声明了一个指定类型的变量，decltype让你从一个变量（或表达式）中得到类型。我说的是什么？
<code>cpp
int x = 3;
decltype(x) y = x; // 相当于 auto y = x;
</code>
可以对基本上任何类型使用decltype，包括函数的返回值。嗯，听起来像个熟悉的问题，假如我们这样写：
<code>cpp
decltype( builder.makeObject() )
</code>
我们将得到makeObject的返回值类型，这能让我们指定makeAndProcessObject的返回类型。我们可以整合进新的返回值语法：
```cpp
template <typename Builder>
auto
makeAndProcessObject (const Builder&amp; builder) &ndash;> decltype( builder.makeObject() )
{</p>

<pre><code>auto val = builder.makeObject();
// do stuff with val
return val;
</code></pre>

<p>}
```
这仅适用于新的返回值语法，因为旧的语法下，我们在声明函数返回值的时候无法引用函数参数，而新语法，所有的参数都是可访问的。</p>

<h2>auto：引用、指针和常量</h2>

<p>下面要确定的一个问题是auto如何处理引用：
```cpp
int&amp; foo();</p>

<p>auto bar = foo(); // int&amp; or int?
<code>
答案是在C++11中，auto处理引用时默认是值类型，所以下面的代码bar是int。不过你可以指定&amp;作为修饰符强制它作为引用：
</code>cpp
int&amp; foo();</p>

<p>auto bar = foo(); // int
auto&amp; baz = foo(); // int&amp;
<code>
不过，假如你有一个指针auto则自动获取指针类型：
</code>cpp
int* foo();</p>

<p>auto p_bar = foo(); // int<em>
<code>
但是你也可以显式指定表明变量是一个指针：
</code>cpp
int</em> foo();
auto <em>p_baz = foo(); // int</em>
<code>
当处理引用时，你一样可以标记const，如果需要的话：
</code>cpp
int&amp; foo();</p>

<p>const auto&amp; baz = foo(); // const int&amp;
<code>
或者指针：
</code>cpp
int<em> foo();
const int</em> const_foo();
const auto<em> p_bar = foo(); // const int</em>
auto p_bar = const_foo(); // const int*
```
所有这些都很自然，并且这遵循C++模板中类型推导的规则。</p>

<p>下一篇：<a href="/blog/2013/08/11/lambda-closures/">Lambda表达式简明教程</a></p>

<p>上一篇：<a href="/blog/2013/08/01/what-is-cpp11/">什么是C++11</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html">C++11 &ndash; Auto, Decltype and return values after functions &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
</feed>
