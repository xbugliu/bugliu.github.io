<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2013-08-18T21:38:04+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++11系列-lambda函数]]></title>
    <link href="http://towriting.com/blog/2013/08/11/lambda-closures/"/>
    <updated>2013-08-11T22:45:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/11/lambda-closures</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/posts/lambda-closures/lambda.png" width="66" height="90" title="&lsquo;lambda&rsquo; &lsquo;C++11一个最激动人心的特性是支持创建lambda函数（有时称为闭包）。这意味着什么？一个Lambda函数是一个可以内联写在你代码中的函数（通常也会传递给另外的函数，类似于仿函数或函数指针）。使用Lambda，创建机动函数会更简单，而以前你必须创建一个有名函数。在这篇文章中，我先用一些例子解释为什么lambda很酷，然后我会讲解可能会用到的关于lambda的所有细节。&rsquo;" ></p>

<h2>为什么Lambda很酷</h2>

<p>想象你有一个地址簿类，并且你想要提供一个可供检索的函数。你可能会提供一个简单的函数，接受一个字符串然后返回满足所有字符串的地址。有时有些用户可能希望这样。不过假如他们只是想检索域名或者检索用户名并且忽略域名结果；或者检索出现在其他列表中的所有Email地址。这里可能有许多可能的检索方式。除了类中集成所有这些搜索选项，提供一个通用的查找方法，这个方法接受一个查找规则的函数，这样不是更好些吗？让我们叫这个函数findMatchingAddresses，它接受一个函数或仿函数对象。
```cpp</p>

<h1>include <string></h1>

<h1>include <vector></h1>

<p>class AddressBook
{</p>

<pre><code>public:
// 使用模板可以是我们忽略函数、仿函数和Lambda的不同
template&lt;typename Func&gt;
std::vector&lt;std::string&gt; findMatchingAddresses (Func func)
{ 
    std::vector&lt;std::string&gt; results;
    for ( auto itr = _addresses.begin(), end = _addresses.end(); itr != end; ++itr )
    {
        // 调用传递到findMatchingAddresses的函数并检测是否匹配规则
        if ( func( *itr ) )
        {
            results.push_back( *itr );
        }
    }
    return results;
}

private:
std::vector&lt;std::string&gt; _addresses;
</code></pre>

<p>};
```
任何人可以传递一个包含地址查找逻辑的函数给findMatchingAddresses。假如这个函数返回真，则得到相应的地址，地址将被返回。这种方式在以前的C++中一样支持，不过却遭遇一个致命缺陷：创建函数非常不方便。你必须先在其他地方定义好函数，你才能使用它。这就是Lambda出现的原因。</p>

<h2>基本Lambda语法</h2>

<p>在我们解决这个问题之前，让我们看一下真实的lambda基本语法。
```cpp</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>int main()
{</p>

<pre><code>auto func = [] () { cout &lt;&lt; "Hello world"; };
func(); // now call the function
</code></pre>

<p>}
```
好，你找到lambda了吗？它以[]开始。这个标识，叫做捕获指定器，它告诉编译器我们要创建一个lambda表达式。你将看到[](或者里面有变量）在每一个lambda函数的开始。</p>

<p>接着，像其他函数一样，我们需要一个参数列表：()。返回值呢？答案是我们不需要指定。在C++11中，假如编译器可以推导lambda函数的返回值，它将帮你做这件事而不需你显式指定。在这个例子里，编译器知道函数没有返回值。我们只是有一个打印“hello world"的函数体。这一行事实上不会触发关于打印的任何事：我们仅仅是创建了一个函数在这里。基本上相当于定义了一个普通函数。</p>

<p>我们在下面一行调用了这个lambda函数：func()，像调用其它普通函数一样。顺便看到，配合auto做这些事情是多么简单！你不用担心函数指针的丑陋语法。</p>

<h2>在我们的例子中应用Lambda</h2>

<p>让我们看看怎样将lambda应用到我们地址簿例子里，首先我们创建一个查找包含“.org"的email地址的简单函数。
```cpp
AddressBook global_address_book;</p>

<p>vector<string> findAddressesFromOrgs ()
{</p>

<pre><code>return global_address_book.findMatchingAddresses( 
    // we're declaring a lambda here; the [] signals the start
    [] (const string&amp; addr) { return addr.find( ".org" ) != string::npos; } 
);
</code></pre>

<p>}
```</p>

<!-- more -->


<p>再一次，我们以捕获指示符[]开始，但这一次我们有一个参数：地址，并且我们检测地址中是否含有“.org"。再一次说明，lambda的函数体并没有在这里执行；它只会在函数findMatchingAddresses内，当函数变量被使用时，lambda中的代码才会执行。换句话说，findMatchingAddresses的每个循环中会调用lambda函数，并传给它一个地址作为参数，然后这个函数检测地址是否包含“.org"。</p>

<h2>变量捕获</h2>

<p>虽然这些简单的lambda用法也不错，但变量捕获才是成就lambda卓越的秘方。假如你想创建一个查找包含指定名字的短函数。如果可以写出这样的代码是不是非常不错？
```cpp
// read in the name from a user, which we want to search
string name;
cin>> name;
return global_address_book.findMatchingAddresses(</p>

<pre><code>// 注意lambda函数使用了变量 'name'
[&amp;] (const string&amp; addr) { return addr.find( name ) != string::npos; } 
</code></pre>

<p>);
```
可以证明示例代码是合法的，并且它展现了lambda函数的价值。我们可以获取声明在lambda函数之外的变量(name)，并在lambda之内使用。当findMatchingAddresses调用我们的lambda函数，函数体会被执行，当addr.find被调用，它处理用户代码传进的name。为了使这可以运行的唯一要做的事是捕获变量。我用[&amp;]捕获指示做这件事，而不是用[]。[]是告诉编译器不捕获任何变量，而[&amp;]是告诉编译器去捕获变量。</p>

<p>是不是不可思议？我们创建了一个简单的可以捕获变量的函数，并将它传给find函数，所有这些只用了几行代码。如果不用C++11实现这些，我们需要创建一个仿函数或者给AddressBook类添加一个特殊方法。用C++11，我们可以轻易实现一个简单的接口函数，但支持各种检索的功能。</p>

<p>只是好玩，我们想查找email地址小于某个特殊长度的地址。我们可以再一次轻松实现：
<code>cpp
int min_len = 0;
cin &gt;&gt; min_len;
return global_address_book.find( [&amp;] (const string&amp; addr) { return addr.length() &gt;= min_len; } );
</code>
你将习惯于"})&ldquo;，这是lambda结束的标准语法，你开始阅读lambda相关代码或在你自己的代码中使用lambda越多，你将越多的看到这个小的代码片段。</p>

<h2>Lambda和STL</h2>

<p>毋庸质疑，lambda最大的一个优势是在使用STL中的算法(algorithms)库时。以前使用像for_each这样的算法是个体力活。然而现在使用for_each或其他STL算法就好像自己写普通循环一样。对比一下：
```cpp
vector<int> v;
v.push_back( 1 );
v.push_back( 2 );
//&hellip;
for ( auto itr = v.begin(), end = v.end(); itr != end; itr++ )
{</p>

<pre><code>cout &lt;&lt; *itr;
</code></pre>

<p>}
<code>
和：
</code>cpp
vector<int> v;
v.push_back( 1 );
v.push_back( 2 );
//&hellip;
for_each( v.begin(), v.end(), [] (int val)
{</p>

<pre><code>cout &lt;&lt; val;
</code></pre>

<p>} );
```
要我说后一种代码更漂亮，好在它的可读性和结构，也像个普通循环，并且可以利用上for_each可以提供的普通循环没有的一些优势，比如保证你有正确的结束条件。现在你可能会想，这会不会影响性能？意想不到的结论是for_each和普通循环有一样的性能，有时甚至更快（原因是循环展开）。</p>

<p>我希望STL的例子告诉你lambda不仅仅是创建函数的一种简便方式，它创造了一种新的编码方式，当你的代码作为数据处理函数时，你可以抽象处理特殊数据结构的方式。for_each适用于List，但是如果有处理“树”的类似函数是不是很酷？所有你要做的只是写处理每个节点的代码，而无需关心遍历算法。这种一个函数管理数据，将具体的数据处理过程委托到另一个函数的分解方式很有用。使用lambda，C++允许我们这种新的编程方式。这是我们以前没有的，但for_each不是新的，只不过以前我们不想用罢了。</p>

<h2>继续新的lambda语法</h2>

<p>其实参数列表像返回值一样都是可选的，如果你想创建一个不带参数的函数的话。或许最短的lambda是这样的：
<code>cpp
[]{}
</code>
这是一个即没有参数又什么也不干的函数。一个稍有内容的函数：
```cpp
using namespace std;</p>

<h1>include <iostream></h1>

<p>int main()
{</p>

<pre><code>[] { cout &lt;&lt; "Hello, my Greek friends"; }();
</code></pre>

<p>}
```
个人来讲，我不认可省略参数列表的价值。我认为[]和()的组合结构帮助lambda函数在代码上更出色。</p>

<h3>返回值</h3>

<p>如果你的lambda函数没有return语句，则默认返回void。假如你有一个简单的返回语句，编译器将推导返回值的类型：
<code>cpp
[](){return 1;} //编译器知道这是返回一个整型
</code>
假如你写一个更复杂些的lambda函数，不止一个返回值，你应该指定返回类型（有些编译器，像GCC，即使你有多于一个返回值也不需要你这样做，但标准不保证这一点）。
Lambda函数利用<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">C++11可选的新返回值语法</a>将返回值放在函数的后边。事实上假如你想指定返回类型，你一定要这样做。这里有一个显式指定返回值类型的简单例子：
<code>cpp
[] () -&gt; int { return 1; } // 现在你告诉编译器你想要什么
</code></p>

<h3>抛异常指示（throw)</h3>

<p>虽然C++标准委员会决定不赞成使用throw指示符，但throw还没被移除C++。这里有许多检测throw指示符的静态代码检测工具，像PC link。假如你使用这些工具中的一个去进行编译时异常检测，你肯定想知道你的lambda函数会抛出什么异常。这样做的主要原因可能是当你传递一个lambda函数到另一个函数中，而这个函数期望你的lambda只能抛出指定的异常。给你的lambda函数添加一个异常指示，将允许PC link这样的工具去帮你检测。如果你想这样做是可以的。这有一个无参且不抛出异常的lambda函数：
<code>cpp
[] () throw () { /* 你不希望抛出异常*/ }
</code></p>

<h2>Lambda函数是如何实现的？</h2>

<p>变量捕获的魔法是如何运作的？其实lambda实现的方法是创建一个简略的类。这个类重载了operator()，所以表现的像个普通函数。一个lambda函数是这个类的实例。当这个类构造的时候，所有捕获的变量被传送到类中并保存为成员变量。事实上这类似于以前就支持的functor。C++11的优势是这一切都变得非常简单。你可以在任意时候使用它，而不仅仅是极少的特殊场合去写一整个的类。</p>

<p>C++为性能计，实际上提供了好几种灵活的捕捉变量的方式，所有这些都是靠捕捉指示控制的[]。你已经看到了两种情况，[]中什么也没有则不捕获变量，用&amp;则变量以引用捕获。如果你创建了一个空[]的lambda函数，C++将创建一个普通的函数而不是类。这里有完整的捕获选项：</p>

<pre><code>[]  不捕获任何变量
[&amp;] 以引用方式捕获所有变量
[=] 用值的方式捕获所有变量（可能被编译器优化为const &amp;)
[=, &amp;foo] 以引用捕获foo, 但其余变量都靠值捕获
[bar] 以值方式捕获bar; 不捕获其它变量
[this] 捕获所在类的this指针
</code></pre>

<p>注意最后一个捕获选项，如果你已经指定了一个默认的捕获（=或者&amp;）那么也包含this。但是能捕获this指针的能力非常重要，这意味着写函数时你不需要区分局部变量和类属性的不同，两者都可以获取到。酷的是你不需显式指定this指针。它真的像你在写一个内联函数。
```cpp
class Foo
{
public:</p>

<pre><code>Foo () : _x( 3 ) {}
void func ()
{
    // a very silly, but illustrative way of printing out the value of _x
    [this] () { cout &lt;&lt; _x; } ();
}
</code></pre>

<p>private:</p>

<pre><code>    int _x;
</code></pre>

<p>};</p>

<p>int main()
{</p>

<pre><code>Foo f;
f.func();
</code></pre>

<p>}
```</p>

<h3>捕获引用的优缺点</h3>

<p>以引用捕获变量时，可以在lambda函数内修改局部变量的值。这也意味着从一个函数中返回一个lambda函数，你不能以引用捕获变量，因为引用的值在函数返回时已经无效了。</p>

<h2>lambda函数的类型是什么？</h2>

<p>创建lambda函数的一个原因是有些人创建了一个希望接受lambda函数的函数。我们已经看到了我们使用模板去接收lambda函数作为参数，并且使用auto去接这个lambda函数作为一个局部变量。但是你如何命名指定的lambda函数？因为像前面看到的一样，每一个lambda函数都实现为一个独立的类，所以即使是拥有相同类型和返回值的lambda函数也是不同的类型。但C++11提供了一个便捷的外敷类去存储任何类型的函数，lambda函数、仿函数和函数指针。</p>

<h3>std::function</h3>

<p>新的std::function是传递lambda函数的最好的方式，不管是传递参数还是返回值。它允许你在模板中指定参数列表和返回值的确切类型。这里有AddressBook的例子，这次我们使用std::function代替模板。注意我们用到了'functional'头文件。
```cpp</p>

<h1>include <functional></h1>

<h1>include <vector></h1>

<p>class AddressBook
{</p>

<pre><code>public:
std::vector&lt;string&gt; findMatchingAddresses (std::function&lt;bool (const string&amp;)&gt; func)
{ 
    std::vector&lt;string&gt; results;
    for ( auto itr = _addresses.begin(), end = _addresses.end(); itr != end; ++itr )
    {
        // 调用传递到findMatchingAddresses的函数并检测是否匹配规则
        if ( func( *itr ) )
        {
            results.push_back( *itr );
        }
    }
    return results;
}

private:
std::vector&lt;string&gt; _addresses;
</code></pre>

<p>};
```
std::function较模板的一大优势是，使用模板你必须将整个函数放到头文件中，而std::function则不用。当你的代码变化频繁并且被好多代码文件引用时，这会非常有用。</p>

<p>假如你想检测std::function是否含有一个有效的函数，把它当作boolean就可以了：
```cpp
std::function<int ()> func;
// 检测是否包含函数
if ( func )
{</p>

<pre><code>// if we did have a function, call it
func();
</code></pre>

<p>}
```</p>

<h3>关于函数指针的提示</h3>

<p>在最终的C++11标准中，假如你有一个指定空捕获列表的lambda函数，那它将像普通函数一样并可以被赋值到一个函数指针。这有一个作为指针使用空捕获列表lambda的例子：
<code>cpp
typedef int (*func)();
func f = [] () -&gt; int { return 2; };
f();
</code>
这样是可以的，因为lambda函数没有捕获组，那也就不需要自己的类。它可以被编译成普通函数，运行被传递给普通函数。不幸的是这个特性没有被包含到MSVC10中，它被加入到标准的时间太晚了。</p>

<h2>使用Lambda实现委托</h2>

<p>让我们在看一个lambda函数的例子，这次我们创建一个委托。当调用一个普通函数时，你只需要知道这个函数。而调用类的成员函数时，你需要知道两件东西：成员函数和类对象。这是func()和obj.method()的不同。要调用一个成员方法，你需要两者，仅仅将函数地址传进去是不够的，你需要一个对象去调用这个函数。</p>

<p>让我们看一个例子：
```cpp</p>

<h1>include <functional></h1>

<h1>include <string></h1>

<p>class EmailProcessor
{
public:</p>

<pre><code>void receiveMessage (const std::string&amp; message)
{
    if ( _handler_func ) 
    {
        _handler_func( message );
    }
    // other processing
}
void setHandlerFunc (std::function&lt;void (const std::string&amp;)&gt; handler_func)
{
    _handler_func = handler_func;
}
</code></pre>

<p>private:</p>

<pre><code>    std::function&lt;void (const std::string&amp;)&gt; _handler_func;
</code></pre>

<p>};
<code>
这是注册回调函数到类里的很典型的模式，当感兴趣的事情发生时会调用回调函数。接着我们希望另一个类负责跟踪最长的消息（为什么这么做，或许你是一个无聊的管理员）。总之我们创建了如下的类：
</code>cpp</p>

<h1>include <string></h1>

<p>class MessageSizeStore
{</p>

<pre><code>MessageSizeStore () : _max_size( 0 ) {}
void checkMessage (const std::string&amp; message ) 
{
    const int size = message.length();
    if ( size &gt; _max_size )
    {
        _max_size = size;
    }
}
int getSize ()
{
    return _max_size;
}
</code></pre>

<p>private:</p>

<pre><code>int _max_size;
</code></pre>

<p>};
<code>
如果我们想让checkMessage在消息来时被调用，我们该怎么做？我们不能只传进checkMessage自己。它是个成员方法，所以它需要一个对象。
</code>cpp
EmailProcessor processor;
MessageSizeStore size_store;
processor.setHandlerFunc( checkMessage ); // 这行不通
<code>
我们需要绑定setHandleFunc和size_store变量的方法。恩，听起来是lambda的拿手好戏！
</code>cpp
EmailProcessor processor;
MessageSizeStore size_store;
processor.setHandlerFunc(</p>

<pre><code>    [&amp;] (const std::string&amp; message) { size_store.checkMessage( message ); } 
</code></pre>

<p>);
```
够酷吧，我们这里把lambda使成了胶水代码，允许我们传递普通函数到setHandleFunc，实际上调用的还是委托类的成员函数。</p>

<h2>总结</h2>

<p>lambda函数会不会出现在C++代码的各种地方？我觉得会。我开始使用lambda函数在更富生产力的代码中，它们出现在所有的地方：一些为精简代码、一些为支持单元测试、一些代替以前用宏实现的代码。Year，我想lambda比其它希腊字母要酷。</p>

<p>下一篇：区间迭代</p>

<p>上一篇：<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html">C++11 &ndash; Lambda Closures, the Definitive Guide &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-改进的类型推导：auto、decltype和新的函数语法]]></title>
    <link href="http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11/"/>
    <updated>2013-08-08T00:18:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11</id>
    <content type="html"><![CDATA[<p>C++11引入了一些新的实用的类型推导能力，这意味着你可以花费更少的时间去写那些编译器已经知道的东西。当然有些时候你需要帮助编译器或者你的编程伙伴。但是C++11，你可以在一些乏味的东西上花更少的时间，而多去关注逻辑本身。</p>

<h2>auto之乐</h2>

<p>我们先快速回顾一下auto，万一你没有读<a href="/blog/2013/08/01/what-is-cpp11/">第一篇C++11文章</a>中关于auto的部分。在C++11中，如果编译器在定义一个变量的时候可以推断出变量的类型，不用写变量的类型，你只需写auto即可。
<code>cpp
int x = 4;
</code>
现在可以这样写：
<code>cpp
auto x = 4;
</code>
这当然不是auto预期的用途！它会在模板和迭代器的配合使用中闪耀光芒：
<code>cpp
vector&lt;int&gt; vec;
auto itr = vec.iterator();
</code>
其它时候auto也会非常有用。比如，你有一些下面格式的代码：
```cpp
template <typename BuiltType, typename Builder>
void
makeAndProcessObject (const Builder&amp; builder)
{</p>

<pre><code>BuiltType val = builder.makeObject();
// do stuff with val
</code></pre>

<p>}
<code>
上面的代码，我们看到这里需要两个模板参数：一个是Builder对象的类型，另一个是Builder创建出的对象的类型。糟糕的是创建出的类型无法被推导出，所以每次你必须这样调用：
</code>cpp
MyObjBuilder builder;
makeAndProcessObject<MyObj>( builder );
<code>
但是auto立即将丑陋的代码一扫无余，当Builder创建对象时不用写特殊代码了，你可以让C++帮你做：
</code>cpp
template <typename Builder>
void
makeAndProcessObject (const Builder&amp; builder)
{</p>

<pre><code>auto val = builder.makeObject();
// do stuff with val
</code></pre>

<p>}
<code>
现在你仅需一个模板参数，而且这个参数可以在函数调用的时候轻松推导：
</code>cpp
MyObjBuilder builder;
makeAndProcessObject( builder );
```
这样更易调用了，并且没丢失可读性，却更清晰了。</p>

<h2>decltype和新的返回值语法</h2>

<p>现在你可能会说auto就这样吗，假如我想返回Builder创建的对象怎么办？我还是需要提供一个模板参数作为返回值的类型。好！这充分证明了标准委员有一群聪明的家伙，对这个问题他们早想好了一个完美的解决方案。这个方案由两部分组成：decltype和新的返回值语法。</p>

<h3>新的返回值语法</h3>

<p>让我们讲一下新的返回值语法，这个语法还能看到auto的另一个用处。在以前版本的C和C++中，返回值的类型必须写在函数的前面：
<code>cpp
int multiply(int x, int y);
</code>
在C++11中，你可以把返回类型放在函数声明的后面，用auto代替前面的返回类型，像这样：
<code>cpp
auto multiply(int x, int y) -&gt; int;
</code>
但是为什么我要这样用？让我们看一个证明这个语法好处的例子。一个包含枚举的类：
```cpp
class Person
{
public:</p>

<pre><code>enum PersonType { ADULT, CHILD, SENIOR };
void setPersonType (PersonType person_type);
PersonType getPersonType ();
</code></pre>

<p>private:</p>

<pre><code>PersonType _person_type;
</code></pre>

<p>};
<code>
我们写了一个简单的类，里面有一个类型PersonType表明Person是小孩、成人和老人。不做特殊考虑，我们定义这些成员方法时会发生什么？
第一个设置方法，很简单，你可以使用枚举类型PersonType而不会有错误：
</code>cpp
void Person::setPersonType (PersonType person_type)
{</p>

<pre><code>_person_type = person_type;
</code></pre>

<p>}
<code>
而第二个方法却是一团糟。简单的代码却编译不过：
</code>cpp
// 编译器不知道PersonType是什么，因为PersonType会在Person类之外使用
PersonType Person::getPersonType ()
{</p>

<pre><code>return _person_type;
</code></pre>

<p>}
<code>
你必须要这样写，才能使返回值正常工作
</code>cpp
Person::PersonType Person::getPersonType ()
{</p>

<pre><code>return _person_type;
</code></pre>

<p>}
```
这可能不算大问题，不过会容易出错，尤其是牵连进模板的时候。</p>

<p>这就是新的返回值语法引进的原因。因为函数的返回值出现在函数的最后，而不是前面，你不需要补全类作用域。当编译器解析到返回值的时候，它已经知道返回值属于Person类，所以它也知道PersonType是什么。
```cpp
auto Person::getPersonType () &ndash;> PersonType
{</p>

<pre><code>return _person_type;
</code></pre>

<p>}
```
好，这确实不错，但它真的能帮助我们什么吗？我们还不能使用新的返回值语法去解决我们之前的问题，我们能吗？不能，让我们介绍新的概念：decltype。</p>

<h2>decltype</h2>

<p>decltype是auto的反面兄弟。auto让你声明了一个指定类型的变量，decltype让你从一个变量（或表达式）中得到类型。我说的是什么？
<code>cpp
int x = 3;
decltype(x) y = x; // 相当于 auto y = x;
</code>
可以对基本上任何类型使用decltype，包括函数的返回值。嗯，听起来像个熟悉的问题，假如我们这样写：
<code>cpp
decltype( builder.makeObject() )
</code>
我们将得到makeObject的返回值类型，这能让我们指定makeAndProcessObject的返回类型。我们可以整合进新的返回值语法：
```cpp
template <typename Builder>
auto
makeAndProcessObject (const Builder&amp; builder) &ndash;> decltype( builder.makeObject() )
{</p>

<pre><code>auto val = builder.makeObject();
// do stuff with val
return val;
</code></pre>

<p>}
```
这仅适用于新的返回值语法，因为旧的语法下，我们在声明函数返回值的时候无法引用函数参数，而新语法，所有的参数都是可访问的。</p>

<h2>auto：引用、指针和常量</h2>

<p>下面要确定的一个问题是auto如何处理引用：
```cpp
int&amp; foo();</p>

<p>auto bar = foo(); // int&amp; or int?
<code>
答案是在C++11中，auto处理引用时默认是值类型，所以下面的代码bar是int。不过你可以指定&amp;作为修饰符强制它作为引用：
</code>cpp
int&amp; foo();</p>

<p>auto bar = foo(); // int
auto&amp; baz = foo(); // int&amp;
<code>
不过，假如你有一个指针auto则自动获取指针类型：
</code>cpp
int* foo();</p>

<p>auto p_bar = foo(); // int<em>
<code>
但是你也可以显式指定表明变量是一个指针：
</code>cpp
int</em> foo();
auto <em>p_baz = foo(); // int</em>
<code>
当处理引用时，你一样可以标记const，如果需要的话：
</code>cpp
int&amp; foo();</p>

<p>const auto&amp; baz = foo(); // const int&amp;
<code>
或者指针：
</code>cpp
int<em> foo();
const int</em> const_foo();
const auto<em> p_bar = foo(); // const int</em>
auto p_bar = const_foo(); // const int*
```
所有这些都很自然，并且这遵循C++模板中类型推导的规则。</p>

<p>下一篇：<a href="/blog/2013/08/11/lambda-closures/">Lambda表达式简明教程</a></p>

<p>上一篇：<a href="/blog/2013/08/01/what-is-cpp11/">什么是C++11</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html">C++11 &ndash; Auto, Decltype and return values after functions &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-什么是C++11]]></title>
    <link href="http://towriting.com/blog/2013/08/01/what-is-cpp11/"/>
    <updated>2013-08-01T20:32:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/01/what-is-cpp11</id>
    <content type="html"><![CDATA[<h2>什么是C++0x?</h2>

<p>C++0x是C++最新标准标准化过程中的曾用名，在这一系列文章中我们将介绍最新标准添加的一系列新的语言特性。在2011年9月份，C++0x正式由官方发布并命名C++11，现在很多编译器已经支持了部分C++11特性。</p>

<p>C++11包括大量的新特性：主要特征像<a href="http://en.cppreference.com/w/cpp/language/lambda">lambda</a>表达式和移动语义，实用的类型推导关键字auto，更简单的容器遍历方法，和大量使模板更容易使用的改进。这一系列教程将包含所以以上特性。</p>

<h2>你该关注C++11吗？</h2>

<p>很明显，C++11为C++带来了大量的新特性。C++11将修复大量缺陷和降低代码拖沓，比如lambda表达式的支持将使代码更简洁。像移动语义这种特性会提高语言内核的基础效率，使你可以写出更快的代码。对模板系统的优化可以使你更容易写出泛型的代码。</p>

<p>新的标准库同时也会包含新的特性，包括对多线程的支持和优化智能指针，后者将给那些还没用类似于<a href="http://www.boost.org/doc/libs/1_46_1/libs/smart_ptr/shared_ptr.htm">boost::shared_ptr</a>的人提供更简单的内存管理方法。</p>

<p>我已经开始使用新的C++11特性，并且非常喜欢：新的auto关键字，对模板">>&ldquo;写法的支持，lambda表达式和新的函数定义语法。</p>

<h2>C++11是如何开发出来的？</h2>

<p>C++11的出现，首先要感谢C++标准委员会的辛勤工作，一群来自学术界和工业界的专家，他们的多次会晤攻克难题，终于设计出了一种跨平台，被多种编译器支持，可以生成高效易维护代码的语言。而C++11新标准，就像对灵活强大的C++的一次不可思议的扩展。</p>

<h2>C++11包括什么？</h2>

<h4>更易用的语言</h4>

<p>使用过C++11后，我发现它提供了大量的基础方法使C++变成了一种更易使用的语言。这不是说它变成了简单的语言&mdash;这里有大量的新特性&mdash;提供了大量的方法使编程更容易。让我们看一个例子，auto关键字。在C++11中，假如编译器可以从变量的初始化中得到它的类型，那么你不必要指定类型。比如，你可以这样写：
<code>cpp
int x = 3;
auto y = x;
</code>
编译器可以推导出y的类型是int。当然，这不是一个证明auto有用的一个闪亮的例子。当使用模板特别是STL时auto很好用。为什么这么说，想象使用一个迭代器(iterator):
<code>cpp
map&lt;string, string&gt; address_book;
address_book["Alex"] = "webmaster@towriting.com";
//add a bunch of people to address_book
</code>
现在你想遍历address_book中的元素，要这样做，你需要一个迭代器：
<code>cpp
map&lt;string, string&gt;::iterator iter = address_book.begin();
</code>
这是一个恐怖的长类型声明，当你已经知道这个类型的时候。这样是不是简洁多了：
<code>cpp
auto iter = address_book.begin();
</code>
代码变得更简单明了，我觉得可读性也更高了，因为模板语法使这一行其它内容变模糊了。这是我特别喜欢的一个特性，我发现它消除了许多头疼和难以追踪的编译错误，节省了时间而没有丢掉表达式的意思。</p>

<h4>区间迭代（range-based for loop)</h4>

<p>下面迭代器的例子是C++11提供的一种处理迭代的更好方法，有些人叫做区间迭代（基本上所有的现代语言都支持）。这个例子足够证明这种语法是多么优雅：
```cpp
vector<int> vec;
vec.push_back(10);
vec.push_back(20);</p>

<p>for (int &amp;i: vec)
{</p>

<pre><code>cout&lt;&lt;i;
</code></pre>

<p>}
<code>
你需要做的就是给出一个变量和要迭代的区间。但是如果你想迭代一个map怎么办？你怎么设置map中值的类型？你知道vector值的类型是int。但map的值类型是pair，通过.first和.second给你提供键和值。但是用auto，你根本无需关心确切类型，你可以简单的写成：
</code>cpp
for (auto address_entry: address_book)
{</p>

<pre><code>cout&lt;&lt;address_entry.first&lt;&lt;" "&lt;address_entry.second&lt;&lt;endl;
</code></pre>

<p>}
<code>
这将打印出：
</code>bash
Alex <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x77;&#101;&#x62;&#109;&#x61;&#x73;&#x74;&#x65;&#x72;&#64;&#x74;&#111;&#119;&#x72;&#105;&#x74;&#x69;&#110;&#103;&#46;&#99;&#111;&#x6d;">&#119;&#101;&#x62;&#x6d;&#97;&#115;&#116;&#x65;&#x72;&#64;&#116;&#x6f;&#119;&#x72;&#x69;&#x74;&#105;&#x6e;&#103;&#46;&#x63;&#111;&#x6d;</a>
```
这是一个不错的C++11新特性组合用法吧？</p>

<h4>>>(right angle brackets)</h4>

<p>我这里还有更易用的优化&mdash;在以前的C++标准中，假如你写一个含有其他模板类型的模板：
<code>cpp
vector&lt;vector&lt;int&gt; &gt; vector_of_int_vectors;
</code>
你必须在结束的两个'>&lsquo;之间添加空格。这不仅烦人，而且当你写成>>而没有空格时，你将得到困惑和误导的编译错误信息。产生这种行为的原因是C++词法分析的最大匹配原则（<a href="http://en.wikipedia.org/wiki/Maximal_munch">maximal munch rule</a>)。一个好消息是从今往后，你再也不用担心了：
<code>cpp
vector&lt;vector&lt;int&gt;&gt; vector_of_int_vectors;
</code>
对，这确实是个小东西，不过却是人工代码克服机器工具的胜利。另外，这样写就不那么丑了。</p>

<h4>多线程</h4>

<p>这是第一次，C++11将包含一种内存模型和对应的多线程库，这意味着你将可以编写符合标准的多线程代码。新标准将提供所有的通用线程方法，比如线程、线程局部存储和原子操作。它也提供了一系列有趣的特性：futures和promises。futures和promises的主要思想是，你可以编写代码表示，“这个对象，一个future代码还没计算完的结果"，它将可以在后台计算结果。当这个值需要的时候，你向future发请求，假如这个值准备好了，那就可以得到它，要不然继续等待。</p>

<p>我将在后续的文章中深入探讨多线程。</p>

<h4>还有好多其他的东西</h4>

<p>C++11特性的数量是客观的。你可以阅读维基百科里的<a href="http://en.wikipedia.org/wiki/C%2B%2B0x">C++11</a>页面，而我计划在这一系列文章中深入探索这些特性，包括：</p>

<ul>
<li><a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></li>
<li><a href="/blog/2013/08/11/lambda-closures/">Lambda表达式</a></li>
<li>区间迭代</li>
<li>静态表达式</li>
<li>右值引用和移动语义</li>
<li>nullptr和强类型的枚举</li>
</ul>


<h3>C++11的编译器支持</h3>

<p>当然，如果无法使用再好的语言特性又有什么用，好消息是大量的编译器已经开始支持C++11。Apache基金会整理了一个列表，列出了C++11的语言特性和编译器的支持情况：<a href="http://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport">支持C++11的编译器</a>。假如你对GCC感兴趣，这里有<a href="http://gcc.gnu.org/gcc-4.7/cxx0x_status.html">GCC4.7支持C++11</a>。</p>

<p>有些编译器，比如GCC，不会默认支持这些新特性&mdash;例如，为了支持C++11特性，编译时必须指定 -std=c++0x。当然这也是很有用的，你可以在你的项目中选择编译器和语言集。</p>

<p>下一篇：<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/what-is-c++0x.html">What is C++0x? &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降权启动进程]]></title>
    <link href="http://towriting.com/blog/2013/07/31/de-elevate-start-process/"/>
    <updated>2013-07-31T22:01:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/31/de-elevate-start-process</id>
    <content type="html"><![CDATA[<p>Win7下有些进程需要以管理员权限启动，比如安装程序。但又需要这个具有管理员权限的进程启动一个非管理员权限的进程。要实现这一点，方法很简单，首先得到受限的Token，然后由这个Token调用<a href="http://msdn.microsoft.com/en-us/library/ms682429.aspx">CreateProcessAsUser</a>。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>代码：WIN7/VS2010 (de_elevate_start_process.cpp)</span> <a href='/downloads/code/cpp/de_elevate_start_process.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &quot;stdafx.h&quot;</span>
</span><span class='line'><span class="cp">#include &lt;Windows.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;UserEnv.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;WinBase.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;WinSafer.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma comment(lib, &quot;Userenv.lib&quot;)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取不含管理员权限的Token</span>
</span><span class='line'><span class="n">HANDLE</span> <span class="n">CreateNormalUserToken</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="n">SAFER_LEVEL_HANDLE</span> <span class="n">hLevel</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SaferCreateLevel</span><span class="p">(</span><span class="n">SAFER_SCOPEID_USER</span><span class="p">,</span> <span class="n">SAFER_LEVELID_NORMALUSER</span><span class="p">,</span> <span class="n">SAFER_LEVEL_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hLevel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="n">HANDLE</span> <span class="n">hRestrictedToken</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SaferComputeTokenFromLevel</span><span class="p">(</span><span class="n">hLevel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hRestrictedToken</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="n">hRestrictedToken</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>	<span class="n">SaferCloseLevel</span><span class="p">(</span><span class="n">hLevel</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="n">hRestrictedToken</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 从管理员进程，创建非管理员进程</span>
</span><span class='line'><span class="n">BOOL</span> <span class="n">DeElevateStartProcess</span><span class="p">(</span><span class="n">TCHAR</span><span class="o">*</span> <span class="n">cmd</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="k">const</span> <span class="n">HANDLE</span> <span class="n">hRestToken</span> <span class="o">=</span> <span class="n">CreateNormalUserToken</span><span class="p">();</span>
</span><span class='line'>	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">hRestToken</span><span class="p">)</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="n">DWORD</span> <span class="n">dwCreationFlags</span> <span class="o">=</span> <span class="n">NORMAL_PRIORITY_CLASS</span> <span class="o">|</span> <span class="n">CREATE_NEW_CONSOLE</span><span class="p">;</span>
</span><span class='line'>	<span class="n">LPVOID</span> <span class="n">pEnv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>	<span class="k">if</span><span class="p">(</span><span class="n">CreateEnvironmentBlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pEnv</span><span class="p">,</span> <span class="n">hRestToken</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">))</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="n">dwCreationFlags</span> <span class="o">|=</span> <span class="n">CREATE_UNICODE_ENVIRONMENT</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>	<span class="k">else</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="n">pEnv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">;</span>
</span><span class='line'>	<span class="n">STARTUPINFO</span> <span class="n">si</span><span class="p">;</span>	
</span><span class='line'>	<span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFO</span><span class="p">));</span>
</span><span class='line'>	<span class="n">si</span><span class="p">.</span><span class="n">cb</span><span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFO</span><span class="p">);</span>
</span><span class='line'>	<span class="n">si</span><span class="p">.</span><span class="n">lpDesktop</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;winsta0</span><span class="se">\\</span><span class="s">default&quot;</span><span class="p">);</span> <span class="c1">//default input desktop for the interactive window station</span>
</span><span class='line'>	<span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pi</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>	<span class="k">const</span> <span class="n">BOOL</span> <span class="n">bResult</span> <span class="o">=</span> <span class="n">CreateProcessAsUser</span><span class="p">(</span><span class="n">hRestToken</span><span class="p">,</span>    <span class="c1">// client&#39;s access token</span>
</span><span class='line'>						<span class="nb">NULL</span><span class="p">,</span>                   <span class="c1">// file to execute</span>
</span><span class='line'>						<span class="n">cmd</span><span class="p">,</span>      <span class="c1">// command line</span>
</span><span class='line'>						<span class="nb">NULL</span><span class="p">,</span>                   <span class="c1">// pointer to process SECURITY_ATTRIBUTES</span>
</span><span class='line'>						<span class="nb">NULL</span><span class="p">,</span>                   <span class="c1">// pointer to thread SECURITY_ATTRIBUTES</span>
</span><span class='line'>						<span class="n">FALSE</span><span class="p">,</span>                  <span class="c1">// handles are not inheritable</span>
</span><span class='line'>						<span class="n">dwCreationFlags</span><span class="p">,</span>        <span class="c1">// creation flags</span>
</span><span class='line'>						<span class="n">pEnv</span><span class="p">,</span>                   <span class="c1">// pointer to new environment block</span>
</span><span class='line'>						<span class="nb">NULL</span><span class="p">,</span>                   <span class="c1">// name of current directory</span>
</span><span class='line'>						<span class="o">&amp;</span><span class="n">si</span><span class="p">,</span>                    <span class="c1">// pointer to STARTUPINFO structure</span>
</span><span class='line'>						<span class="o">&amp;</span><span class="n">pi</span>                     <span class="c1">// receives information about new process</span>
</span><span class='line'>						<span class="p">);</span>
</span><span class='line'>	<span class="k">if</span> <span class="p">(</span><span class="n">bResult</span><span class="p">)</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="n">CloseHandle</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">);</span>
</span><span class='line'>		<span class="n">CloseHandle</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hThread</span><span class="p">);</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>	<span class="k">if</span> <span class="p">(</span><span class="n">pEnv</span><span class="p">)</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="n">DestroyEnvironmentBlock</span><span class="p">(</span><span class="n">pEnv</span><span class="p">);</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>	<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hRestToken</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="n">bResult</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="n">TCHAR</span> <span class="n">cmd</span><span class="p">[]</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;notepad.exe&quot;</span><span class="p">);</span>
</span><span class='line'>	<span class="n">DeElevateStartProcess</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>需要创建出的进程支持拖拽的看这里：<a href="/blog/2013/08/06/process-can-drag-drop/">创建支持拖拽的进程</a></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[获取进程打开的互斥量]]></title>
    <link href="http://towriting.com/blog/2013/07/25/mutexs-owned-by-process/"/>
    <updated>2013-07-25T21:36:00+08:00</updated>
    <id>http://towriting.com/blog/2013/07/25/mutexs-owned-by-process</id>
    <content type="html"><![CDATA[<p>最近有个任务涉及到区分【同进程名进程】，所以想到了用进程"拥有"的互斥量来区分这些进程。所以下面实现了获取指定进程"拥有"哪些互斥量的方法，当然这种方法也适合各种内核对象（FILE、REG&hellip;)。</p>

<pre><code>1. 使用NtQuerySystemInformation检索SystemHandleInformation(16)即可获得系统中所有的句柄信息：
</code></pre>

<p>通过SystemHandleInformation检索到的系统中所有句柄的数据结构是这样定义的：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SYSTEM_HANDLE_INFORMATION</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ULONG</span> <span class="n">HandleCount</span><span class="p">;</span>
</span><span class='line'><span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span> <span class="n">Handles</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">SYSTEM_HANDLE_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">PSYSTEM_HANDLE_INFORMATION</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中SYSTEM_HANDLE_TABLE_ENTRY_INFO是一个句柄信息的数据结构
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SYSTEM_HANDLE_TABLE_ENTRY_INFO</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ULONG</span> <span class="n">ProcessId</span><span class="p">;</span>
</span><span class='line'><span class="n">BYTE</span> <span class="n">ObjectTypeNumber</span><span class="p">;</span>
</span><span class='line'><span class="n">BYTE</span> <span class="n">Flags</span><span class="p">;</span>
</span><span class='line'><span class="n">USHORT</span> <span class="n">Handle</span><span class="p">;</span>
</span><span class='line'><span class="n">PVOID</span> <span class="n">Object</span><span class="p">;</span>
</span><span class='line'><span class="n">ACCESS_MASK</span> <span class="n">GrantedAccess</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="p">,</span> <span class="o">*</span><span class="n">PSYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<pre><code>2. 将句柄复制到当前进程
</code></pre>

<p>想要获取一个句柄的详细信息，必须将其拷贝到当前进程，对于一个句柄数据类型：SYSTEM_HANDLE_TABLE_ENTRY_INFO，我们可以使用其第四个成员Handle，然后使用DuplicateHandle将这个句柄复制到当前进程。</p>

<pre><code>3. 获取句柄的类型信息
</code></pre>

<p>由2中获取的复制到当前进程的句柄，调用函数NtQueryObject，指定获取ObjectNameInformation(1)即可获取句柄的类型信息，获取到的句柄的类型信息结构是这样的：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_OBJECT_TYPE_INFORMATION</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">UNICODE_STRING</span> <span class="n">TypeName</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">TotalNumberOfObjects</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">TotalNumberOfHandles</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">TotalPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">TotalNonPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">TotalNamePoolUsage</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">TotalHandleTableUsage</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">HighWaterNumberOfObjects</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">HighWaterNumberOfHandles</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">HighWaterPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">HighWaterNonPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">HighWaterNamePoolUsage</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">HighWaterHandleTableUsage</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">InvalidAttributes</span><span class="p">;</span>
</span><span class='line'><span class="n">GENERIC_MAPPING</span> <span class="n">GenericMapping</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">ValidAccessMask</span><span class="p">;</span>
</span><span class='line'><span class="n">BOOLEAN</span> <span class="n">SecurityRequired</span><span class="p">;</span>
</span><span class='line'><span class="n">BOOLEAN</span> <span class="n">MaintainHandleCount</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">PoolType</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">DefaultPagedPoolCharge</span><span class="p">;</span>
</span><span class='line'><span class="n">ULONG</span> <span class="n">DefaultNonPagedPoolCharge</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">OBJECT_TYPE_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">POBJECT_TYPE_INFORMATION</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
其中第一个成员TypeName即是句柄类型的类型名</p>

<!--more-->


<pre><code>4. 获取句柄的名字
</code></pre>

<p>调用函数NtQueryObject，指定获取ObjectNameInformation即可获取句柄的类型信息，获取到的句柄的名字数据结构是UNICODE_STRING类型。</p>

<pre><code>5. 找到当前进程占有的互斥量
</code></pre>

<p>由获取的句柄的类型信息和句柄所在的进程ID，即可找到当前进程拥有的互斥量，同时我们也得到了互斥量的名字。</p>

<h3>完整代码如下：</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>代码：WIN7/VS2010 (get_process_mutex.cpp)</span> <a href='/downloads/code/cpp/get_process_mutex.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &quot;stdafx.h&quot;</span>
</span><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'><span class="cp">#include &lt;Windows.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;winternl.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;ntstatus.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// NtQueryObject枚举出的内核对象的类型信息的结构</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_OBJECT_TYPE_INFORMATION</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="n">UNICODE_STRING</span> <span class="n">TypeName</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">TotalNumberOfObjects</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">TotalNumberOfHandles</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">TotalPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">TotalNonPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">TotalNamePoolUsage</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">TotalHandleTableUsage</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">HighWaterNumberOfObjects</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">HighWaterNumberOfHandles</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">HighWaterPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">HighWaterNonPagedPoolUsage</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">HighWaterNamePoolUsage</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">HighWaterHandleTableUsage</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">InvalidAttributes</span><span class="p">;</span>
</span><span class='line'>	<span class="n">GENERIC_MAPPING</span> <span class="n">GenericMapping</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">ValidAccessMask</span><span class="p">;</span>
</span><span class='line'>	<span class="n">BOOLEAN</span> <span class="n">SecurityRequired</span><span class="p">;</span>
</span><span class='line'>	<span class="n">BOOLEAN</span> <span class="n">MaintainHandleCount</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">PoolType</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">DefaultPagedPoolCharge</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">DefaultNonPagedPoolCharge</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">OBJECT_TYPE_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">POBJECT_TYPE_INFORMATION</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 一个句柄信息的数据结构</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SYSTEM_HANDLE_TABLE_ENTRY_INFO</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="n">ULONG</span> <span class="n">ProcessId</span><span class="p">;</span>
</span><span class='line'>	<span class="n">BYTE</span> <span class="n">ObjectTypeNumber</span><span class="p">;</span>
</span><span class='line'>	<span class="n">BYTE</span> <span class="n">Flags</span><span class="p">;</span>
</span><span class='line'>	<span class="n">USHORT</span> <span class="n">Handle</span><span class="p">;</span>
</span><span class='line'>	<span class="n">PVOID</span> <span class="n">Object</span><span class="p">;</span>
</span><span class='line'>	<span class="n">ACCESS_MASK</span> <span class="n">GrantedAccess</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="p">,</span> <span class="o">*</span><span class="n">PSYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取一个句柄的详细信息</span>
</span><span class='line'><span class="c1">// 可以获取类型名和内核对象的名字</span>
</span><span class='line'><span class="c1">// bType - 获取句柄的类型名</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">QueryHandleNameInfo</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">handle</span><span class="p">,</span> <span class="n">BOOL</span> <span class="n">bType</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strName</span><span class="p">;</span>
</span><span class='line'>	<span class="k">const</span> <span class="n">HMODULE</span> <span class="n">hDll</span> <span class="o">=</span> <span class="n">LoadLibrary</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;ntdll.dll&quot;</span><span class="p">));</span>
</span><span class='line'>	<span class="k">if</span> <span class="p">(</span><span class="n">hDll</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="k">return</span> <span class="n">strName</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>	<span class="k">typedef</span> <span class="n">NTSTATUS</span> <span class="p">(</span><span class="n">NTAPI</span> <span class="o">*</span><span class="n">NtQueryObjectFunc</span><span class="p">)(</span><span class="n">HANDLE</span><span class="p">,</span> <span class="n">OBJECT_INFORMATION_CLASS</span><span class="p">,</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">ULONG</span><span class="p">,</span> <span class="n">PULONG</span><span class="p">);</span>
</span><span class='line'>	<span class="n">NtQueryObjectFunc</span> <span class="n">NtQueryObject_</span> <span class="o">=</span> <span class="p">(</span><span class="n">NtQueryObjectFunc</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hDll</span><span class="p">,</span> <span class="s">&quot;NtQueryObject&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>	<span class="k">do</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="k">if</span> <span class="p">(</span><span class="n">NtQueryObject_</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
</span><span class='line'>		<span class="p">{</span>
</span><span class='line'>			<span class="k">break</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="c1">// 获取信息</span>
</span><span class='line'>		<span class="k">const</span> <span class="n">DWORD</span> <span class="n">ObjectNameInformation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>		<span class="n">OBJECT_INFORMATION_CLASS</span> <span class="n">infoType</span> <span class="o">=</span> <span class="n">bType</span> <span class="o">?</span> <span class="n">ObjectTypeInformation</span> <span class="o">:</span> <span class="n">OBJECT_INFORMATION_CLASS</span><span class="p">(</span><span class="n">ObjectNameInformation</span><span class="p">);</span>
</span><span class='line'>		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BYTE</span><span class="o">&gt;</span> <span class="n">objVec</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
</span><span class='line'>		<span class="n">ULONG</span> <span class="n">bytesOfRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	
</span><span class='line'>		<span class="n">NTSTATUS</span> <span class="n">status</span> <span class="o">=</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span>
</span><span class='line'>		<span class="k">do</span>
</span><span class='line'>		<span class="p">{</span>
</span><span class='line'>			<span class="n">status</span> <span class="o">=</span> <span class="n">NtQueryObject_</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">infoType</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">objVec</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">objVec</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">bytesOfRead</span><span class="p">);</span>
</span><span class='line'>			<span class="k">if</span> <span class="p">(</span><span class="n">STATUS_INFO_LENGTH_MISMATCH</span> <span class="o">==</span> <span class="n">status</span><span class="p">)</span>
</span><span class='line'>			<span class="p">{</span>
</span><span class='line'>				<span class="n">objVec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">objVec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>				<span class="k">continue</span><span class="p">;</span>
</span><span class='line'>			<span class="p">}</span>
</span><span class='line'>			<span class="k">break</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
</span><span class='line'>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
</span><span class='line'>		<span class="p">{</span>
</span><span class='line'>			<span class="k">break</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="n">objVec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">bytesOfRead</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>		<span class="k">if</span> <span class="p">(</span><span class="n">bType</span><span class="p">)</span>
</span><span class='line'>		<span class="p">{</span>
</span><span class='line'>			<span class="k">const</span> <span class="n">OBJECT_TYPE_INFORMATION</span> <span class="o">*</span><span class="n">pObjType</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">OBJECT_TYPE_INFORMATION</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">objVec</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span><span class='line'>			<span class="n">strName</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="p">(</span><span class="n">pObjType</span><span class="o">-&gt;</span><span class="n">TypeName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">pObjType</span><span class="o">-&gt;</span><span class="n">TypeName</span><span class="p">.</span><span class="n">Length</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">));</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="k">else</span>
</span><span class='line'>		<span class="p">{</span>
</span><span class='line'>			<span class="k">const</span> <span class="n">UNICODE_STRING</span> <span class="o">*</span><span class="n">pObjName</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">UNICODE_STRING</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">objVec</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span><span class='line'>			<span class="n">strName</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="p">(</span><span class="n">pObjName</span><span class="o">-&gt;</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">pObjName</span><span class="o">-&gt;</span><span class="n">Length</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">));</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>	<span class="n">FreeLibrary</span><span class="p">(</span><span class="n">hDll</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="n">strName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 遍历句柄辅助类</span>
</span><span class='line'><span class="k">class</span> <span class="nc">WalkHandleHelper</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>	<span class="n">WalkHandleHelper</span><span class="p">(</span><span class="k">const</span> <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="o">&amp;</span> <span class="n">handleInfo</span><span class="p">,</span> <span class="k">const</span> <span class="n">HANDLE</span><span class="o">&amp;</span> <span class="n">handle</span><span class="p">)</span><span class="o">:</span><span class="n">m_HandleInfo</span><span class="p">(</span><span class="n">handleInfo</span><span class="p">),</span> <span class="n">m_Handle</span><span class="p">(</span><span class="n">handle</span><span class="p">){}</span>
</span><span class='line'>	<span class="n">DWORD</span> <span class="n">GetProcessID</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">m_HandleInfo</span><span class="p">.</span><span class="n">ProcessId</span><span class="p">;}</span>
</span><span class='line'>	<span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">GetTypeName</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="k">return</span> <span class="n">QueryHandleNameInfo</span><span class="p">(</span><span class="n">m_Handle</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>	<span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">GetObjectName</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="k">return</span> <span class="n">QueryHandleNameInfo</span><span class="p">(</span><span class="n">m_Handle</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>	<span class="k">const</span> <span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span><span class="o">&amp;</span> <span class="n">m_HandleInfo</span><span class="p">;</span>
</span><span class='line'>	<span class="k">const</span> <span class="n">HANDLE</span><span class="o">&amp;</span> <span class="n">m_Handle</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 枚举系统的句柄</span>
</span><span class='line'><span class="kt">void</span> <span class="n">WalkHandle</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">WalkHandleHelper</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">functor</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="k">const</span> <span class="n">HMODULE</span> <span class="n">hDll</span> <span class="o">=</span> <span class="n">LoadLibrary</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;ntdll.dll&quot;</span><span class="p">));</span>
</span><span class='line'>	<span class="k">if</span> <span class="p">(</span><span class="n">hDll</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="k">return</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="c1">// 使用NtQuerySystemInformation检索SystemHandleInformation(16)即可获得系统中所有的句柄信息</span>
</span><span class='line'>	<span class="k">const</span> <span class="n">DWORD</span> <span class="n">SystemHandleInformation</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>		
</span><span class='line'>
</span><span class='line'>	<span class="c1">// 通过SystemHandleInformation检索到的系统中所有句柄的数据结构</span>
</span><span class='line'>	<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SYSTEM_HANDLE_INFORMATION</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="n">ULONG</span> <span class="n">HandleCount</span><span class="p">;</span>
</span><span class='line'>		<span class="n">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span> <span class="n">Handles</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>	<span class="p">}</span> <span class="n">SYSTEM_HANDLE_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">PSYSTEM_HANDLE_INFORMATION</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>	<span class="k">typedef</span> <span class="n">NTSTATUS</span> <span class="p">(</span><span class="n">NTAPI</span> <span class="o">*</span><span class="n">NtQuerySystemInformationFunc</span><span class="p">)(</span><span class="n">ULONG</span><span class="p">,</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">ULONG</span><span class="p">,</span> <span class="n">PULONG</span><span class="p">);</span>
</span><span class='line'>	<span class="n">NtQuerySystemInformationFunc</span> <span class="n">NtQuerySystemInformation_</span> <span class="o">=</span> <span class="p">(</span><span class="n">NtQuerySystemInformationFunc</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hDll</span><span class="p">,</span> <span class="s">&quot;NtQuerySystemInformation&quot;</span><span class="p">);</span>
</span><span class='line'>	<span class="k">const</span> <span class="n">HANDLE</span> <span class="n">hCurProcess</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
</span><span class='line'>	<span class="k">do</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">NtQuerySystemInformation_</span><span class="p">)</span>
</span><span class='line'>		<span class="p">{</span>
</span><span class='line'>			<span class="k">break</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="c1">// 获取系统句柄表</span>
</span><span class='line'>		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BYTE</span><span class="o">&gt;</span> <span class="n">vecData</span><span class="p">(</span><span class="mi">512</span><span class="p">);</span>
</span><span class='line'>		<span class="n">ULONG</span> <span class="n">bytesOfRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>		<span class="n">NTSTATUS</span> <span class="n">status</span><span class="p">;</span>
</span><span class='line'>		<span class="k">do</span>
</span><span class='line'>		<span class="p">{</span>
</span><span class='line'>			<span class="n">status</span> <span class="o">=</span> <span class="n">NtQuerySystemInformation_</span><span class="p">(</span><span class="n">SystemHandleInformation</span><span class="p">,</span> <span class="n">vecData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">vecData</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">bytesOfRead</span><span class="p">);</span>
</span><span class='line'>			<span class="k">if</span> <span class="p">(</span><span class="n">STATUS_INFO_LENGTH_MISMATCH</span> <span class="o">==</span> <span class="n">status</span><span class="p">)</span>
</span><span class='line'>			<span class="p">{</span>
</span><span class='line'>				<span class="n">vecData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">vecData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>				<span class="k">continue</span><span class="p">;</span>
</span><span class='line'>			<span class="p">}</span>
</span><span class='line'>			<span class="k">break</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
</span><span class='line'>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
</span><span class='line'>		<span class="p">{</span>
</span><span class='line'>			<span class="k">break</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="n">vecData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">bytesOfRead</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>		<span class="n">PSYSTEM_HANDLE_INFORMATION</span> <span class="n">pSysHandleInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSYSTEM_HANDLE_INFORMATION</span><span class="p">)</span><span class="n">vecData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span><span class='line'>		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">pSysHandleInfo</span><span class="o">-&gt;</span><span class="n">HandleCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>		<span class="p">{</span>
</span><span class='line'>			<span class="k">const</span> <span class="n">HANDLE</span> <span class="n">hOwnProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_DUP_HANDLE</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">pSysHandleInfo</span><span class="o">-&gt;</span><span class="n">Handles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ProcessId</span><span class="p">);</span>
</span><span class='line'>			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">hOwnProcess</span><span class="p">)</span>
</span><span class='line'>			<span class="p">{</span>
</span><span class='line'>				<span class="k">continue</span><span class="p">;</span>
</span><span class='line'>			<span class="p">}</span>
</span><span class='line'>			<span class="n">HANDLE</span> <span class="n">hDuplicate</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>			<span class="c1">// 必须把Handle放入自己的进程中，否则无法获取其他进程拥有Handle的信息</span>
</span><span class='line'>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DuplicateHandle</span><span class="p">(</span><span class="n">hOwnProcess</span><span class="p">,</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">pSysHandleInfo</span><span class="o">-&gt;</span><span class="n">Handles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Handle</span><span class="p">,</span> <span class="n">hCurProcess</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hDuplicate</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">DUPLICATE_SAME_ACCESS</span><span class="p">))</span>
</span><span class='line'>			<span class="p">{</span>
</span><span class='line'>				<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hOwnProcess</span><span class="p">);</span>
</span><span class='line'>				<span class="k">continue</span><span class="p">;</span>
</span><span class='line'>			<span class="p">}</span>
</span><span class='line'>			<span class="n">WalkHandleHelper</span> <span class="n">helper</span><span class="p">(</span><span class="n">pSysHandleInfo</span><span class="o">-&gt;</span><span class="n">Handles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hDuplicate</span><span class="p">);</span>
</span><span class='line'>			<span class="n">functor</span><span class="p">(</span><span class="n">helper</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>			<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDuplicate</span><span class="p">);</span>
</span><span class='line'>			<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hOwnProcess</span><span class="p">);</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>	<span class="n">FreeLibrary</span><span class="p">(</span><span class="n">hDll</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 枚举当前进程的互斥量</span>
</span><span class='line'><span class="kt">void</span> <span class="n">EnumCurProcessMutex</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="n">std</span><span class="o">::</span><span class="n">wcout</span><span class="o">&lt;&lt;</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;Find The Mutex Opened By Current Process:&quot;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>	<span class="k">const</span> <span class="n">DWORD</span> <span class="n">dwCurProcess</span> <span class="o">=</span> <span class="n">GetCurrentProcessId</span><span class="p">();</span>
</span><span class='line'>	<span class="n">WalkHandle</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">WalkHandleHelper</span><span class="o">&amp;</span> <span class="n">helper</span><span class="p">)</span>
</span><span class='line'>	<span class="p">{</span>
</span><span class='line'>		<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">strMutant</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;Mutant&quot;</span><span class="p">));</span>
</span><span class='line'>		<span class="k">if</span> <span class="p">(</span><span class="n">helper</span><span class="p">.</span><span class="n">GetProcessID</span><span class="p">()</span> <span class="o">==</span> <span class="n">dwCurProcess</span> <span class="o">&amp;&amp;</span> <span class="n">helper</span><span class="p">.</span><span class="n">GetTypeName</span><span class="p">().</span><span class="n">compare</span><span class="p">(</span><span class="n">strMutant</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>		<span class="p">{</span>			
</span><span class='line'>			<span class="n">std</span><span class="o">::</span><span class="n">wcout</span><span class="o">&lt;&lt;</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;ObjectName: &quot;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">helper</span><span class="p">.</span><span class="n">GetObjectName</span><span class="p">().</span><span class="n">c_str</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="n">CreateMutex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>	<span class="n">CreateMutex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;TestMutex&quot;</span><span class="p">));</span>
</span><span class='line'>	<span class="n">CreateMutex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">&quot;Global</span><span class="se">\\</span><span class="s">TestGlobalMutex&quot;</span><span class="p">));</span>
</span><span class='line'>	<span class="n">EnumCurProcessMutex</span><span class="p">();</span>
</span><span class='line'>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
</feed>
