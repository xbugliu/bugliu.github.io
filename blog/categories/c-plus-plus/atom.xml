<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2013-12-15T03:00:23+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Boost.Lambda与C++11.Lambda的用法对比]]></title>
    <link href="http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda/"/>
    <updated>2013-12-13T22:38:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda</id>
    <content type="html"><![CDATA[<p>我们知道C++11已经支持了Lambda表达式，大部分新的编译器都已支持Lambda。但boost里面的Lambda还是有存在的必要，因为并不是每个人都有选择自己编译环境的权利。</p>

<p>让我们通过几个例子对比C++11.Lambda来学习一下boost.Lambda的用法，详细的C++11.Lambda用法可以看这里：<a href="/blog/2013/08/11/lambda-closures/">C++11系列-Lambda表达式</a></p>

<h3>1.a boost.Lambda：构造一个functor</h3>

<p>boost.Lambda的使用是基于placeholder: <code>boost::Lambda::_1</code>,<code>boost::Lambda::_2</code>,<code>boost::Lambda::_3</code>可以理解为Lambda表达式的第一、第二、第三个参数。Lambda的出现利索地解决了STL算法库函数的使用不便。让我们首先看一个最简单的boost.Lambda与std::for_each结合的例子:</p>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin values in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;&ldquo;,&rdquo;);
std::cout&lt;&lt;std::endl;
```</p>

<p>上面的例子，使用std::for_each遍历vector中的元素并打印内容。boost::Lambda::_1这个占位符表示for_each遍历时传进来的第一个参数，<code>std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;","</code>可以理解为临时创建出来的匿名函数，函数的定义是<code>void(int)</code>。</p>

<p>让我们对比一下C++11标准的写法:</p>

<h3>1.b C++11.Lambda：构造一个functor</h3>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin value in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), <a href="const%20int%20&amp;%20val"></a>
{
std::cout&lt;&lt;val&lt;&lt;&ldquo;,&rdquo;;
});
std::cout&lt;&lt;std::endl;
```
一眼望去竟是boost的Lambda用法简洁。</p>

<h3>2.a boost.Lambda：修改参数的内容</h3>

<p>上面的例子，我们使用Lambda表达式，借助于for_each，对vector中的元素进行了访问，那我们可以修改vector的内容吗？</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), boost::Lambda::_1 *= boost::Lambda::_1);
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;",");//打印
std::cout&lt;&lt;std::endl;
</code>
上面的例子，功能是对vecIn中的值求平方。占位符boost::Lambda::_1直接用引用的方式得到了传入的参数（vecIn的元素），结果直接改写进了vecIn。</p>

<h3>2.b C++11.Lambda：修改参数的内容</h3>

<p>修改1.b函数定义为引用即可</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [](int &amp; val)
{
val *= val;
});
//打印：
std::for_each(vecIn.begin(), vecIn.end(), [](const int &amp; val)
{
std::cout&lt;&lt;val&lt;&lt;",";
});
std::cout&lt;&lt;std::endl;
</code></p>

<h3>3.a boost.Lambda：变量捕获</h3>

<p>boost.Lambda可以很方便的以引用的方式捕获local变量，看例子：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), sum += boost::Lambda::_1);
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>3.b C++11.Lambda：变量捕获</h3>

<p>C++11捕获变量，可控性更强，我们可以指定捕获方式：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [&amp;sum](int &amp; val)
{
sum += val;
});
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>4.a boost.Lambda：返回值</h3>

<p>有时需要匿名函数返回结果，比如作为std::find_if类似函数的Predicate函数时，这种能力boost.Lambda当然也是胜任的，整个Lambda表达式的结果，即是函数的返回值。</p>

<p>```cpp
boost::function&lt;bool(int)> IsOdd = boost::Lambda::_1 % 2 != 0;</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```
上面的例子创建了一个检测参数是否是奇数的匿名函数，并保存到IsOdd对象中，然后对其进行了调用。例子同样演示了如何将一个boost.Lambda表达式存储起来，后续使用的方法。</p>

<h3>4.b C++11.Lambda：返回值</h3>

<p>C++11的返回值，必须使用return语句，返回值的类型有些时候也需要显示指定。
```cpp
std::function&lt;bool(int)> IsOdd = (std::function&lt;bool(int)>)<a href="int%20val"></a>{return val % 2 != 0;};</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```</p>

<h3>5. 上面四个例子的运行结果</h3>

<pre><code>the orgin values in vecIn：
1,2,3,
the values in vecIn after Square：
1,4,9,
the sum of values in vecIn：
14
100 is Odd？ false
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[那些C++牛人的博客]]></title>
    <link href="http://towriting.com/blog/2013/12/12/cpp-blogs/"/>
    <updated>2013-12-12T20:57:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/12/cpp-blogs</id>
    <content type="html"><![CDATA[<p>现整理收集C++世界里那些“牛人”的个人博客。凡三类：一是令人高山仰止的大牛，对C++语言本身产生过深远的影响的人；二是C++运用炉火纯青的高手，有原创性的技术干货；三是中文世界里的C++牛人。</p>

<h2>C++大牛的博客</h2>

<p><img class="pull-right" src="/images/posts/cpp-blogs/BjarneStroustrup.jpg" width="120" height="150"></p>

<ul>
<li><strong>Bjarne Stroustrup的博客</strong>: <a href="http://www.stroustrup.com/">Bjarne Stroustrup&rsquo;s Homepage</a></li>
</ul>


<p>Bjarne Stroustrup，不认识的可以去面壁了，没有他，就没有我们现在的饭碗。Bjarne Stroustrup是丹麦人，目前任教于TAMU。他的Homepage和他的书籍<a href='http://www.amazon.cn/gp/product/B003EIKI0C/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B003EIKI0C&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>The C++ Programming Language</a>一样，都是百科全书级的，如果你认真研究，你也会成为你同事或周围人的C++之父。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/ScottMeyers.jpg" width="120" height="150"></p>

<ul>
<li><strong>Scott Meyers的博客</strong>: <a href="http://scottmeyers.blogspot.com/">The View from Aristeia</a></li>
</ul>


<p>Scott Meyers，不多介绍，世界上几乎每个C++程序员都应该知道的名字，畅销书：<a href='http://www.amazon.cn/gp/product/B004G72P24<em>Effective C++</em>B004IP8BD6/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004G72P24<em>Effective C++</em>B004IP8BD6&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>More Effective C++</a>的作者。博客长期更新，就凭Scott Meyers这个名字，就值得一读。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/stan_lippman.jpg" width="120" height="150"></p>

<ul>
<li><strong>Stanley B.Lippman的博客</strong>: <a href="http://blogs.msdn.com/b/slippman/">Stan Lippman&rsquo;s BLog</a></li>
</ul>


<p>Lippman，C++第一个编译器Cfront的实现者，最大的贡献是凭借其著作<a href='http://www.amazon.cn/gp/product/B00ESUIL0O<em>C++ Primer/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ESUIL0O<em>C++ Primer&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'></a>, 在世界范围内普及了C++。Lippman本人算是个励志故事，父母是蓝领移民，他为了融入美国主流社会而努力工作，终于取得了今日的成就，他的另一本书<a href='http://www.amazon.cn/gp/product/B006QXQXTM</em>Inside The C++ Object Model/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B006QXQXTM</em>Inside The C++ Object Model&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'></a>, 让我知道了C++代码编译后的样子，不过我不知他写该书时发生了什么事情，因为书中有大量的低级错误，与前一本书的严谨截然相反。列出他的博客，更多的是因为他是C++牛人中无法绕过的一个，而其博客久不更新，早已荒芜，而且是MSDN上的专栏，可能不太能提起人多大兴趣去读。</p>

<p><img class="pull-right" src="/images/posts/cpp-blogs/HerbSutter.jpg" width="120" height="150"></p>

<ul>
<li><strong>Herb Sutter的博客</strong>: <a href="http://herbsutter.com/">Sutter’s Mill: Herb Sutter on software, hardware, and concurrency</a></li>
</ul>


<p>Herb Sutter, C++标准委员会主席，目前就职于微软。代表作为C++ Exceptional系列：<a href='http://www.amazon.cn/gp/product/B008CGKUBS<em>Exceptional C++</em>B004IUISIO<em>More Exceptional C++</em>B00114BFTO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008CGKUBS<em>Exceptional C++</em>B004IUISIO<em>More Exceptional C++</em>B00114BFTO&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Exceptional C++ Style</a>, 因封面头像蓄须，被国人称“小胡子”，不过貌似现在刮干净了。博客更新很快，内容杂乱，有技术亦有资讯，gotw系列个人感觉不错。</p>

<p><img class="pull-right" src="/images/posts/cpp-blogs/AndreiAlexandrescu.jpg" width="120" height="150"></p>

<ul>
<li><strong>Andrei Alexandrescu的博客</strong>: <a href="http://erdani.com/index.php/articles/">Official website of Andrei Alexandrescu</a></li>
</ul>


<p>Andrei Alexandrescu，罗马尼亚人，目前任职于FaceBook, C++天书<a href='http://www.amazon.cn/gp/product/0201704315/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=0201704315&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Modern C++ Design: Generic Programming and Design Patterns Applied</a>的作者，凭借此书第一次人C++社区认识到模板编程鬼斧神工之力。后来不满C++而转投D语言，是D语言的主要开发者。不过他的博客貌似好久不更新了，内容也大多学术气息浓厚。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/dave_abrahams.jpg" width="120" height="150"></p>

<ul>
<li><strong>David Abrahams的博客</strong>: <a href="http://daveabrahams.com/">Dave Abrahams: Home Page | Stuff I wrote, things I did, etc</a></li>
</ul>


<p>David Abrahams，美国人，C++标准委员会成员，将exception-safety加入标准，Boost.org的联合创始人，<a href='http://www.amazon.cn/gp/product/B002WB1J0U/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B002WB1J0U&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>C++ Template Metaprogramming</a>的作者。但博客内容一般，最后一篇内容更新时间是12年的，内容不多，也没有太多亮点，不过笑容却是感染了我。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/BartoszMilewski.jpg" width="120" height="150"></p>

<ul>
<li><strong>Bartosz Milewski的博客</strong>：<a href="http://bartoszmilewski.com/">Bartosz Milewski&rsquo;s Programming Cafe：Concurrency, Multicore, C++, Haskell</a></li>
</ul>


<p>Bartosz Milewski，波兰人，物理系毕业的计算机大牛，曾就职于微软。<a href='http://www.amazon.cn/gp/product/B009TB3ZBW/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009TB3ZBW&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>c++ in action</a>的作者。博客更新频繁，内容密实，观点前卫，对C++的不满流露于字里行间，多以Haskell对比C++的不足，然后实现一些函数式编程风格的C++代码。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/anthony_williams.jpg" width="120" height="150"></p>

<ul>
<li><strong>Anthony Williams的博客</strong>：<a href="http://www.justsoftwaresolutions.co.uk/blog/">Just Software Solutions</a></li>
</ul>


<p>Anthony Williams，英国人，一个记事起就开始写程序的人。Boost.Thread的作者，参与了C++11 Thread的标准化工作。博客有一部分技术文章，也有一些标准化和他自己维护的一些库的记录，对C++多线程感兴趣的可以读一下他的书：<a href='http://www.amazon.cn/gp/product/1933988770/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1933988770&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>C++ Concurrency in Action</a>，市面上第一本讲解C++11并发的权威书籍。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/AlexanderStepanov.jpg" width="120" height="150"></p>

<ul>
<li><strong>Alexander A. Stepanov的博客</strong>：<a href="http://www.stepanovpapers.com/">Collected Papers of Alexander A. Stepanov</a></li>
</ul>


<p>Alexander A. Stepanov，出生于莫斯科，STL之父，<a href='http://www.amazon.cn/gp/product/B006P7V73G/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B006P7V73G&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>编程原本</a>的作者。Alexander A. Stepanov的这个博客如其名，是他个人学术论文的整理，学术价值应该是蛮高吧，不过像我这种低级程序员只能远观了。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/austern.jpg" width="120" height="150"></p>

<ul>
<li><strong>Matt Austern的博客</strong>: <a href="http://lafstern.org/matt/">Matt Austern&rsquo;s Home Page</a></li>
</ul>


<p>Matt Austern, 现任职于Google, 前C++标准委员会主席，SCG STL的最初实现者，<a href='http://www.amazon.cn/gp/product/0201309564/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=0201309564&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Generic Programming and the STL</a>的作者。Matt Austern的这个博客其实是个人主页，没有太多技术东西，只是一些生平和生活照片，无聊的看一下倒还行。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/pjp.jpg" width="120" height="150"></p>

<ul>
<li><strong>P.J. Plauger的博客</strong>：<a href="http://www.stepanovpapers.com/">Collected Papers of Alexander A. Stepanov</a></li>
</ul>


<p>P.J. Plauger，这个名字可能不是每个人都听说过，但在Windows平台开发的同学肯定都用过他写的代码，他就是MS VC STL库的实现者。本来他的博客，只是个人主页并且上面没什么内容，不过看到他的履历里面完成了13部科幻小说的编写，拿来勉励大家吧。</p>

<br/>


<br/>


<h2>C++高手的博客</h2>

<p><img class="pull-right" src="/images/posts/cpp-blogs/akrzemi1.jpeg" width="120" height="150"></p>

<ul>
<li><strong>Andrzej Krzemieński的博客</strong>：<a href="http://akrzemi1.wordpress.com/">Andrzej&rsquo;s C++ blog Guidelines and thoughts about C++</a></li>
</ul>


<p>Andrzej Krzemieński，从名字看是波兰人，近期博客更新较快，表达清晰，行文流畅，内容难度不高，有C++11内容，是像我这样的初级并且语言控的C++程序员的福音。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/SumantTambe.jpg" width="120" height="150"></p>

<ul>
<li><strong>Sumant Tambe的博客</strong>： <a href="http://cpptruths.blogspot.com/">c++ truths</a></li>
</ul>


<p>Sumant Tambe，印度人，美国范德堡大学的计算机博士，技术涉猎广泛，同时也是著名的<a href="http://en.wikibooks.org/wiki/More_C++_Idioms">More C++ Idioms</a>创建者。博客一直更新，内容面向中高级C++程序员，最新文章涉及C++11的“高级Idioms”，比如13年10月的一篇文章主题是：创建递归的lambda表达式。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/JeffPreshing.jpg" width="120" height="150"></p>

<ul>
<li><strong>Jeff Preshing的博客</strong>: <a href="http://preshing.com/">Preshing on Programming</a></li>
</ul>


<p>Jeff Preshing，加拿大人，自称游戏行业开发10数年，C++功力自是深厚。博客每年更新十数篇，C++相关文章内容上进，直面工程上的难题：并发，而不是在C++本身上打转转。且行为流畅，图文并茂，深入前出，是C++工程控的福音。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/Joaqu.jpg" width="120" height="150"></p>

<ul>
<li><strong>Joaquín M López Muñoz的博客</strong>: <a href="http://bannalia.blogspot.com/">Bannalia: trivial notes on themes diverse</a></li>
</ul>


<p>Joaquín M López Muñoz，西班牙人。Boost.MultiIndex的实现者。博客长期更新，内容偏向算法，文章中有大量的公式推演和曲线图表，估计大部分中国开发者对这种内容是不感冒的。计算机或数学系的研究生，并以后打算从事算法相关工作的，推荐阅读。从这个西班牙男人身上，也可以看到老牌欧洲资本主义国家，教育水平的强悍，尤其是基础学科。</p>

<ul>
<li><strong>Daniel Park的博客</strong>: <a href="http://functionalcpp.wordpress.com/">functionalcpp-Abusing the type system like never before</a></li>
</ul>


<p>Daniel Park，喜欢用昵称whanhee，身世不知。一个注重实干的C++狂热分子，正如其博客简介所说，不想接着讲那些被讲烂掉的函数式编程概念，要用C++来实现这些概念。博客是一个关于函数式编程概念如何用C++实现的一个系列文章，作者采用的是C++11乃至C++14的特性，所以对C++高级函数式实现思想感兴趣的不容错过。近期博客更新也较快的。</p>

<ul>
<li><strong>Agustín Bergé的博客</strong>: <a href="http://talesofcpp.fusionfenix.com/">talesofcpp</a></li>
</ul>


<p>Agustín Bergé，86年生阿根廷人，可能是这里面最年轻的，stackoverflow目前排名708。作者想用自己的博客探索永无边界的C++世界，尤其是那些前人未涉足的犄角旮旯，所以C++中毒颇深者可以看看。</p>

<ul>
<li><strong>Chris Kohlhoff的博客</strong>: <a href="http://blog.think-async.com/">Preshing on Programming</a></li>
</ul>


<p>Chris Kohlhoff，澳大利亚人，Boost.asoi作者。博客更新到10年，内容主要涉及网络，asio相关，使用asio的可以去看看。</p>

<h2>中文C++名博</h2>

<p><img class="pull-right" src="/images/posts/cpp-blogs/liuweipeng.jpg" width="120" height="150"></p>

<ul>
<li><strong>刘未鹏的博客</strong>：<a href="http://mindhacks.cn/">MindHacks-思维改变生活</a></li>
</ul>


<p>刘未鹏，84年生人，现就职于微软，<a href='http://www.amazon.cn/gp/product/B008A4Y2R0<em>Imperfect C++</em>B00114BFTO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008A4Y2R0<em>Imperfect C++</em>B00114BFTO&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Exceptional C++ Style</a>译者，大学时对C++有极大的学习兴趣，曾与C++之父邮件往来，记录在另一个博客<a href="http://blog.csdn.net/pongba/">C++的卢浮宫</a>上。据闻刘未鹏现忙于育儿与心理学，所以博客更新较慢，但以往博客含金量高，很值得一读。博客内容偏重于学习方法，纯技术的C++文章少些。</p>

<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/chenhao.jpg" width="120" height="150"></p>

<ul>
<li><strong>陈皓的博客</strong>：<a href="http://coolshell.cn/">酷壳-享受编程和技术所带来的快乐</a></li>
</ul>


<p>陈皓，不认为自己是牛人的牛人，现就职余阿里巴巴。<a href="http://coolshell.cn/articles/4990.html">程序员技术练级攻略</a>这篇博文足以奠定其江湖地位。陈皓自称有技术焦虑症，所以博客更新频繁，内容大量涉及C++及一切劝人上进的观点和方法，也有不少网友的高质量投稿，涉及软件开发的方方面面。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/chenshuo.jpg" width="120" height="150">
* <strong>陈硕的博客</strong>：<a href="http://blog.csdn.net/solstice/">陈硕的Blog</a></p>

<p>陈硕，国内少有的C++工程功底深厚，作风严谨且乐于分享的人。Muduo开源库的作者，有干货著作<a href='http://www.amazon.cn/gp/product/B00AYS2KL0/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00AYS2KL0&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Linux多线程服务端编程:使用muduo C++网络库</a>一本，译注若干。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++中的静态断言]]></title>
    <link href="http://towriting.com/blog/2013/12/10/static-assert/"/>
    <updated>2013-12-10T00:02:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/10/static-assert</id>
    <content type="html"><![CDATA[<h2>什么是静态断言</h2>

<p>断言（Assert)是报告代码状态错误的技术手段。Windows下的C++开发肯定都知道ASSERT或ATLASSERT，这两个宏生成DEBUG版本下的断言，另外还有assert，是C/C++提供的断言函数，效果和以上两个宏是一样的。</p>

<p>那什么是静态断言？上面介绍的普通断言是运行时检测的，静态断言是编译期检测的，所以被称之为静态断言（static assert）。最早知道编译期检测是在Matthew wilson的<a href="http://www.amazon.cn/gp/product/B008A4Y2R0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008A4Y2R0&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="" target="_blank">《Imperfect C++》</a>中，里面称其为约束（constraints)，并抱怨C++为什么不支持如此常用的功能（C++11已有改善）。</p>

<p>那使用静态断言有什么好处呢？</p>

<h2>静态断言的好处</h2>

<ol>
<li>更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</li>
<li>无法忽略的错误，对于Assert类似DEBUG下的断言，有时候被不会被执行到，即使执行到也会遭到一些开发的忽视，而静态断言的错误是无法忽视的，因为构建失败了。</li>
<li>减少运行时开销，静态断言是编译期检测的，减少了运行时开销</li>
</ol>


<p>那如何使用实现静态断言？</p>

<h2>使用静态断言</h2>

<p>静态断言作用的对象一般是编译时已知的状态。任何可以成为模板类参数的内容都可以作为静态断言的对象。</p>

<p>下面看一个静态断言的例子：
```cpp
template <typename D,typename B>
struct has_base
{</p>

<pre><code> ~has_base()
{
    void(*p)(D*,B*) = constraints;
}
</code></pre>

<p>private:</p>

<pre><code>static void constraints(D *pd,B *pb)
</code></pre>

<p>   {</p>

<pre><code>    pb = pd; 
</code></pre>

<p>   }
};
<code>
这个例子最早出自Bjarne Stroustrup之手，用于检测一个类型是否是另一个类型的父类（类型相等和void*的情况没有考虑，用起来像这样子：
</code>cpp
class CBase {};
class CDer: public CBase {};
has_base&lt;CDer, CBase> a;
has_base&lt;CBase, CDer> b; //编译错误
```
它的工作原理是，成员函数constraints试图把D的指针转化成B的指针，这一般只在B是D的派生类时成立。而且constraints函数永远不会被调到，所以没有运行时开销。</p>

<p>在看一个例子：
```cpp
enum personType
{</p>

<pre><code>person_child,
person_adult,
person_woman,
person_man,
person_count    
</code></pre>

<p>};</p>

<p>void ProcessPersonType(personType ptVal)
{
  char dummy[person_count > CHAR_MAX ? -1 : 1];
  char cVal = ptVal;
  // do something with cVal
}</p>

<p><code>``
上面例子里，试图将枚举类型的值转化成cVal,但可能有溢出的问题，所以设置一个静态断言：</code>char dummy[person_count > UCHAR_MAX ? 1 : -1];<code>，原理是如果personType的最大值大于char类型的最大值，则表达式为</code>char dummy[-1]`，我们知道这是编译不过的，所以会提示我们出问题了。</p>

<p>以上方式虽然可以实现静态断言的效果，但提示的信息，可能和我们断言想要报告的完全无关，所以并不是最完美的解决方案。</p>

<h2>C++11中的静态断言</h2>

<p>C++11中增加了static_assert支持静态断言，用法相当简单，static_asset接受两个参数，第一个为要断言的内容，第二个为显示的错误提示。
```cpp
template<int n>                               <br/>
struct Factorial                                  <br/>
{
 static_assert(n > 1, &ldquo;n must bigger than 1&rdquo;);<br/>
 enum{ value=n * Factorial&lt;n-1>::value }; <br/>
};</p>

<p>template&lt;>                                        <br/>
struct Factorial<0>                                  <br/>
{<br/>
 enum{ value=1 };<br/>
};<br/>
```
上面是计算阶乘的一个模板，我们使用static_assert检测n的值大于1，如果不满足则，编译错误，提示为："n must bigger than 1"。</p>

<p>static_assert是编译器很容易实现的一个特性，一般的编译器最新版本应该都已支持。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Safe bool惯用法到explicit标识符]]></title>
    <link href="http://towriting.com/blog/2013/11/01/safe-bool-idiom/"/>
    <updated>2013-11-01T22:52:00+08:00</updated>
    <id>http://towriting.com/blog/2013/11/01/safe-bool-idiom</id>
    <content type="html"><![CDATA[<blockquote><p>C++是一个学语法都能让人入迷的奇葩语言，有各种的奇技淫巧。比如这里的许多的惯用法：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms">More C++ Idioms</a>，虽凝聚了C++程序员的聪明才智，但都是特定时期的产物，
相信都会被冲到C++语言演化长河的河滩上，仅供后人瞻仰（或者是C++本身）。让我们从Safe bool idiom说起。</p></blockquote>

<h2>Safe bool idiom</h2>

<p>什么是safe bool idiom？就是为自定义类型（class）提供检测真假的能力，而又不会带来副作用。</p>

<h3>为类(Class)提供检测真假的能力</h3>

<p>方法有二，第一种简单直白，提供一个返回bool类型的函数，比如下面的isValid成员函数：
<code>cpp
class CData
{
 public:
  bool IsValid() const;
};
int main()
{
  CData data;
  if (data.IsValid())
  {
   //dosomething
  }
}
</code>
这是直观而不易出错的。但多多少少有些强迫症的人会说，如果能像检测内置bool类型一样检测data对象不是更好的保证了代码的语法一致性？
<code>cpp
int main()
{
  CData data;
  if (data)
  {
   //dosomething
  }
}
</code>
同时他又急于向人们展示，"我会使用操作符重载哦“。于是第二种方法出来了，重载bool类型转化操作符：
<code>cpp
class CData
{
 public:
  operator bool() const;
};
int main()
{
  CData data;
  if (data)
  {
   //dosomething
  }
}
</code>
漂亮的外表后面的东西可能是有毒的，比如毒蘑菇、巫婆的毒苹果和传说中的红颜祸水们。软件开发也概莫能外，这个漂亮的解决方案后面有问题。</p>

<h3>bool操作符的副作用</h3>

<p>假使有一个简单的指针外敷类：
```cpp
template<typename T>
class CPtr
{
  T *ptr;
  public:
   operator bool() const
   {</p>

<pre><code>return ptr != nullptr;
</code></pre>

<p>   }
};</p>

<p>int main()
{
  CPtr<float> p1;
  CPtr<int>   p2;</p>

<p>  if (p1 == p2)
  {
   //天知道会怎样
   //something
  }</p>

<p>}</p>

<p>```
有人不小心拿两个不同类型的类对象来比较，不幸的是编译器并没有报错，因为17行隐式调用了operator==(bool,bool)，后面的结果真真天知道。
这可如何是好？C++社区里最不缺人才，很快有人想出解决方案：</p>

<h3>Safe bool实现</h3>

<p>Safe Bool正式的提出是这里：<a href="http://www.artima.com/cppsource/safebool.html">The Safe Bool Idiom</a>，方法就是写一个类型转化操作符，这个操作符返回一个可以进行 <strong>if</strong> 判断的特有类型：
```cpp
class Testable
{</p>

<pre><code>bool ok_;
typedef void (Testable::*bool_type)() const;
void this_type_does_not_support_comparisons() const {}
</code></pre>

<p>  public:</p>

<pre><code>explicit Testable(bool b=true):ok_(b) {}

operator bool_type() const {
  return ok_==true ? 
    &amp;Testable::this_type_does_not_support_comparisons : 0;
}
</code></pre>

<p>};</p>

<p>class TestableOther
{</p>

<pre><code>bool ok_;
typedef void (TestableOther::*bool_type)() const;
void this_type_does_not_support_comparisons() const {}
</code></pre>

<p>  public:</p>

<pre><code>explicit TestableOther(bool b=true):ok_(b) {}

operator bool_type() const {
  return ok_==true ? 
    &amp;Testable::this_type_does_not_support_comparisons : 0;
}
</code></pre>

<p>};</p>

<p>int main()
{
  Testable testable;
  TestableOther testableother;
  if (testable)
  {</p>

<pre><code>//something
</code></pre>

<p>  }
  if (testable == testableother) //编译错误
  {</p>

<p>  }</p>

<p>}</p>

<p>```
上面代码，利用的是bool_type是函数指针类型，所以可以进行 <strong>if</strong> 判断，且不同类的bool_type是不同的，直接比较会编译错误。
这就是safe bool Idiom，详细的代码可以参看这里：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/">More C++ Idioms/Safe bool</a>。
但我认为这个方案是顾此失彼，会引发新的问题，比如类中重载operator int操作符怎么办？</p>

<h2>C++11的做法</h2>

<p>C++11的基因支持safe bool，方法就是使用<a href="http://en.cppreference.com/w/cpp/language/explicit">explicit</a>修饰operator：
```cpp
struct Testable
{</p>

<pre><code>explicit operator bool() const {
      return false;
}
</code></pre>

<p>};</p>

<p>int main()
{
  Testable a, b;
  if (a)      { /<em>do something</em>/ }<br/>
  if (a == b) { /<em>do something</em>/ }  // 编译错误
}
```
<strong>explicit</strong> 在C++11以前是只能用于修饰构造函数，但在C++11中可以用来修饰操作符，上面代码中的operator bool（）加上<strong>explicit</strong>表式其无法隐式转化为bool。
这个解决方案，干净漂亮，无副作用。</p>

<h2>总结</h2>

<p>C++11前后的两种Safe Bool的解决方案比较，优劣立现。站在实用的角度上，C++11出现后，C++中好多“高端技术”已经不需要学习，比如StackOver上列出的这些：<a href="http://stackoverflow.com/questions/9299101/what-c-idioms-are-deprecated-in-c11">what C++ idioms are deprecated in C++11</a>。这些东西就像毛笔字一样，可以仅供专家与爱好者把玩了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++手爱德华]]></title>
    <link href="http://towriting.com/blog/2013/09/23/edward-chands/"/>
    <updated>2013-09-23T22:25:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/23/edward-chands</id>
    <content type="html"><![CDATA[<p><img class="pull-right" src="/images/posts/edward-chands/Edwardscissorhandsposter.png" title="" ></p>

<blockquote><p>我一直在寻找一种可以类比使用C++编程时心情的东西，直到我想起1900年Tim Burton的电影，剪刀手爱德华。</p></blockquote>

<p>在这部电影中，可怜的家伙（Johnny Depp)想温柔的拥抱Winona Ryder但是他笨拙的剪刀手对他们俩都会造成伤害。他的脸上留下了很多伤疤。</p>

<p>拥有一对剪刀手并不总是坏事。爱德华有许多才能，比如，它可以给狗剪除漂亮的发式。</p>

<p>当参加完一些C++会议后，我总会有一些想法，最近参加的是Going Native 2013。去年可喜的是大多会议围绕着闪亮的C++11最新标准。但今年更多的关于实际检查。不要误会，这里有太多的漂亮的小狗发式可以展现（我是说C++代码可以简洁优雅）但是会议的主题总是关于如何避免出错及出错后的补救。</p>

<h2>恐怖小窝</h2>

<p>这里有太多的关于<strong>C++禁忌</strong>的讲座使我意识到这可能不是初级程序员的问题，这明显是C++语言自身的错。所以你仅仅学习了语言的基本元素后就使用它，你会遍体鳞伤的。</p>

<p>C++对此有借口：向后兼容 &mdash; 特别是兼容C语言。你应该认为C作为C++的子集应该像人们不应该每天使用汇编一样，除非你是个汇编程序员。假如你对你的C++工具箱视而不见，你看到的总是裸指针、for循环等丑陋的东西。</p>

<p>一个人所共知的禁忌是不要使用malloc动态分配内存，不要使用free释放内存。malloc接受一个size并返回一个void*，你必须把它转换成其它有用的类型。很难实现一个比这更糟糕的内存分配API。这有一段真的很糟的代码（但一般是运行正确的，假如不可能出现空指针解引用的话）：
```cpp
struct Pod {</p>

<pre><code>int count;
int * counters;
</code></pre>

<p>};</p>

<p>int n = 10;
Pod * pod = (Pod <em>) malloc (sizeof Pod);
pod->count = n
pod->counters = (int </em>) malloc (n * sizeof(int));
&hellip;
free (pod->counters);
free (pod);
```
我希望人们不会写出这样的代码，但我确信现实世界的好多程序的代码中有这样的结构。</p>

<p>C++通过替换malloc和free为new和delete"解决"了多余的强转和易出错的size计算。正确的C++代码应该这样：
```cpp
struct Pod {</p>

<pre><code>int count;
int * counters;
</code></pre>

<p>};</p>

<p>int n = 10;
Pod * pod = new Pod;
pod->count = n;
pod->counters = new int [n];
&hellip;
delete [] pod->counters;
delete pod;
<code>
顺便说一下，空指针引用的问题同样被解决了，因为如果系统内存耗尽，new总是会抛出异常。但这里在第二个new的地方还是有几率发生内存泄漏，所以这是现实中正确的代码：
</code>cpp
class Snd { // Sophisticated New Data
public:</p>

<pre><code>Snd (int n) : _count(n), _counters(new int [n]) {}
~Snd () { delete [] _counters; }
</code></pre>

<p>private:</p>

<pre><code>int _count;
int * _counters;
</code></pre>

<p>};</p>

<p>Snd * snd = new Snd (10);
&hellip;
delete snd;
```
我们做完了吗？才没呢！这段代码不是异常安全的。</p>

<p>C++的基本准则是避免裸指针、避免数组、避免delete。所以医治malloc的良药new也是不应使用的，它会返回危险的指针。</p>

<p>我们都知道（满脸的伤疤可以证明）尽一切可能使用STL容器和智能指针。也应该按值传递参数。不，等一下。按值传递参数因为多余的拷贝会增加性能损耗。使用shared_ptr或shared_ptr的容器怎么样？但这会增加引用计数的滥用。这里有新的解决方案：移动语义和右值引用。</p>

<p>我能举出无数类似的例子。看到规律了没？一个问题的解决方案可能会引入新的问题。不仅C子集需要避免使用。每个新的语言特性或库组建都会带来新的缺陷。当你听完Scott Meyers讲过后，你会发现一个新的特性怎么设计的这么烂（猜一下Scott Meyers论证的最新的缺陷是什么？是移动语义）。</p>

<h2>C++的哲学</h2>

<p>Bjarne Stroustrup一直强调向后兼容对C++来说多么重要。它是C++哲学的根基。它是决定那些代码是合法的依据。然而兼容性给语言演化代理了极大的拖累。如果自然界和C++一样是向后兼容的，人们还会有尾巴、腮、脚蹼、触角 &mdash; 在进化的过程中它们都有过作用。</p>

<p>C++变成了极度复杂的语言。同一件事情有无数种实现方式，但大部分都走向错误、危险、难维护。问题是代码可以编译甚至运行。错误或者缺陷会在后来被发现，甚至是产品发布以后。</p>

<p>你可能会说这是编程语言的自然特性。如果你真这样想，那要好好看看Haskell了。你的第一反应是：用这种极度严苛的语言我不知怎样实现第一件事（阶乘、斐波那契等）。这完全不同于C++。你不会意识到，运气好的话，需要十年你才能发现C++的“真谛”。能否想到，越好的C++程序员，他的代码越具有“函数性”。请教任何一个C++大神，它会回答你：避免可变的（mutation)，避免边际效应，避免继承和派生。但是你将需要严厉的准则和可以控制你同事的能力，因为C++太宽容了。</p>

<p>Haskell一点也不宽容，它不会让你或者你的同事写出不安全的代码的。是的，一开始你可能因为想要用haskell实现C++几分钟可以完成的事情而抓狂。假如你走运，为Sean Parent<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>或类似严格的程序员共事，他将review你的代码，并指出你不要用C++编码了。或者你自己继续在黑暗的日子里，数着自己伤害自己的伤口个数。</p>

<h2>资源管理</h2>

<p>我以资源管理的例子开始这篇文章（严格说是内存管理），因为这是我的个人爱好。从90年代起我就开始写关于资源管理的东西和宣传它。不过失败的是20年后资源管理技术还是鲜为人知。Bjarne Stroustrup有责任花费一半的演讲时间给高级C++程序员讲解资源管理的知识。你也可能会责备初级程序员们没能领悟资源管理是C++编程的根基。但问题是语言并没有指出我一开始写的那段代码有什么纰漏。事实上学习正确的技术就好像学习新的语言。</p>

<p>为何如此艰难？因为C++中最重要的资源管理是内存管理。事实上需要反复强调的是垃圾收集解决不了资源管理的问题：这里有文件句柄，内核对象，打开的数据库等等。这都是重要的资源，但重要性被繁复的内存管理比下去了。为什么不支持垃圾收集，不是因为找不到一种高效的实现方式，因为C++是排斥垃圾收集的。编译器和运行时总要做最坏的打算：不仅一个指针可能是另一个的别名而且内存地址可以保存成整型甚至它的低字节用作位域（所以C++只考虑保守的垃圾收集）。</p>

<p>一个错误的常识是引用计数（shared pointer中使用）比垃圾收集更好。这有个<a href="http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf">研究</a>显示它们是异曲同工的。你应该知道delete一个shared pointer可能会引发任意时间的程序暂停，这和垃圾收集的性能损耗是一样的。这不仅仅是因为一个靠谱的引用计数算法必须处理好环（cycles），并且每次引用计数到0，对象可以达到的指针都需要遍历。用shared pointer创建的数据结构可能花费很长的时间去释放，除了极简单的情况，你无法知道什么时候shared指针要清零了。</p>

<p>在单线程环境下小心的资源管理和使用shared_ptr还是很好的防御方式。但多线程下，麻烦来了。每一次增加减少计数都需要加锁！锁一般由原子变量实现，而不是互斥量。别傻了：使用原子变量消耗很大，这带给我C++的最大问题。</p>

<h2>并发和并行（Concurrency and Parallelism）</h2>

<p>早在8年以前，herb Sutter就发表了著名的声明：<a href="http://www.gotw.ca/publications/concurrency-ddj.htm">免费的午餐结束了</a>！并发并不是发明在2005年。Posix线程1995年就定义了。微软在Windows95引入线程，在NT中支持了多处理器。然而并发是C++11中才有的知识。</p>

<p>C++11算是“白手起家”并发。它必须定义内存模型：多线程写内存时，什么时候和以什么顺序使其对其它线程可见。基于实用的考虑，C++的内存模型是从java中拷贝来的（去掉了一些有争议的数据竞争时的保证）。一句话就是，如果没有数据竞争C++程序是按次序的。</p>

<p>C++11定义了关于线程创建和管理的一些元素，这些同步元素都是被dijkstra和hoare在1960年定义的，比如互斥量（mutexes）和条件变量。有人可能会争辩这些是否是同步的好组件，但这没关系因为都知道他们不是可组装的（composable)。STM（Software Transactional Memory）是可组装的抽象，但这很难在命令式语言中高效及正确的实现。标准委员会有个STM学习小组，所以STM还是有机会成为标准的一部分的。但是因为C++对边界效应不做任何控制，所以它会很难正确应用的。</p>

<p>还有一些误导和混淆是尝试去提供基于任务的并行，使用的是async tasks和非组装的futures（慎重考虑后都会在C++14中不推荐使用）。线程局部变量的标准化也使基于任务的并发很难实现。锁和条件变量也是线程相关的，而不是任务相关的。未来几年标准委员会的当务之急就是这些了：基于任务的并行, communication通道代替futures , 任务取消, 可能还有longer term, data-driven 并行, 包括支持GPU。一个微软PPL和英特尔TBB的衍生可能会被加进标准库（希望不是微软的AMP）。</p>

<p>预测推断所有这些可以在2015年标准化和实现。假如预测成真，我还是不相信人们会用C++实现并行编程。C++是为单线程编程设计的，支持并行编程需要革命而不是改革。四个字：数据竞争，指令型语言没有对此提供保护，可能除了D语言。</p>

<p>在C++中，数据默认是线程共享的、默认是可变的；函数默认是有边界效应的。所有这些指针和引用为数据竞争提供了富饶的土壤。数据结构和函数在竞争上的先天不足使类型系统无法反射。在C++中，假如你有个对象的const引用，但不能保证另一个线程中不会修改它。更糟的是，一个const对象里面的引用默认是可变的。</p>

<p>D语言至少有深度const和不可变的概念（没有线程可以修改一个不可变的数据结构）。D语言朝着并发的另一个改良是可以定义纯函数（pure functions)。在D语言中，可变对象默认不是进程共享的。这是正确的方向，虽然增加了共享对象的运行开销。更重要的想法是，线程不是一个并发编程的好的抽象，所以这种改进在轻量级的任务序列中就不那么有效了。</p>

<p>但是C++对这些都不支持，并且看起来永远都支持不了。</p>

<p>当然，你可能认出了这些并发和并行的特征都是函数式语言具有的，特别是不可变和纯函数。别嫌我烦：Haskell是并发编程上执牛耳者，包括GPU编程。这是为什么我在布道C++技巧数载后轻易转向了haskell。每一个认真对待并发和并行的程序员都应该好好学习haskell看一下它是如何处理这一切的。这里有一本Simon Marlow写的不错的书：<a href="http://www.amazon.cn/gp/product/1449335942/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1449335942&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="">Parallel and Concurrent Programming in Haskell</a>，读完它你或者开始在C++中使用函数式编程技术，或者认识到并发编程和指令式编程的分歧而转投Haskell。</p>

<h2>结论</h2>

<p>我认为C++语言和其哲学是和并发编程的需求冲突的。这种冲突导致并发编程在主流软件开发中缓慢前行。因为这过时的编程范式，微处理器、vector units和GPU的巨大能力被业界浪费了。</p>

<p>翻译自：<a href="http://bartoszmilewski.com/2013/09/19/edward-chands/">Edward C++Hands</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Adobe公司的首席科学家和移动数字图像组的架构师<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
