<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2017-12-01T01:26:58+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bjarne Stroustrup previews C++ 17]]></title>
    <link href="http://towriting.com/blog/2016/03/18/bjarne-stroustrup-previews-c-plus-plus-17/"/>
    <updated>2016-03-18T07:17:22+08:00</updated>
    <id>http://towriting.com/blog/2016/03/18/bjarne-stroustrup-previews-c-plus-plus-17</id>
    <content type="html"><![CDATA[<p>本文是infoWorld关于C++17对C++之父进行的采访，原文见<a href="0">这里</a></p>

<hr />

<p><strong>InfoWorld</strong>:C++17什么时候可用?</p>

<p><strong>Stroustrup</strong>:C++17将会在2017年的某个时间正式发布，可能是在秋季。主要特性的实现会准时或提前完成。其实有些部分现在已经实现了。</p>

<p><strong>InfoWorld</strong>:你认为C++17有哪些重大的新特性?</p>

<p><strong>Stroustrup</strong>:如何定义重大呢，假如一个语言特性或者库会影响你对这门语言的看法并且影响你的代码结构，那我认为它就是重要的。按照这个定义，很遗憾，我的答案是：
对于绝大多数人来说，C++17并没有重大的特性。请不要把"C++17并无重大改进”这样的文字加粗或者作为文章的标题，因为这是不准确的、是不必要的煽动。我很看好文件库(file system library)和
并行算法(parallel algorithms)。它们特别有用，会使有些任务变简单，但对于大部分人来说，这并不是重大的特性。</p>

<p>然而，我认为重大的特性以其它的方式存在。一些重大的特性会出现在TS(Technical Specifications)中。比如：concepts, networking, more concurrency stuff, ranges (Standard Template Library 2), modules, coroutines.
它们肯定不会被包含在C++17中，但它们确实存在着。</p>

<p><strong>InfoWorld</strong>:C++17的哪些<a href="http://meetingcpp.com/index.php/br/items/cpp17-and-other-future-highlights-of-cpp.html">改进</a>对开发者影响最大呢？</p>

<ul>
<li>(parts of) Library Fundamentals TS v1</li>
<li>Parallelism TS v1 * File System TS v1</li>
<li>Special math functions</li>
<li>hardware<em>*</em>interference_size * .is_always_lockfree() * clamp()</li>
<li>non-const .data() for string</li>
</ul>


<p><strong>Stroustrup</strong>:这因人而异，因你做的事情而异。对我来说，我认为并行算法是最重要的，文件系统库也是很方便的特性. <code>optional</code>, <code>any</code>和<code>string_view</code>这些基础库中的东西也很重要. 另外STL中其它小的改进也很多.
如果你是搞数学的，那么数学库对你是不可或缺的，现在也都在标准库中了。</p>

<p><strong>InfoWorld</strong>:7月份能知道C++17所有的特性(facets)吗?</p>

<p><strong>Stroustrup</strong>:我希望可以，2016年6月下旬，我们会在芬兰奥卢确定一些小的提议,比如:</p>

<ul>
<li>Dynamic memory allocation for overaligned data (for better vectorization)</li>
<li>Template parameter deduction for constructors (make many"make functions" redundant)</li>
<li>constexpr_if (a compile-time if)</li>
<li>Refining Expression Evaluation Order for Idiomatic C++ (finally, we can eliminate bugs from people accidentally relying on undefined order of evaluation)</li>
<li>Default comparisons (==, !=, &lt;, &lt;=, >, and >=)</li>
<li>Operator Dot (smart references)</li>
<li>Generalizing the Range-Based For Loop (for sentinel-based and counted ranges)</li>
<li>Structured bindings (simple use of multiple return types)</li>
</ul>


<p>只要不是运气太差，这些都可以确定下来的。当然，投票统计之前所有事情都是无法确定的。标准委员会会争取共识，一张否决票顶五张赞成票。和16年3月份通过的决议比较，假如本次通过了大部分决议那C++17将变得更加有趣。</p>

<p><strong>InfoWorld</strong>:随着<code>constexpr lambdas</code>进入C++17，C++是不是朝着函数式编程语言更进了一步。这对开发者有什么影响呢？</p>

<p><strong>Stroustrup</strong>:自从1994年STL起，C++平稳而谨慎的增加着函数式编程技术的使用。<code>constexpr lambdas</code>只是编译时特性的一个简单扩展。如果<code>structured bindings</code>的决议C++17通过了的话，
多返回值将被支持，就像一些函数式编程语言的函数一样。</p>

<p><strong>InfoWorld</strong>:<code>Concepts</code>这个可以改善编译时诊断的技术，没有被加入C++17是不是一件遗憾的事情？</p>

<p><strong>Stroustrup</strong>:对我来说是的，这是个巨大的遗憾。从2004年，我就和Gabriel Dos Reis及其他几个人一起，在这个问题上研究了好几年，并且用Andrew Sutton的实现测试了三年的时间。我觉得可以
正式发布这个特性了，但标准委员会的大多数人因为各种原因不同意。一个<code>Concept</code>是对类型和值的集合的编译时断言(predicate)。我认为“更好的错误提示"是<code>Concept</code>最基础且重要的一个优势：我们可以对
我们泛型函数（模板）的参数设定要求。这样可以促成更好的设计、更好的接口、更高效的代码。</p>

<p><strong>InfoWorld</strong>:你能不能回答下，为什么<code>modules</code>和<code>co-routines</code>也不会放到c++17.</p>

<p><strong>Stroustrup</strong>:我很乐意看到<code>modules</code>可以更好的防范某些单元上下文中的改变(比如宏)和更好的编译速度，但是提议还没有为C++17准备好，所以只能加进TS了。我想最终<code>modules</code>会变成一个重要的特性。
它解决了C/C++里面长期存在的问题。MS C++(vs2015)和clang的某些版本已经有类似<code>modules</code>的支持。对于<code>co-routines</code>没有直接放到c++17而是放到TS中我很失望。我认为它在一些特殊的场景下很重要(pipelines and generators)。
MS Vc++（vs2015）也集成了这个特性。</p>

<p><strong>InfoWorld</strong>:为什么你不延期发布一年，以使<code>concepts</code>、<code>modules</code>和<code>co-routines</code>等特性可以一起发布呢?</p>

<p><strong>Stroustrup</strong>:我以前也被问过这个问题，我回答了no, 我们要保证c++17可以按期发布。一次延期会是一次很不好的先例，会导致后面更多的延期。假如c++17变成c++18, 我想c++20会变成c++22或者c++23。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++API设计 - 笔记]]></title>
    <link href="http://towriting.com/blog/2014/11/16/api-design-for-c-plus-plus-notes/"/>
    <updated>2014-11-16T04:24:38+08:00</updated>
    <id>http://towriting.com/blog/2014/11/16/api-design-for-c-plus-plus-notes</id>
    <content type="html"><![CDATA[<p><a href='http://www.amazon.cn/gp/product/B00EE13U30/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00EE13U30&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>C++ API设计</a>从书名看是关于设计C++接口的书，内容却不仅仅是关于C++接口设计。书还算实用，但如果看过代码大全和Effective系列的话，可以不用在看这本书了。</p>

<h2>笔记</h2>

<p>P91 重构就像汽车高速行驶时更换引擎，但还不能停车</p>

<p>P103 API的第一个发行版本很重要</p>

<p>P115 LISKOV替换原则指出，如果S是T的子类，那么在行为上，S不需要修改就可以替换T类型的对象</p>

<p>P117 私有继承、Was-a的关系</p>

<p>P119 开发封闭原则是一种启发式的原则，则不是必须遵守的</p>

<p>P121 一个好的名字往往可以表达类的意图，如果一个类难以命名，这往往是缺乏设计的信号</p>

<p>P122 函数尽量使用正面的概念命名，比如IsConnect而不是IsUnConnect</p>

<p>P132 C API比C++ API具有更好的二进制兼容性</p>

<p>P140 可以使用预处理器技术模拟模板</p>

<p>P176 避免使用友元，这往往意味这糟糕的设计</p>

<p>P182 如果没有必要使用Dynamic_Cast则常见的做法是关闭运行时信息生成</p>

<p>P182 不要猜测性能瓶颈的位置</p>

<p>P183 传值可能会导致对象切割而引起莫名其妙的问题</p>

<p>P185 不应该前置声明STL的类型</p>

<p>P192 C++11中一个构造函数可以调用其他的构造函数</p>

<p>P192 对象越小，就越适合缓存</p>

<p>P197 Donald Knuth有句名言：过早优化是万恶之源</p>

<p>P211 Linux 的奇数版本号代表开发版本</p>

<p>P216 如果确实需要做二进制不兼容，则需要考虑给信库起个新名字。比如zlib.dll &ndash;> zlib1.dll</p>

<p>P225 弃用标记：__declspec(deprecated)</p>

<p>P250 时间驱动、质量驱动和功能驱动</p>

<p>P257 性能测试的结果是实数而不是简单的真和假</p>

<p>P264 驱动测试开发的好处是推动你考虑接口会被如何调用</p>

<p>P286 SWIG</p>

<p>P286 任何脚本绑定技术都是建立在适配器模式上的</p>

<p>P286 Boost.Python支持Boost和Python的互相交互</p>

<p>P265 模拟对象又可以简单称为MOCK</p>

<p>P339 每个DLL有相应的到入库lib文件，虽然静态库和导入库的格式都是lib但他们的文件类型是不同的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谁在用C++ STL？]]></title>
    <link href="http://towriting.com/blog/2014/04/18/who-use-stl/"/>
    <updated>2014-04-18T23:39:00+08:00</updated>
    <id>http://towriting.com/blog/2014/04/18/who-use-stl</id>
    <content type="html"><![CDATA[<p>C++用了四年了，这两天才把<a href='http://www.amazon.cn/gp/product/B00DGLU91K/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00DGLU91K&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Effective STL</a>看了一遍。此书作为C++经典书系Effective三部曲之一，知名度与所受褒扬远不及另两本，个中缘由是否因为STL地位不济。所以今日以自己鄙陋的经历来谈一谈当前STL在C++程序员中的地位和使用状况。</p>

<p>大家知道STL中三大法宝：容器、迭代器和算法。我所经历的公司/团队STL的使用情况：</p>

<hr />

<table border="1">
<tr><th>序号</th><th>团队规模</th><th>项目规模</th><th>容器</th><th>迭代器</th><th>高级迭代器</th><th>算法</th><th>高级算法</th><th>funtional</th></tr>
<tr><th>1</th><td>5人以下,平均2年经验</td><td>10万以下</td><td>基本没有</td><td>基本没有</td><td>基本没有</td><td>基本没有</td><td>无</td><td>无</td></tr>
<tr><th>2</th><td>10人,平均2年经验</td><td>100万</td><td>较多</td><td>较多</td><td>较少</td><td>较少</td><td>极少</td><td>几无</td></tr>
<tr><th>3</th><td>10人,平均4年经验</td><td>100万</td><td>较多</td><td>较多</td><td>较少</td><td>极少</td><td>较少</td><td>有</td></tr>
</table>


<p>（注：表中迭代器是指通过begin和end获取interator，而高级迭代器指back_inserter等迭代器生成器和内置迭代器;算法指sort,foreach, 高级算法指算法带if的形式）</p>

<hr />

<p><strong>看来，STL并不受大家欢迎，至少在我所呆过的团队里是这样的，为何如此？</strong></p>

<h3>洪水猛兽 （守旧）</h3>

<p>容器（最简单的vector）几乎是大部分C++程序员最开始接触的STL组件，我也不例外。那是10年自己刚毕业那会儿，在一家公司实习，实现一个简单的图像显示和处理的Demo程序。里面图像数据最初是存储在原始的数组（char [])中。那一阵子在狂啃《C++ Primer》，里面提到C++程序员不应该使用这些原生的数组，应该用vector代替，于是自己将程序中的char []替换成了vector<char>。而后发现一些图像算法执行慢了好多，遂请教mentor，mentor是名校的doctor，不编程久已，他并没用过STL，但提出不要用STL，不要追时髦、偷懒，老老实实的写“C”代码就好了。</p>

<p>舔着第一次用STL的伤口，念着mentor的教诲，在这家公司的第一年里自己后来好像就不再关注和使用STL。同期的C++ Programmer共四人，一个工作1年，另两个更久些，那时我们在“不赶时髦”上很团结，大家愉快的使用着VC6，且都不使用STL。</p>

<p>这就是某些老式小型软件公司一些C++程序员对待STL的态度：排斥守旧，其中缘由高校的计算机教育脱不了干系。</p>

<p>当然有个人和特殊业务场景也会排斥STL：<a href="http://www.zhihu.com/question/20201972">为何某些公司不容许使用C++ STL</a>。</p>

<h3>玄之又玄 （畏惧）</h3>

<p>C++本来有有很多不易掌握的细节。而STL同样如此，简单强大，但有微妙的陷阱。就拿Effective STL来说，条款1：慎重的选择容器类型中，就有大量自己不曾掌握模棱两可的点：</p>

<ul>
<li>string的swap会导致迭代器失效</li>
<li>容器的内部可能有引用计数</li>
<li>插入、删除操作的回滚能力</li>
</ul>


<p>当然有些细节无需掌握，但就我接触到的C++程序员大都使用STL的最简单用法: 使用vector和map存储一些数据，而对稍微高级点的STL用法麻木无知或畏惧使用：</p>

<ol>
<li>各种容器的区别，如何使用容器兼容C接口</li>
<li>for_each等函数存在的意义，如何写出函数式风格的代码</li>
<li>类的成员函数和同名全局函数的区别，比如set::find与std::find，map::remove与std::remove等等</li>
<li>xxx_if函数的使用，如何写predicate</li>
<li>function&lt;>, bind函数的使用</li>
<li>一些惯用法，比如erase-remove</li>
</ol>


<p>以上是我认为一个合格的C++开发应掌握的STL技巧。而掌握这些技巧，却是需要一段时间的练习，是否这一原因导致了一部分人对STL的无爱？因为即使不掌握这些技巧，功能是同样可以完成的。</p>

<h3>曲高和寡 （风气)</h3>

<p>语言的出现提高了人们交流的效率，设计模式的出现提高了软件人员的交流效率，但前提是交流的双方都懂才行。STL同样如此，我之蜜糖彼之砒霜，在一个不了解STL的团队中大量使用STL尤其是一些稍微“高级另类”的用法，难免遭人排斥。而且别人很难看懂你写的代码，指责你的代码难于维护，这并不是谁的错，这是一个道不同不幸与某的问题。</p>

<p>在一个不用、不了解STL的团队，喜爱STL之人会克制使用STL！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《C++标准库第二版 上册》笔记]]></title>
    <link href="http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1/"/>
    <updated>2013-12-18T23:27:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1</id>
    <content type="html"><![CDATA[<p>p63 a pair&lt;> using a type that has only a nonconstant copy constructor will no longer compile.</p>

<p>p64 std::piecewise_construct is passed as the first argument is class Foo forced to use a constructor that takes the elements of the tuple rather than a tuple as a whole.</p>

<p>p65 The make_pair() function template enables you to create a value pair without writing the types explicitly.</p>

<p>p67 pair used in functions that return two values.</p>

<p>p68 tuples extend the concept of pairs to an arbitrary number.we can access elements with the get&lt;>() function template.</p>

<p>p70 A tuple type can be a reference. For example:</p>

<p><code>cpp
string s;
tuple&lt;string&amp;&gt; t(s);
</code></p>

<p>For element access, you must know the index of element at complier time.It is also a complier error if you pass a invalid index.
Make_tuple can create tuple without special the type of element.
By using references with make_tuple(), you can extract values of a tuple back to some other variables. e.g.</p>

<p><code>cpp
std::tuple&lt;int, float&gt; t(1, 1.5);
int i = 0;
float f = 2.0;
make_tuple(std::ref(i), std::ref(f)) = t;
</code></p>

<p>p72 std::tie() creates a tuple of references. the use of std::ignore allows ignoring tuple elements while parsing with tie()</p>

<p>p75 You can initialize a two-element tuple with a pair.Also, you can assign a pair to a two-element tuple.</p>

<p>p76 Tow types of smart pointer:</p>

<ul>
<li>shared_ptr. Multiple smart pointer can refer to the same object.</li>
<li>unique_ptr. only one smart pointer can refer to this object at a time.</li>
</ul>


<p>p77 shared_ptr. you can define other ways to clean up object.</p>

<p>p78 shared_ptr can&rsquo;t assign a new ordinary pointer. but can use reset function to reset the pointer.</p>

<p>p79 assigning a nullptr to a shared_ptr would delete the ownship.</p>

<p>p80 Smart pointer, when use new[] to create an array of object, you must define your own deleter.</p>

<p>p85 weak_ptr allows sharing but not owning an object.</p>

<p>p90 You should always directly initialize a smart pointer the moment you create the object with its associated resource.</p>

<p>p95 Aliasing constructor,The constructor taking another shared_pointer and an additional raw pointer.</p>

<p>p96 shared pointers are not thread safe.</p>

<p>p101 You can&rsquo;t copy or assgin a unique pointer if you use the ordinary copy semantics, but can use move semantics.</p>

<p>p102 assgining nullptr is also possible, which has the same effect as calling reset().</p>

<p>p103 The Reason that no std::move is necessary in the return statement of source() is than according to the language rules of c++11, the compiler will try a move automaticallly.</p>

<p>p105 The c++ stl provides a partial spartial specialization of class unique_ptr for array: std::unique_ptr<code>&lt;std::string[]&gt;</code></p>

<p>p110 unique_ptr not necessarily defined as T*</p>

<p>p115 The new concept of numeric limits has two advantages: first, it offers more type safety. second, it enables a programmer to write templates that evaluate these limits.</p>

<p>p119 all members of numeric_limits are declared as constexpr.</p>

<p>p121 you can query for any arbitrary type whether or not it has numeric limits defined.</p>

<p>p125 Type Traits:</p>

<ul>
<li>Type Predicates</li>
<li>Type Relations</li>
<li>Type Modifiers</li>
</ul>


<p>p130 A reference to a constant type is not constant</p>

<p>p136 Note that swap provides an exception specification</p>

<p>p158 Not that time_t usually is just the number of seconds since the UNXI epoch. bu this is not guaranteed.</p>

<p>p166 The marjor advantage of iterators is that they offer a small but common interface for any arbitrary container type.</p>

<p>p166 The concept of STL is base on a separation of data and operations. The data is managed by container classes, and the operations are defined by configurable algorithms. iterators are the glue between these two components.</p>

<p>p167 There are three general kinds of containers:</p>

<ul>
<li>Sequence contains are ordered collections in which every element has a certain postion.</li>
<li>Associative containers are sorted collections in which the postion of an element depends on its value due to a certain sorting criterion: set multiset map multimap.</li>
<li>Unorderd containers. neither the order of insertion nor the value of the inserted element has an influence on the postion of the element, and the position might change over the lifetime of the container: unordered_set,undered_multiset,undered_map,undered_multimap.</li>
</ul>


<p>p170 size() is provided for any container class execept singly linked lists(class forward_list)</p>

<p>p170 deque rhymes with &ldquo;check&rdquo;</p>

<p>p171 the push_front is not provided for vectors, because it would have a bad runtime for vectors, but is is possible to insert an element at the beginning of a vector.</p>

<p>p171 using array. with a safer and more convenient interface.</p>

<p>p176 forward_list is in principle just a limited list.</p>

<p>p177 The major advantage of associative containers is that finding an element with a specific value is rather fast.</p>

<p>p177 you can consider a set as a special kind of map, in which the value is identical to the key. in fact, all these are implemented by using the same basic implementation of a binary tree.</p>

<p>p180 C++11 guarantees that newly inserted elements are inserted at the end of equivalent elements that multisets and multimaps already contain.</p>

<p>p180 unordered containers are typically implemented as a hash table. the goal is that each element has its own position so that you have fast access to each element.</p>

<p>p185 associative array: an array whose index is not an integer value.</p>

<p>p188 an iterator is an object that can iterate over elements. iterators share the same interface but have different types.</p>

<p>p189 every container defines two iterator types:</p>

<ul>
<li>container::iterator is provided to iterator over elements in read/write mode</li>
<li>container::const_iterator is provided to iterator over elements in read mode</li>
</ul>


<p>p199 To write generic code you should not use special operations for random-access iterators.</p>

<p>p199 Algorithms are not member functions of the container classer but instead are global functions that operator wich iterators. this concept reduces the amount of code and increases the power and the flexibility of the library.</p>

<p>p208 Multiple Ranges, make sure that the second and additional ranges have at least as many elements as the first range.</p>

<p>p209 associative and unordered containers cannot be used as a destination for overwriting algorithms.</p>

<p>p210 Interator Adapters</p>

<p>p210 Insert Interators solve the problem of algorithms that write to destination that does not have enough room.</p>

<p>p212 general insertor call insert()</p>

<p>p213 <code>istream_iterator&lt;string&gt;()</code> calls the default constructor of iterators that creates a so-called end-of-stream iterator.</p>

<p>p214 reverse iterators rbegin()\rend()</p>

<p>p220 distance if iterator were random-access, you could with &ldquo;&ndash;&rdquo;</p>

<p>p221 to make agorithms as flexible as possible there are good reason not requrie that interator know their container.</p>

<p>p223 a container might have member functions that provide much better performance that algorithms</p>

<p>p226 predicates must stateless</p>

<p>p232 Lambda no default constructor and no assignment operator.</p>

<p>p235 function object are functions with states</p>

<ul>
<li>fnctction object has its own type</li>
<li>function object may faster than ordinary functions.</li>
</ul>


<p>p241 Binder to combine predefined function objects with other values or use special cases.</p>

<p>p248 it&rsquo;s turns out that exception specifications could cause performance penalties, so they were replaced by noexcept with c++11.</p>

<p>p249 if you need a transaction-safe container, you should use a list.</p>

<p>p254 container&rsquo;s operators are not safe in the sense that they check for every possible error.</p>

<p>p257 since c++11 you can use move constructor</p>

<p>p258 Move Sytax: The contents of the container on the right-hand side are undefined afterwared:</p>

<p>p258 forware_list not provided size()</p>

<p>p260 all containers except vectors and deques guarantee that iterators an references to elements remianing valid if other elemenets are deleteed.</p>

<p>p262 array&lt;> default initialized.</p>

<p>p267 array you must not pass an iterator as the address of the first element.</p>

<p>p271 vectors： capacity(), which returns the number of elements a vector could contain in its actual memory.</p>

<p>p271 If the only reason for initialization is to reserve memory, you should use reserve()</p>

<p>p271 it is not possible to call reserve for vectors to shrink the capacity.</p>

<p>p282 For vector<bool> the return type of subscript operator is an auxiliary class.</p>

<p>p283 Deque is typically implemented as a bunch of individual blocks.</p>

<p>p284 Deque provide no support to control the capacity and the momnet of reallocation.Howerer reallocation may perform better than for vectors because according to their typical internal structure, deques don&rsquo;t have to copy all elemenets on reallocation.</p>

<p>p284 Blocks of memory might get freed when they are no longer used(implementation specific)</p>

<p>p286 You could say that lists are transaction safe.</p>

<p>p301 The design goal to have &ldquo;zero space or time overhead relative to a hand-written C-stype single linked list.</p>

<p>p303 forward_list provide no support size(), but you can use std::distance(list.begin(),list.end())</p>

<p>p315 you cant change set&rsquo;s value from interator</p>

<p>p316 not that the sorting criterion is also used to check for equivalence of two elements in the same container.</p>

<p>p338 std::for_each(coll.begin(), coll.end(), [] (decltype(coll)::value_type &amp;elem) {}
p342 piecewise_construct emplace.</p>

<p>p345 [] is slower than the insert()</p>

<p>p366 unorder container</p>

<p>p366 unorder containers are optimized for fast searching of elements</p>

<p>p386 using the noninvasive approach is simple, you need only objects that are able to iterate over the elements of an array by using the STL iterator interface.</p>

<p>p386 Any Thing that behaves like an iterator is an iterator.</p>

<p>p437 forward iterators, it is guaranteed that for two forward iterators that refor to the same elemnet, operator == yields true and that they will refer to the same value after both are incremented.</p>

<p>p442 to be able to change container and iterator types, you should use advance</p>

<p>p460 for insert iterator, a bad hint might even be worse than no hint.</p>

<p>p471 writing user-defined iterators</p>

<p>p476 each function object has its own type</p>

<p>p479 by default, function objects are passed by value rather than by reference.</p>

<p>p483 for_each can return a value</p>

<p>p485 a predicate should always be stateless. you should declare operator() as const. but lambda not exist this problem.</p>

<p>p494 bind also could bind data member.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boost.Lambda与C++11.Lambda的用法对比]]></title>
    <link href="http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda/"/>
    <updated>2013-12-13T22:38:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda</id>
    <content type="html"><![CDATA[<p>我们知道C++11已经支持了Lambda表达式，大部分新的编译器都已支持Lambda。但boost里面的Lambda还是有存在的必要，因为并不是每个人都有选择自己编译环境的权利。</p>

<p>让我们通过几个例子对比C++11.Lambda来学习一下boost.Lambda的用法，详细的C++11.Lambda用法可以看这里：<a href="/blog/2013/08/11/lambda-closures/">C++11系列-Lambda表达式</a></p>

<h3>1.a boost.Lambda：构造一个functor</h3>

<p>boost.Lambda的使用是基于placeholder: <code>boost::Lambda::_1</code>,<code>boost::Lambda::_2</code>,<code>boost::Lambda::_3</code>可以理解为Lambda表达式的第一、第二、第三个参数。Lambda的出现利索地解决了STL算法库函数的使用不便。让我们首先看一个最简单的boost.Lambda与std::for_each结合的例子:</p>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin values in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;&ldquo;,&rdquo;);
std::cout&lt;&lt;std::endl;
```</p>

<p>上面的例子，使用std::for_each遍历vector中的元素并打印内容。boost::Lambda::_1这个占位符表示for_each遍历时传进来的第一个参数，<code>std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;","</code>可以理解为临时创建出来的匿名函数，函数的定义是<code>void(int)</code>。</p>

<p>让我们对比一下C++11标准的写法:</p>

<h3>1.b C++11.Lambda：构造一个functor</h3>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin value in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), <a href="const%20int%20&amp;%20val"></a>
{
std::cout&lt;&lt;val&lt;&lt;&ldquo;,&rdquo;;
});
std::cout&lt;&lt;std::endl;
```
一眼望去竟是boost的Lambda用法简洁。</p>

<h3>2.a boost.Lambda：修改参数的内容</h3>

<p>上面的例子，我们使用Lambda表达式，借助于for_each，对vector中的元素进行了访问，那我们可以修改vector的内容吗？</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), boost::Lambda::_1 *= boost::Lambda::_1);
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;",");//打印
std::cout&lt;&lt;std::endl;
</code>
上面的例子，功能是对vecIn中的值求平方。占位符boost::Lambda::_1直接用引用的方式得到了传入的参数（vecIn的元素），结果直接改写进了vecIn。</p>

<h3>2.b C++11.Lambda：修改参数的内容</h3>

<p>修改1.b函数定义为引用即可</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [](int &amp; val)
{
val *= val;
});
//打印：
std::for_each(vecIn.begin(), vecIn.end(), [](const int &amp; val)
{
std::cout&lt;&lt;val&lt;&lt;",";
});
std::cout&lt;&lt;std::endl;
</code></p>

<h3>3.a boost.Lambda：变量捕获</h3>

<p>boost.Lambda可以很方便的以引用的方式捕获local变量，看例子：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), sum += boost::Lambda::_1);
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>3.b C++11.Lambda：变量捕获</h3>

<p>C++11捕获变量，可控性更强，我们可以指定捕获方式：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [&amp;sum](int &amp; val)
{
sum += val;
});
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>4.a boost.Lambda：返回值</h3>

<p>有时需要匿名函数返回结果，比如作为std::find_if类似函数的Predicate函数时，这种能力boost.Lambda当然也是胜任的，整个Lambda表达式的结果，即是函数的返回值。</p>

<p>```cpp
boost::function&lt;bool(int)> IsOdd = boost::Lambda::_1 % 2 != 0;</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```
上面的例子创建了一个检测参数是否是奇数的匿名函数，并保存到IsOdd对象中，然后对其进行了调用。例子同样演示了如何将一个boost.Lambda表达式存储起来，后续使用的方法。</p>

<h3>4.b C++11.Lambda：返回值</h3>

<p>C++11的返回值，必须使用return语句，返回值的类型有些时候也需要显示指定。
```cpp
std::function&lt;bool(int)> IsOdd = (std::function&lt;bool(int)>)<a href="int%20val"></a>{return val % 2 != 0;};</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```</p>

<h3>5. 上面四个例子的运行结果</h3>

<pre><code>the orgin values in vecIn：
1,2,3,
the values in vecIn after Square：
1,4,9,
the sum of values in vecIn：
14
100 is Odd？ false
</code></pre>
]]></content>
  </entry>
  
</feed>
