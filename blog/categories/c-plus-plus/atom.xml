<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2014-10-26T20:47:26+00:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[谁在用C++ STL？]]></title>
    <link href="http://towriting.com/blog/2014/04/18/who-use-stl/"/>
    <updated>2014-04-18T23:39:00+00:00</updated>
    <id>http://towriting.com/blog/2014/04/18/who-use-stl</id>
    <content type="html"><![CDATA[<p>C++用了四年了，这两天才把<a href='http://www.amazon.cn/gp/product/B00DGLU91K/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00DGLU91K&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Effective STL</a>看了一遍。此书作为C++经典书系Effective三部曲之一，知名度与所受褒扬远不及另两本，个中缘由是否因为STL地位不济。所以今日以自己鄙陋的经历来谈一谈当前STL在C++程序员中的地位和使用状况。</p>

<p>大家知道STL中三大法宝：容器、迭代器和算法。我所经历的公司/团队STL的使用情况：</p>

<hr />

<table border="1">
<tr><th>序号</th><th>团队规模</th><th>项目规模</th><th>容器</th><th>迭代器</th><th>高级迭代器</th><th>算法</th><th>高级算法</th><th>funtional</th></tr>
<tr><th>1</th><td>5人以下,平均2年经验</td><td>10万以下</td><td>基本没有</td><td>基本没有</td><td>基本没有</td><td>基本没有</td><td>无</td><td>无</td></tr>
<tr><th>2</th><td>10人,平均2年经验</td><td>100万</td><td>较多</td><td>较多</td><td>较少</td><td>较少</td><td>极少</td><td>几无</td></tr>
<tr><th>3</th><td>10人,平均4年经验</td><td>100万</td><td>较多</td><td>较多</td><td>较少</td><td>极少</td><td>较少</td><td>有</td></tr>
</table>


<p>（注：表中迭代器是指通过begin和end获取interator，而高级迭代器指back_inserter等迭代器生成器和内置迭代器;算法指sort,foreach, 高级算法指算法带if的形式）</p>

<hr />

<p><strong>看来，STL并不受大家欢迎，至少在我所呆过的团队里是这样的，为何如此？</strong></p>

<h3>洪水猛兽 （守旧）</h3>

<p>容器（最简单的vector）几乎是大部分C++程序员最开始接触的STL组件，我也不例外。那是10年自己刚毕业那会儿，在一家公司实习，实现一个简单的图像显示和处理的Demo程序。里面图像数据最初是存储在原始的数组（char [])中。那一阵子在狂啃《C++ Primer》，里面提到C++程序员不应该使用这些原生的数组，应该用vector代替，于是自己将程序中的char []替换成了vector<char>。而后发现一些图像算法执行慢了好多，遂请教mentor，mentor是名校的doctor，不编程久已，他并没用过STL，但提出不要用STL，不要追时髦、偷懒，老老实实的写“C”代码就好了。</p>

<p>舔着第一次用STL的伤口，念着mentor的教诲，在这家公司的第一年里自己后来好像就不再关注和使用STL。同期的C++ Programmer共四人，一个工作1年，另两个更久些，那时我们在“不赶时髦”上很团结，大家愉快的使用着VC6，且都不使用STL。</p>

<p>这就是某些老式小型软件公司一些C++程序员对待STL的态度：排斥守旧，其中缘由高校的计算机教育脱不了干系。</p>

<p>当然有个人和特殊业务场景也会排斥STL：<a href="http://www.zhihu.com/question/20201972">为何某些公司不容许使用C++ STL</a>。</p>

<h3>玄之又玄 （畏惧）</h3>

<p>C++本来有有很多不易掌握的细节。而STL同样如此，简单强大，但有微妙的陷阱。就拿Effective STL来说，条款1：慎重的选择容器类型中，就有大量自己不曾掌握模棱两可的点：</p>

<ul>
<li>string的swap会导致迭代器失效</li>
<li>容器的内部可能有引用计数</li>
<li>插入、删除操作的回滚能力</li>
</ul>


<p>当然有些细节无需掌握，但就我接触到的C++程序员大都使用STL的最简单用法: 使用vector和map存储一些数据，而对稍微高级点的STL用法麻木无知或畏惧使用：</p>

<ol>
<li>各种容器的区别，如何使用容器兼容C接口</li>
<li>for_each等函数存在的意义，如何写出函数式风格的代码</li>
<li>类的成员函数和同名全局函数的区别，比如set::find与std::find，map::remove与std::remove等等</li>
<li>xxx_if函数的使用，如何写predicate</li>
<li>function&lt;>, bind函数的使用</li>
<li>一些惯用法，比如erase-remove</li>
</ol>


<p>以上是我认为一个合格的C++开发应掌握的STL技巧。而掌握这些技巧，却是需要一段时间的练习，是否这一原因导致了一部分人对STL的无爱？因为即使不掌握这些技巧，功能是同样可以完成的。</p>

<h3>曲高和寡 （风气)</h3>

<p>语言的出现提高了人们交流的效率，设计模式的出现提高了软件人员的交流效率，但前提是交流的双方都懂才行。STL同样如此，我之蜜糖彼之砒霜，在一个不了解STL的团队中大量使用STL尤其是一些稍微“高级另类”的用法，难免遭人排斥。而且别人很难看懂你写的代码，指责你的代码难于维护，这并不是谁的错，这是一个道不同不幸与某的问题。</p>

<p>在一个不用、不了解STL的团队，喜爱STL之人会克制使用STL！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《C++标准库第二版 上册》笔记]]></title>
    <link href="http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1/"/>
    <updated>2013-12-18T23:27:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/18/read-notes-of-cpp-standard-1</id>
    <content type="html"><![CDATA[<p>p63 a pair&lt;> using a type that has only a nonconstant copy constructor will no longer compile.</p>

<p>p64 std::piecewise_construct is passed as the first argument is class Foo forced to use a constructor that takes the elements of the tuple rather than a tuple as a whole.</p>

<p>p65 The make_pair() function template enables you to create a value pair without writing the types explicitly.</p>

<p>p67 pair used in functions that return two values.</p>

<p>p68 tuples extend the concept of pairs to an arbitrary number.we can access elements with the get&lt;>() function template.</p>

<p>p70 A tuple type can be a reference. For example:</p>

<p><code>cpp
string s;
tuple&lt;string&amp;&gt; t(s);
</code></p>

<p>For element access, you must know the index of element at complier time.It is also a complier error if you pass a invalid index.
Make_tuple can create tuple without special the type of element.
By using references with make_tuple(), you can extract values of a tuple back to some other variables. e.g.</p>

<p><code>cpp
std::tuple&lt;int, float&gt; t(1, 1.5);
int i = 0;
float f = 2.0;
make_tuple(std::ref(i), std::ref(f)) = t;
</code></p>

<p>p72 std::tie() creates a tuple of references. the use of std::ignore allows ignoring tuple elements while parsing with tie()</p>

<p>p75 You can initialize a two-element tuple with a pair.Also, you can assign a pair to a two-element tuple.</p>

<p>p76 Tow types of smart pointer:</p>

<ul>
<li>shared_ptr. Multiple smart pointer can refer to the same object.</li>
<li>unique_ptr. only one smart pointer can refer to this object at a time.</li>
</ul>


<p>p77 shared_ptr. you can define other ways to clean up object.</p>

<p>p78 shared_ptr can&rsquo;t assign a new ordinary pointer. but can use reset function to reset the pointer.</p>

<p>p79 assigning a nullptr to a shared_ptr would delete the ownship.</p>

<p>p80 Smart pointer, when use new[] to create an array of object, you must define your own deleter.</p>

<p>p85 weak_ptr allows sharing but not owning an object.</p>

<p>p90 You should always directly initialize a smart pointer the moment you create the object with its associated resource.</p>

<p>p95 Aliasing constructor,The constructor taking another shared_pointer and an additional raw pointer.</p>

<p>p96 shared pointers are not thread safe.</p>

<p>p101 You can&rsquo;t copy or assgin a unique pointer if you use the ordinary copy semantics, but can use move semantics.</p>

<p>p102 assgining nullptr is also possible, which has the same effect as calling reset().</p>

<p>p103 The Reason that no std::move is necessary in the return statement of source() is than according to the language rules of c++11, the compiler will try a move automaticallly.</p>

<p>p105 The c++ stl provides a partial spartial specialization of class unique_ptr for array: std::unique_ptr<code>&lt;std::string[]&gt;</code></p>

<p>p110 unique_ptr not necessarily defined as T*</p>

<p>p115 The new concept of numeric limits has two advantages: first, it offers more type safety. second, it enables a programmer to write templates that evaluate these limits.</p>

<p>p119 all members of numeric_limits are declared as constexpr.</p>

<p>p121 you can query for any arbitrary type whether or not it has numeric limits defined.</p>

<p>p125 Type Traits:</p>

<ul>
<li>Type Predicates</li>
<li>Type Relations</li>
<li>Type Modifiers</li>
</ul>


<p>p130 A reference to a constant type is not constant</p>

<p>p136 Note that swap provides an exception specification</p>

<p>p158 Not that time_t usually is just the number of seconds since the UNXI epoch. bu this is not guaranteed.</p>

<p>p166 The marjor advantage of iterators is that they offer a small but common interface for any arbitrary container type.</p>

<p>p166 The concept of STL is base on a separation of data and operations. The data is managed by container classes, and the operations are defined by configurable algorithms. iterators are the glue between these two components.</p>

<p>p167 There are three general kinds of containers:</p>

<ul>
<li>Sequence contains are ordered collections in which every element has a certain postion.</li>
<li>Associative containers are sorted collections in which the postion of an element depends on its value due to a certain sorting criterion: set multiset map multimap.</li>
<li>Unorderd containers. neither the order of insertion nor the value of the inserted element has an influence on the postion of the element, and the position might change over the lifetime of the container: unordered_set,undered_multiset,undered_map,undered_multimap.</li>
</ul>


<p>p170 size() is provided for any container class execept singly linked lists(class forward_list)</p>

<p>p170 deque rhymes with &ldquo;check&rdquo;</p>

<p>p171 the push_front is not provided for vectors, because it would have a bad runtime for vectors, but is is possible to insert an element at the beginning of a vector.</p>

<p>p171 using array. with a safer and more convenient interface.</p>

<p>p176 forward_list is in principle just a limited list.</p>

<p>p177 The major advantage of associative containers is that finding an element with a specific value is rather fast.</p>

<p>p177 you can consider a set as a special kind of map, in which the value is identical to the key. in fact, all these are implemented by using the same basic implementation of a binary tree.</p>

<p>p180 C++11 guarantees that newly inserted elements are inserted at the end of equivalent elements that multisets and multimaps already contain.</p>

<p>p180 unordered containers are typically implemented as a hash table. the goal is that each element has its own position so that you have fast access to each element.</p>

<p>p185 associative array: an array whose index is not an integer value.</p>

<p>p188 an iterator is an object that can iterate over elements. iterators share the same interface but have different types.</p>

<p>p189 every container defines two iterator types:</p>

<ul>
<li>container::iterator is provided to iterator over elements in read/write mode</li>
<li>container::const_iterator is provided to iterator over elements in read mode</li>
</ul>


<p>p199 To write generic code you should not use special operations for random-access iterators.</p>

<p>p199 Algorithms are not member functions of the container classer but instead are global functions that operator wich iterators. this concept reduces the amount of code and increases the power and the flexibility of the library.</p>

<p>p208 Multiple Ranges, make sure that the second and additional ranges have at least as many elements as the first range.</p>

<p>p209 associative and unordered containers cannot be used as a destination for overwriting algorithms.</p>

<p>p210 Interator Adapters</p>

<p>p210 Insert Interators solve the problem of algorithms that write to destination that does not have enough room.</p>

<p>p212 general insertor call insert()</p>

<p>p213 <code>istream_iterator&lt;string&gt;()</code> calls the default constructor of iterators that creates a so-called end-of-stream iterator.</p>

<p>p214 reverse iterators rbegin()\rend()</p>

<p>p220 distance if iterator were random-access, you could with &ldquo;&ndash;&rdquo;</p>

<p>p221 to make agorithms as flexible as possible there are good reason not requrie that interator know their container.</p>

<p>p223 a container might have member functions that provide much better performance that algorithms</p>

<p>p226 predicates must stateless</p>

<p>p232 Lambda no default constructor and no assignment operator.</p>

<p>p235 function object are functions with states</p>

<ul>
<li>fnctction object has its own type</li>
<li>function object may faster than ordinary functions.</li>
</ul>


<p>p241 Binder to combine predefined function objects with other values or use special cases.</p>

<p>p248 it&rsquo;s turns out that exception specifications could cause performance penalties, so they were replaced by noexcept with c++11.</p>

<p>p249 if you need a transaction-safe container, you should use a list.</p>

<p>p254 container&rsquo;s operators are not safe in the sense that they check for every possible error.</p>

<p>p257 since c++11 you can use move constructor</p>

<p>p258 Move Sytax: The contents of the container on the right-hand side are undefined afterwared:</p>

<p>p258 forware_list not provided size()</p>

<p>p260 all containers except vectors and deques guarantee that iterators an references to elements remianing valid if other elemenets are deleteed.</p>

<p>p262 array&lt;> default initialized.</p>

<p>p267 array you must not pass an iterator as the address of the first element.</p>

<p>p271 vectors： capacity(), which returns the number of elements a vector could contain in its actual memory.</p>

<p>p271 If the only reason for initialization is to reserve memory, you should use reserve()</p>

<p>p271 it is not possible to call reserve for vectors to shrink the capacity.</p>

<p>p282 For vector<bool> the return type of subscript operator is an auxiliary class.</p>

<p>p283 Deque is typically implemented as a bunch of individual blocks.</p>

<p>p284 Deque provide no support to control the capacity and the momnet of reallocation.Howerer reallocation may perform better than for vectors because according to their typical internal structure, deques don&rsquo;t have to copy all elemenets on reallocation.</p>

<p>p284 Blocks of memory might get freed when they are no longer used(implementation specific)</p>

<p>p286 You could say that lists are transaction safe.</p>

<p>p301 The design goal to have &ldquo;zero space or time overhead relative to a hand-written C-stype single linked list.</p>

<p>p303 forward_list provide no support size(), but you can use std::distance(list.begin(),list.end())</p>

<p>p315 you cant change set&rsquo;s value from interator</p>

<p>p316 not that the sorting criterion is also used to check for equivalence of two elements in the same container.</p>

<p>p338 std::for_each(coll.begin(), coll.end(), [] (decltype(coll)::value_type &amp;elem) {}
p342 piecewise_construct emplace.</p>

<p>p345 [] is slower than the insert()</p>

<p>p366 unorder container</p>

<p>p366 unorder containers are optimized for fast searching of elements</p>

<p>p386 using the noninvasive approach is simple, you need only objects that are able to iterate over the elements of an array by using the STL iterator interface.</p>

<p>p386 Any Thing that behaves like an iterator is an iterator.</p>

<p>p437 forward iterators, it is guaranteed that for two forward iterators that refor to the same elemnet, operator == yields true and that they will refer to the same value after both are incremented.</p>

<p>p442 to be able to change container and iterator types, you should use advance</p>

<p>p460 for insert iterator, a bad hint might even be worse than no hint.</p>

<p>p471 writing user-defined iterators</p>

<p>p476 each function object has its own type</p>

<p>p479 by default, function objects are passed by value rather than by reference.</p>

<p>p483 for_each can return a value</p>

<p>p485 a predicate should always be stateless. you should declare operator() as const. but lambda not exist this problem.</p>

<p>p494 bind also could bind data member.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boost.Lambda与C++11.Lambda的用法对比]]></title>
    <link href="http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda/"/>
    <updated>2013-12-13T22:38:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda</id>
    <content type="html"><![CDATA[<p>我们知道C++11已经支持了Lambda表达式，大部分新的编译器都已支持Lambda。但boost里面的Lambda还是有存在的必要，因为并不是每个人都有选择自己编译环境的权利。</p>

<p>让我们通过几个例子对比C++11.Lambda来学习一下boost.Lambda的用法，详细的C++11.Lambda用法可以看这里：<a href="/blog/2013/08/11/lambda-closures/">C++11系列-Lambda表达式</a></p>

<h3>1.a boost.Lambda：构造一个functor</h3>

<p>boost.Lambda的使用是基于placeholder: <code>boost::Lambda::_1</code>,<code>boost::Lambda::_2</code>,<code>boost::Lambda::_3</code>可以理解为Lambda表达式的第一、第二、第三个参数。Lambda的出现利索地解决了STL算法库函数的使用不便。让我们首先看一个最简单的boost.Lambda与std::for_each结合的例子:</p>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin values in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;&ldquo;,&rdquo;);
std::cout&lt;&lt;std::endl;
```</p>

<p>上面的例子，使用std::for_each遍历vector中的元素并打印内容。boost::Lambda::_1这个占位符表示for_each遍历时传进来的第一个参数，<code>std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;","</code>可以理解为临时创建出来的匿名函数，函数的定义是<code>void(int)</code>。</p>

<p>让我们对比一下C++11标准的写法:</p>

<h3>1.b C++11.Lambda：构造一个functor</h3>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin value in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), <a href="const%20int%20&amp;%20val"></a>
{
std::cout&lt;&lt;val&lt;&lt;&ldquo;,&rdquo;;
});
std::cout&lt;&lt;std::endl;
```
一眼望去竟是boost的Lambda用法简洁。</p>

<h3>2.a boost.Lambda：修改参数的内容</h3>

<p>上面的例子，我们使用Lambda表达式，借助于for_each，对vector中的元素进行了访问，那我们可以修改vector的内容吗？</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), boost::Lambda::_1 *= boost::Lambda::_1);
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;",");//打印
std::cout&lt;&lt;std::endl;
</code>
上面的例子，功能是对vecIn中的值求平方。占位符boost::Lambda::_1直接用引用的方式得到了传入的参数（vecIn的元素），结果直接改写进了vecIn。</p>

<h3>2.b C++11.Lambda：修改参数的内容</h3>

<p>修改1.b函数定义为引用即可</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [](int &amp; val)
{
val *= val;
});
//打印：
std::for_each(vecIn.begin(), vecIn.end(), [](const int &amp; val)
{
std::cout&lt;&lt;val&lt;&lt;",";
});
std::cout&lt;&lt;std::endl;
</code></p>

<h3>3.a boost.Lambda：变量捕获</h3>

<p>boost.Lambda可以很方便的以引用的方式捕获local变量，看例子：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), sum += boost::Lambda::_1);
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>3.b C++11.Lambda：变量捕获</h3>

<p>C++11捕获变量，可控性更强，我们可以指定捕获方式：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [&amp;sum](int &amp; val)
{
sum += val;
});
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>4.a boost.Lambda：返回值</h3>

<p>有时需要匿名函数返回结果，比如作为std::find_if类似函数的Predicate函数时，这种能力boost.Lambda当然也是胜任的，整个Lambda表达式的结果，即是函数的返回值。</p>

<p>```cpp
boost::function&lt;bool(int)> IsOdd = boost::Lambda::_1 % 2 != 0;</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```
上面的例子创建了一个检测参数是否是奇数的匿名函数，并保存到IsOdd对象中，然后对其进行了调用。例子同样演示了如何将一个boost.Lambda表达式存储起来，后续使用的方法。</p>

<h3>4.b C++11.Lambda：返回值</h3>

<p>C++11的返回值，必须使用return语句，返回值的类型有些时候也需要显示指定。
```cpp
std::function&lt;bool(int)> IsOdd = (std::function&lt;bool(int)>)<a href="int%20val"></a>{return val % 2 != 0;};</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```</p>

<h3>5. 上面四个例子的运行结果</h3>

<pre><code>the orgin values in vecIn：
1,2,3,
the values in vecIn after Square：
1,4,9,
the sum of values in vecIn：
14
100 is Odd？ false
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[那些C++牛人的博客]]></title>
    <link href="http://towriting.com/blog/2013/12/12/cpp-blogs/"/>
    <updated>2013-12-12T20:57:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/12/cpp-blogs</id>
    <content type="html"><![CDATA[<p>现整理收集C++世界里那些“牛人”的个人博客。凡三类：一是令人高山仰止的大牛，对C++语言本身产生过深远的影响的人；二是C++运用炉火纯青的高手，有原创性的技术干货；三是中文世界里的C++牛人。</p>

<h2>C++大牛的博客</h2>

<p><img class="pull-right" src="/images/posts/cpp-blogs/BjarneStroustrup.jpg" width="120" height="150"></p>

<ul>
<li><strong>Bjarne Stroustrup的博客</strong>: <a href="http://www.stroustrup.com/">Bjarne Stroustrup&rsquo;s Homepage</a></li>
</ul>


<p>Bjarne Stroustrup，不认识的可以去面壁了，没有他，就没有我们现在的饭碗。Bjarne Stroustrup是丹麦人，目前任教于<a href="http://en.wikipedia.org/wiki/Texas_A%26M_University">TAMU</a>。他的Homepage和他的书籍<a href='http://www.amazon.cn/gp/product/B003EIKI0C/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B003EIKI0C&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>The C++ Programming Language</a>一样，都是百科全书级的，如果你认真研究，你也会成为你同事或周围人的C++之父。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/ScottMeyers.jpg" width="120" height="150"></p>

<ul>
<li><strong>Scott Meyers的博客</strong>: <a href="http://scottmeyers.blogspot.com/">The View from Aristeia</a></li>
</ul>


<p>Scott Meyers，不多介绍，世界上几乎每个C++程序员都应该知道的名字，畅销书：<a href='http://www.amazon.cn/gp/product/B004G72P24<em>Effective C++</em>B004IP8BD6/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004G72P24<em>Effective C++</em>B004IP8BD6&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>More Effective C++</a>的作者。博客长期更新，就凭Scott Meyers这个名字，就值得一读。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/stan_lippman.jpg" width="120" height="150"></p>

<ul>
<li><strong>Stanley B.Lippman的博客</strong>: <a href="http://blogs.msdn.com/b/slippman/">Stan Lippman&rsquo;s BLog</a></li>
</ul>


<p>Lippman，C++第一个编译器<a href="http://en.wikipedia.org/wiki/Cfront">Cfront</a>的实现者，最大的贡献是凭借其著作<a href='http://www.amazon.cn/gp/product/B00ESUIL0O<em>C++ Primer/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ESUIL0O<em>C++ Primer&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'></a>, 在世界范围内普及了C++。Lippman本人算是个励志故事，父母是蓝领移民，他为了融入美国主流社会而努力工作，终于取得了今日的成就，他的另一本书<a href='http://www.amazon.cn/gp/product/B006QXQXTM</em>Inside The C++ Object Model/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B006QXQXTM</em>Inside The C++ Object Model&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'></a>, 让我知道了C++代码编译后的样子，不过我不知他写该书时发生了什么事情，因为书中有大量的低级错误，与前一本书的严谨截然相反。列出他的博客，更多的是因为他是C++牛人中无法绕过的一个，而其博客久不更新，早已荒芜，而且是MSDN上的专栏，可能不太能提起人多大兴趣去读。</p>

<p><img class="pull-right" src="/images/posts/cpp-blogs/HerbSutter.jpg" width="120" height="150"></p>

<ul>
<li><strong>Herb Sutter的博客</strong>: <a href="http://herbsutter.com/">Sutter’s Mill: Herb Sutter on software, hardware, and concurrency</a></li>
</ul>


<p>Herb Sutter, C++标准委员会主席，目前就职于微软。代表作为C++ Exceptional系列：<a href='http://www.amazon.cn/gp/product/B008CGKUBS<em>Exceptional C++</em>B004IUISIO<em>More Exceptional C++</em>B00114BFTO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008CGKUBS<em>Exceptional C++</em>B004IUISIO<em>More Exceptional C++</em>B00114BFTO&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Exceptional C++ Style</a>, 因封面头像蓄须，被国人称“小胡子”，不过貌似现在刮干净了。博客更新很快，内容杂乱，有技术亦有资讯，gotw系列个人感觉不错。</p>

<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/AndreiAlexandrescu.jpg" width="120" height="150"></p>

<ul>
<li><strong>Andrei Alexandrescu的博客</strong>: <a href="http://erdani.com/index.php/articles/">Official website of Andrei Alexandrescu</a></li>
</ul>


<p>Andrei Alexandrescu，罗马尼亚人，目前任职于FaceBook, C++天书<a href='http://www.amazon.cn/gp/product/0201704315/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=0201704315&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Modern C++ Design: Generic Programming and Design Patterns Applied</a>的作者，凭借此书使C++社区认识到模板编程鬼斧神工之力。后来不满C++而转投D语言，是D语言的主要开发者。不过他的博客貌似好久不更新了，内容也大多学术气息浓厚。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/dave_abrahams.jpg" width="120" height="150"></p>

<ul>
<li><strong>David Abrahams的博客</strong>: <a href="http://daveabrahams.com/">Dave Abrahams: Home Page | Stuff I wrote, things I did, etc</a></li>
</ul>


<p>David Abrahams，美国人，C++标准委员会成员，将exception-safety加入标准，Boost.org的联合创始人，<a href='http://www.amazon.cn/gp/product/B002WB1J0U/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B002WB1J0U&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>C++ Template Metaprogramming</a>的作者。但博客内容一般，最后一篇内容更新时间是12年的，内容不多，也没有太多亮点，不过笑容却是感染了我。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/BartoszMilewski.jpg" width="120" height="150"></p>

<ul>
<li><strong>Bartosz Milewski的博客</strong>：<a href="http://bartoszmilewski.com/">Bartosz Milewski&rsquo;s Programming Cafe：Concurrency, Multicore, C++, Haskell</a></li>
</ul>


<p>Bartosz Milewski，波兰人，物理系毕业的计算机大牛，曾就职于微软。<a href='http://www.amazon.cn/gp/product/B009TB3ZBW/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009TB3ZBW&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>c++ in action</a>的作者。博客更新频繁，内容密实，观点前卫，对C++的不满流露于字里行间，多以Haskell对比C++的不足，然后实现一些函数式编程风格的C++代码。</p>

<p>不才曾翻译过他的文章：<a href="/blog/2013/09/23/edward-chands/">C++手爱德华</a></p>

<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/anthony_williams.jpg" width="120" height="150"></p>

<ul>
<li><strong>Anthony Williams的博客</strong>：<a href="http://www.justsoftwaresolutions.co.uk/blog/">Just Software Solutions</a></li>
</ul>


<p>Anthony Williams，英国人，一个记事起就开始写程序的人。<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html">Boost.Thread</a>的作者，参与了C++11 Thread的标准化工作。博客有一部分技术文章，也有一些标准化和他自己维护的一些库的记录，对C++多线程感兴趣的可以读一下他的书：<a href='http://www.amazon.cn/gp/product/1933988770/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1933988770&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>C++ Concurrency in Action</a>，市面上第一本讲解C++11并发的权威书籍。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/AlexanderStepanov.jpg" width="120" height="150"></p>

<ul>
<li><strong>Alexander A. Stepanov的博客</strong>：<a href="http://www.stepanovpapers.com/">Collected Papers of Alexander A. Stepanov</a></li>
</ul>


<p>Alexander A. Stepanov，出生于莫斯科，STL之父，<a href='http://www.amazon.cn/gp/product/B006P7V73G/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B006P7V73G&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>编程原本</a>的作者。Alexander A. Stepanov的这个博客如其名，是他个人学术论文的整理，学术价值应该是蛮高吧，不过像我这种低级程序员只能远观了。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/austern.jpg" width="120" height="150"></p>

<ul>
<li><strong>Matt Austern的博客</strong>: <a href="http://lafstern.org/matt/">Matt Austern&rsquo;s Home Page</a></li>
</ul>


<p>Matt Austern, 现任职于Google, 前C++标准委员会主席，SCG STL的最初实现者，<a href='http://www.amazon.cn/gp/product/0201309564/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=0201309564&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Generic Programming and the STL</a>的作者。Matt Austern的这个博客其实是个人主页，没有太多技术东西，只是一些生平和生活照片，无聊的看一下倒还行。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/pjp.jpg" width="120" height="150"></p>

<ul>
<li><strong>P.J. Plauger的博客</strong>：<a href="http://www.stepanovpapers.com/">Collected Papers of Alexander A. Stepanov</a></li>
</ul>


<p>P.J. Plauger，这个名字可能不是每个人都听说过，但在Windows平台开发的同学肯定都用过他写的代码，他就是MS VC STL库的实现者。本来他的博客，只是个人主页并且上面没什么内容，不过看到他的履历里面完成了13部科幻小说的编写，拿来勉励大家吧。</p>

<br/>


<br/>


<h2>C++高手的博客</h2>

<p><img class="pull-right" src="/images/posts/cpp-blogs/akrzemi1.jpeg" width="120" height="150"></p>

<ul>
<li><strong>Andrzej Krzemieński的博客</strong>：<a href="http://akrzemi1.wordpress.com/">Andrzej&rsquo;s C++ blog Guidelines and thoughts about C++</a></li>
</ul>


<p>Andrzej Krzemieński，从名字看是波兰人，近期博客更新较快，表达清晰，行文流畅，内容难度不高，有C++11内容，是像我这样的初级并且语言控的C++程序员的福音。</p>

<br/>


<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/SumantTambe.jpg" width="120" height="150"></p>

<ul>
<li><strong>Sumant Tambe的博客</strong>： <a href="http://cpptruths.blogspot.com/">c++ truths</a></li>
</ul>


<p>Sumant Tambe，印度人，美国范德堡大学的计算机博士，技术涉猎广泛，同时也是著名的<a href="http://en.wikibooks.org/wiki/More_C++_Idioms">More C++ Idioms</a>创建者。博客一直更新，内容面向中高级C++程序员，最新文章涉及C++11的“高级Idioms”，比如13年10月的一篇文章主题是：创建递归的lambda表达式。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/JeffPreshing.jpg" width="120" height="150"></p>

<ul>
<li><strong>Jeff Preshing的博客</strong>: <a href="http://preshing.com/">Preshing on Programming</a></li>
</ul>


<p>Jeff Preshing，加拿大人，自称游戏行业开发10数年，C++功力自是深厚。博客每年更新十数篇，C++相关文章内容上进，直面工程上的难题：并发，而不是在C++本身上打转转。且行为流畅，图文并茂，深入浅出，是C++工程控的福音。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/Joaqu.jpg" width="120" height="150"></p>

<ul>
<li><strong>Joaquín M López Muñoz的博客</strong>: <a href="http://bannalia.blogspot.com/">Bannalia: trivial notes on themes diverse</a></li>
</ul>


<p>Joaquín M López Muñoz，西班牙人。Boost.MultiIndex的实现者。博客长期更新，内容偏向算法，文章中有大量的公式推演和曲线图表，估计大部分中国开发者对这种内容是不感冒的。计算机或数学系的研究生，并以后打算从事算法相关工作的，推荐阅读。从这个西班牙男人身上，也可以看到老牌欧洲资本主义国家，教育水平的强悍，尤其是基础学科。</p>

<ul>
<li><strong>Daniel Park的博客</strong>: <a href="http://functionalcpp.wordpress.com/">functionalcpp-Abusing the type system like never before</a></li>
</ul>


<p>Daniel Park，喜欢用昵称whanhee，身世不知。一个注重实干的C++狂热分子，正如其博客简介所说，不想接着讲那些被讲烂掉的函数式编程概念，要用C++来实现这些概念。博客是一个关于函数式编程概念如何用C++实现的一个系列文章，作者采用的是C++11乃至C++14的特性，所以对C++高级函数式实现思想感兴趣的不容错过。近期博客更新也较快的。</p>

<ul>
<li><strong>Agustín Bergé的博客</strong>: <a href="http://talesofcpp.fusionfenix.com/">talesofcpp</a></li>
</ul>


<p>Agustín Bergé，86年生阿根廷人，可能是这里面最年轻的，stackoverflow目前排名708。作者想用自己的博客探索永无边界的C++世界，尤其是那些前人未涉足的犄角旮旯，所以C++中毒颇深者可以看看。</p>

<ul>
<li><strong>Chris Kohlhoff的博客</strong>: <a href="http://blog.think-async.com/">Preshing on Programming</a></li>
</ul>


<p>Chris Kohlhoff，澳大利亚人，Boost.asoi作者。博客更新到10年，内容主要涉及网络，asio相关，使用asio的可以去看看。</p>

<h2>中文C++名博</h2>

<p><img class="pull-right" src="/images/posts/cpp-blogs/liuweipeng.jpg" width="120" height="150"></p>

<ul>
<li><strong>刘未鹏的博客</strong>：<a href="http://mindhacks.cn/">MindHacks-思维改变生活</a></li>
</ul>


<p>刘未鹏，84年生人，现就职于微软，<a href='http://www.amazon.cn/gp/product/B008A4Y2R0<em>Imperfect C++</em>B00114BFTO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008A4Y2R0<em>Imperfect C++</em>B00114BFTO&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Exceptional C++ Style</a>译者，大学时对C++有极大的学习兴趣，曾与C++之父邮件往来，记录在另一个博客<a href="http://blog.csdn.net/pongba/">C++的卢浮宫</a>上。据闻刘未鹏现忙于育儿与心理学，所以博客更新较慢，但以往博客含金量高，很值得一读。博客内容偏重于学习方法，纯技术的C++文章少些。</p>

<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/chenhao.jpg" width="120" height="150"></p>

<ul>
<li><strong>陈皓的博客</strong>：<a href="http://coolshell.cn/">酷壳-享受编程和技术所带来的快乐</a></li>
</ul>


<p>陈皓，不认为自己是牛人的牛人，现就职于阿里巴巴。<a href="http://coolshell.cn/articles/4990.html">程序员技术练级攻略</a>这篇博文足以奠定其江湖地位。陈皓自称有技术焦虑症，所以博客更新频繁，内容大量涉及C++及一切劝人上进的观点和方法，也有不少网友的高质量投稿，涉及软件开发的方方面面。</p>

<br/>


<br/>


<p><img class="pull-right" src="/images/posts/cpp-blogs/chenshuo.jpg" width="120" height="150"></p>

<ul>
<li><strong>陈硕的博客</strong>：<a href="http://blog.csdn.net/solstice/">陈硕的Blog</a></li>
</ul>


<p>陈硕，国内少有的C++工程功底深厚，作风严谨且乐于分享的人。Muduo开源库的作者，有干货著作<a href='http://www.amazon.cn/gp/product/B00AYS2KL0/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00AYS2KL0&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>Linux多线程服务端编程:使用muduo C++网络库</a>一本，译注若干。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++中的静态断言]]></title>
    <link href="http://towriting.com/blog/2013/12/10/static-assert/"/>
    <updated>2013-12-10T00:02:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/10/static-assert</id>
    <content type="html"><![CDATA[<h2>什么是静态断言</h2>

<p>断言（Assert)是报告代码状态错误的技术手段。Windows下的C++开发肯定都知道ASSERT或ATLASSERT，这两个宏生成DEBUG版本下的断言，另外还有assert，是C/C++提供的断言函数，效果和以上两个宏是一样的。</p>

<p>那什么是静态断言？上面介绍的普通断言是运行时检测的，静态断言是编译期检测的，所以被称之为静态断言（static assert）。最早知道编译期检测是在Matthew wilson的<a href="http://www.amazon.cn/gp/product/B008A4Y2R0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008A4Y2R0&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="" target="_blank">《Imperfect C++》</a>中，里面称其为约束（constraints)，并抱怨C++为什么不支持如此常用的功能（C++11已有改善）。</p>

<p>那使用静态断言有什么好处呢？</p>

<h2>静态断言的好处</h2>

<ol>
<li>更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</li>
<li>无法忽略的错误，对于Assert类似DEBUG下的断言，有时候被不会被执行到，即使执行到也会遭到一些开发的忽视，而静态断言的错误是无法忽视的，因为构建失败了。</li>
<li>减少运行时开销，静态断言是编译期检测的，减少了运行时开销</li>
</ol>


<p>那如何使用实现静态断言？</p>

<h2>使用静态断言</h2>

<p>静态断言作用的对象一般是编译时已知的状态。任何可以成为模板类参数的内容都可以作为静态断言的对象。</p>

<p>下面看一个静态断言的例子：
```cpp
template <typename D,typename B>
struct has_base
{</p>

<pre><code> ~has_base()
{
    void(*p)(D*,B*) = constraints;
}
</code></pre>

<p>private:</p>

<pre><code>static void constraints(D *pd,B *pb)
</code></pre>

<p>   {</p>

<pre><code>    pb = pd; 
</code></pre>

<p>   }
};
<code>
这个例子最早出自Bjarne Stroustrup之手，用于检测一个类型是否是另一个类型的父类（类型相等和void*的情况没有考虑，用起来像这样子：
</code>cpp
class CBase {};
class CDer: public CBase {};
has_base&lt;CDer, CBase> a;
has_base&lt;CBase, CDer> b; //编译错误
```
它的工作原理是，成员函数constraints试图把D的指针转化成B的指针，这一般只在B是D的派生类时成立。而且constraints函数永远不会被调到，所以没有运行时开销。</p>

<p>在看一个例子：
```cpp
enum personType
{</p>

<pre><code>person_child,
person_adult,
person_woman,
person_man,
person_count    
</code></pre>

<p>};</p>

<p>void ProcessPersonType(personType ptVal)
{
  char dummy[person_count > CHAR_MAX ? -1 : 1];
  char cVal = ptVal;
  // do something with cVal
}</p>

<p><code>``
上面例子里，试图将枚举类型的值转化成cVal,但可能有溢出的问题，所以设置一个静态断言：</code>char dummy[person_count > UCHAR_MAX ? 1 : -1];<code>，原理是如果personType的最大值大于char类型的最大值，则表达式为</code>char dummy[-1]`，我们知道这是编译不过的，所以会提示我们出问题了。</p>

<p>以上方式虽然可以实现静态断言的效果，但提示的信息，可能和我们断言想要报告的完全无关，所以并不是最完美的解决方案。</p>

<h2>C++11中的静态断言</h2>

<p>C++11中增加了static_assert支持静态断言，用法相当简单，static_asset接受两个参数，第一个为要断言的内容，第二个为显示的错误提示。
```cpp
template<int n>                               <br/>
struct Factorial                                  <br/>
{
 static_assert(n > 1, &ldquo;n must bigger than 1&rdquo;);<br/>
 enum{ value=n * Factorial&lt;n-1>::value }; <br/>
};</p>

<p>template&lt;>                                        <br/>
struct Factorial<0>                                  <br/>
{<br/>
 enum{ value=1 };<br/>
};<br/>
```
上面是计算阶乘的一个模板，我们使用static_assert检测n的值大于1，如果不满足则，编译错误，提示为："n must bigger than 1"。</p>

<p>static_assert是编译器很容易实现的一个特性，一般的编译器最新版本应该都已支持。</p>
]]></content>
  </entry>
  
</feed>
