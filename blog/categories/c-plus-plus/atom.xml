<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2013-11-10T23:43:56+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从Safe bool惯用法到explicit标识符]]></title>
    <link href="http://towriting.com/blog/2013/11/01/safe-bool-idiom/"/>
    <updated>2013-11-01T22:52:00+08:00</updated>
    <id>http://towriting.com/blog/2013/11/01/safe-bool-idiom</id>
    <content type="html"><![CDATA[<blockquote><p>C++是一个学语法都能让人入迷的奇葩语言，有各种的奇技淫巧。比如这里的许多的惯用法：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms">More C++ Idioms</a>，虽凝聚了C++程序员的聪明才智，但都是特定时期的产物，
相信都会被冲到C++语言演化长河的河滩上，仅供后人瞻仰（或者是C++本身）。让我们从Safe bool idiom说起。</p></blockquote>

<h2>Safe bool idiom</h2>

<p>什么是safe bool idiom？就是为自定义类型（class）提供检测真假的能力，而又不会带来副作用。</p>

<h3>为类(Class)提供检测真假的能力</h3>

<p>方法有二，第一种简单直白，提供一个返回bool类型的函数，比如下面的isValid成员函数：
<code>cpp
class CData
{
 public:
  bool IsValid() const;
};
int main()
{
  CData data;
  if (data.IsValid())
  {
   //dosomething
  }
}
</code>
这是直观而不易出错的。但多多少少有些强迫症的人会说，如果能像检测内置bool类型一样检测data对象不是更好的保证了代码的语法一致性？
<code>cpp
int main()
{
  CData data;
  if (data)
  {
   //dosomething
  }
}
</code>
同时他又急于向人们展示，"我会使用操作符重载哦“。于是第二种方法出来了，重载bool类型转化操作符：
<code>cpp
class CData
{
 public:
  operator bool() const;
};
int main()
{
  CData data;
  if (data)
  {
   //dosomething
  }
}
</code>
漂亮的外表后面的东西可能是有毒的，比如毒蘑菇、巫婆的毒苹果和传说中的红颜祸水们。软件开发也概莫能外，这个漂亮的解决方案后面有问题。</p>

<h3>bool操作符的副作用</h3>

<p>假使有一个简单的指针外敷类：
```cpp
template<typename T>
class CPtr
{
  T *ptr;
  public:
   operator bool() const
   {</p>

<pre><code>return ptr != nullptr;
</code></pre>

<p>   }
};</p>

<p>int main()
{
  CPtr<float> p1;
  CPtr<int>   p2;</p>

<p>  if (p1 == p2)
  {
   //天知道会怎样
   //something
  }</p>

<p>}</p>

<p>```
有人不小心拿两个不同类型的类对象来比较，不幸的是编译器并没有报错，因为17行隐式调用了operator==(bool,bool)，后面的结果真真天知道。
这可如何是好？C++社区里最不缺人才，很快有人想出解决方案：</p>

<h3>Safe bool实现</h3>

<p>Safe Bool正式的提出是这里：<a href="http://www.artima.com/cppsource/safebool.html">The Safe Bool Idiom</a>，方法就是写一个类型转化操作符，这个操作符返回一个可以进行 <strong>if</strong> 判断的特有类型：
```cpp
class Testable
{</p>

<pre><code>bool ok_;
typedef void (Testable::*bool_type)() const;
void this_type_does_not_support_comparisons() const {}
</code></pre>

<p>  public:</p>

<pre><code>explicit Testable(bool b=true):ok_(b) {}

operator bool_type() const {
  return ok_==true ? 
    &amp;Testable::this_type_does_not_support_comparisons : 0;
}
</code></pre>

<p>};</p>

<p>class TestableOther
{</p>

<pre><code>bool ok_;
typedef void (TestableOther::*bool_type)() const;
void this_type_does_not_support_comparisons() const {}
</code></pre>

<p>  public:</p>

<pre><code>explicit TestableOther(bool b=true):ok_(b) {}

operator bool_type() const {
  return ok_==true ? 
    &amp;Testable::this_type_does_not_support_comparisons : 0;
}
</code></pre>

<p>};</p>

<p>int main()
{
  Testable testable;
  TestableOther testableother;
  if (testable)
  {</p>

<pre><code>//something
</code></pre>

<p>  }
  if (testable == testableother) //编译错误
  {</p>

<p>  }</p>

<p>}</p>

<p>```
上面代码，利用的是bool_type是函数指针类型，所以可以进行 <strong>if</strong> 判断，且不同类的bool_type是不同的，直接比较会编译错误。
这就是safe bool Idiom，详细的代码可以参看这里：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/">More C++ Idioms/Safe bool</a>。
但我认为这个方案是顾此失彼，会引发新的问题，比如类中重载operator int操作符怎么办？</p>

<h2>C++11的做法</h2>

<p>C++11的基因支持safe bool，方法就是使用<a href="http://en.cppreference.com/w/cpp/language/explicit">explicit</a>修饰operator：
```cpp
struct Testable
{</p>

<pre><code>explicit operator bool() const {
      return false;
}
</code></pre>

<p>};</p>

<p>int main()
{
  Testable a, b;
  if (a)      { /<em>do something</em>/ }<br/>
  if (a == b) { /<em>do something</em>/ }  // 编译错误
}
```
<strong>explicit</strong> 在C++11以前是只能用于修饰构造函数，但在C++11中可以用来修饰操作符，上面代码中的operator bool（）加上<strong>explicit</strong>表式其无法隐式转化为bool。
这个解决方案，干净漂亮，无副作用。</p>

<h2>总结</h2>

<p>C++11前后的两种Safe Bool的解决方案比较，优劣立现。站在实用的角度上，C++11出现后，C++中好多“高端技术”已经不需要学习，比如StackOver上列出的这些：<a href="http://stackoverflow.com/questions/9299101/what-c-idioms-are-deprecated-in-c11">what C++ idioms are deprecated in C++11</a>。这些东西就像毛笔字一样，可以仅供专家与爱好者把玩了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++手爱德华]]></title>
    <link href="http://towriting.com/blog/2013/09/23/edward-chands/"/>
    <updated>2013-09-23T22:25:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/23/edward-chands</id>
    <content type="html"><![CDATA[<p><img class="pull-right" src="/images/posts/edward-chands/Edwardscissorhandsposter.png" title="" ></p>

<blockquote><p>我一直在寻找一种可以类比使用C++编程时心情的东西，直到我想起1900年Tim Burton的电影，剪刀手爱德华。</p></blockquote>

<p>在这部电影中，可怜的家伙（Johnny Depp)想温柔的拥抱Winona Ryder但是他笨拙的剪刀手对他们俩都会造成伤害。他的脸上留下了很多伤疤。</p>

<p>拥有一对剪刀手并不总是坏事。爱德华有许多才能，比如，它可以给狗剪除漂亮的发式。</p>

<p>当参加完一些C++会议后，我总会有一些想法，最近参加的是Going Native 2013。去年可喜的是大多会议围绕着闪亮的C++11最新标准。但今年更多的关于实际检查。不要误会，这里有太多的漂亮的小狗发式可以展现（我是说C++代码可以简洁优雅）但是会议的主题总是关于如何避免出错及出错后的补救。</p>

<h2>恐怖小窝</h2>

<p>这里有太多的关于<strong>C++禁忌</strong>的讲座使我意识到这可能不是初级程序员的问题，这明显是C++语言自身的错。所以你仅仅学习了语言的基本元素后就使用它，你会遍体鳞伤的。</p>

<p>C++对此有借口：向后兼容 &mdash; 特别是兼容C语言。你应该认为C作为C++的子集应该像人们不应该每天使用汇编一样，除非你是个汇编程序员。假如你对你的C++工具箱视而不见，你看到的总是裸指针、for循环等丑陋的东西。</p>

<p>一个人所共知的禁忌是不要使用malloc动态分配内存，不要使用free释放内存。malloc接受一个size并返回一个void*，你必须把它转换成其它有用的类型。很难实现一个比这更糟糕的内存分配API。这有一段真的很糟的代码（但一般是运行正确的，假如不可能出现空指针解引用的话）：
```cpp
struct Pod {</p>

<pre><code>int count;
int * counters;
</code></pre>

<p>};</p>

<p>int n = 10;
Pod * pod = (Pod <em>) malloc (sizeof Pod);
pod->count = n
pod->counters = (int </em>) malloc (n * sizeof(int));
&hellip;
free (pod->counters);
free (pod);
```
我希望人们不会写出这样的代码，但我确信现实世界的好多程序的代码中有这样的结构。</p>

<p>C++通过替换malloc和free为new和delete"解决"了多余的强转和易出错的size计算。正确的C++代码应该这样：
```cpp
struct Pod {</p>

<pre><code>int count;
int * counters;
</code></pre>

<p>};</p>

<p>int n = 10;
Pod * pod = new Pod;
pod->count = n;
pod->counters = new int [n];
&hellip;
delete [] pod->counters;
delete pod;
<code>
顺便说一下，空指针引用的问题同样被解决了，因为如果系统内存耗尽，new总是会抛出异常。但这里在第二个new的地方还是有几率发生内存泄漏，所以这是现实中正确的代码：
</code>cpp
class Snd { // Sophisticated New Data
public:</p>

<pre><code>Snd (int n) : _count(n), _counters(new int [n]) {}
~Snd () { delete [] _counters; }
</code></pre>

<p>private:</p>

<pre><code>int _count;
int * _counters;
</code></pre>

<p>};</p>

<p>Snd * snd = new Snd (10);
&hellip;
delete snd;
```
我们做完了吗？才没呢！这段代码不是异常安全的。</p>

<p>C++的基本准则是避免裸指针、避免数组、避免delete。所以医治malloc的良药new也是不应使用的，它会返回危险的指针。</p>

<p>我们都知道（满脸的伤疤可以证明）尽一切可能使用STL容器和智能指针。也应该按值传递参数。不，等一下。按值传递参数因为多余的拷贝会增加性能损耗。使用shared_ptr或shared_ptr的容器怎么样？但这会增加引用计数的滥用。这里有新的解决方案：移动语义和右值引用。</p>

<p>我能举出无数类似的例子。看到规律了没？一个问题的解决方案可能会引入新的问题。不仅C子集需要避免使用。每个新的语言特性或库组建都会带来新的缺陷。当你听完Scott Meyers讲过后，你会发现一个新的特性怎么设计的这么烂（猜一下Scott Meyers论证的最新的缺陷是什么？是移动语义）。</p>

<h2>C++的哲学</h2>

<p>Bjarne Stroustrup一直强调向后兼容对C++来说多么重要。它是C++哲学的根基。它是决定那些代码是合法的依据。然而兼容性给语言演化代理了极大的拖累。如果自然界和C++一样是向后兼容的，人们还会有尾巴、腮、脚蹼、触角 &mdash; 在进化的过程中它们都有过作用。</p>

<p>C++变成了极度复杂的语言。同一件事情有无数种实现方式，但大部分都走向错误、危险、难维护。问题是代码可以编译甚至运行。错误或者缺陷会在后来被发现，甚至是产品发布以后。</p>

<p>你可能会说这是编程语言的自然特性。如果你真这样想，那要好好看看Haskell了。你的第一反应是：用这种极度严苛的语言我不知怎样实现第一件事（阶乘、斐波那契等）。这完全不同于C++。你不会意识到，运气好的话，需要十年你才能发现C++的“真谛”。能否想到，越好的C++程序员，他的代码越具有“函数性”。请教任何一个C++大神，它会回答你：避免可变的（mutation)，避免边际效应，避免继承和派生。但是你将需要严厉的准则和可以控制你同事的能力，因为C++太宽容了。</p>

<p>Haskell一点也不宽容，它不会让你或者你的同事写出不安全的代码的。是的，一开始你可能因为想要用haskell实现C++几分钟可以完成的事情而抓狂。假如你走运，为Sean Parent<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>或类似严格的程序员共事，他将review你的代码，并指出你不要用C++编码了。或者你自己继续在黑暗的日子里，数着自己伤害自己的伤口个数。</p>

<h2>资源管理</h2>

<p>我以资源管理的例子开始这篇文章（严格说是内存管理），因为这是我的个人爱好。从90年代起我就开始写关于资源管理的东西和宣传它。不过失败的是20年后资源管理技术还是鲜为人知。Bjarne Stroustrup有责任花费一半的演讲时间给高级C++程序员讲解资源管理的知识。你也可能会责备初级程序员们没能领悟资源管理是C++编程的根基。但问题是语言并没有指出我一开始写的那段代码有什么纰漏。事实上学习正确的技术就好像学习新的语言。</p>

<p>为何如此艰难？因为C++中最重要的资源管理是内存管理。事实上需要反复强调的是垃圾收集解决不了资源管理的问题：这里有文件句柄，内核对象，打开的数据库等等。这都是重要的资源，但重要性被繁复的内存管理比下去了。为什么不支持垃圾收集，不是因为找不到一种高效的实现方式，因为C++是排斥垃圾收集的。编译器和运行时总要做最坏的打算：不仅一个指针可能是另一个的别名而且内存地址可以保存成整型甚至它的低字节用作位域（所以C++只考虑保守的垃圾收集）。</p>

<p>一个错误的常识是引用计数（shared pointer中使用）比垃圾收集更好。这有个<a href="http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf">研究</a>显示它们是异曲同工的。你应该知道delete一个shared pointer可能会引发任意时间的程序暂停，这和垃圾收集的性能损耗是一样的。这不仅仅是因为一个靠谱的引用计数算法必须处理好环（cycles），并且每次引用计数到0，对象可以达到的指针都需要遍历。用shared pointer创建的数据结构可能花费很长的时间去释放，除了极简单的情况，你无法知道什么时候shared指针要清零了。</p>

<p>在单线程环境下小心的资源管理和使用shared_ptr还是很好的防御方式。但多线程下，麻烦来了。每一次增加减少计数都需要加锁！锁一般由原子变量实现，而不是互斥量。别傻了：使用原子变量消耗很大，这带给我C++的最大问题。</p>

<h2>并发和并行（Concurrency and Parallelism）</h2>

<p>早在8年以前，herb Sutter就发表了著名的声明：<a href="http://www.gotw.ca/publications/concurrency-ddj.htm">免费的午餐结束了</a>！并发并不是发明在2005年。Posix线程1995年就定义了。微软在Windows95引入线程，在NT中支持了多处理器。然而并发是C++11中才有的知识。</p>

<p>C++11算是“白手起家”并发。它必须定义内存模型：多线程写内存时，什么时候和以什么顺序使其对其它线程可见。基于实用的考虑，C++的内存模型是从java中拷贝来的（去掉了一些有争议的数据竞争时的保证）。一句话就是，如果没有数据竞争C++程序是按次序的。</p>

<p>C++11定义了关于线程创建和管理的一些元素，这些同步元素都是被dijkstra和hoare在1960年定义的，比如互斥量（mutexes）和条件变量。有人可能会争辩这些是否是同步的好组件，但这没关系因为都知道他们不是可组装的（composable)。STM（Software Transactional Memory）是可组装的抽象，但这很难在命令式语言中高效及正确的实现。标准委员会有个STM学习小组，所以STM还是有机会成为标准的一部分的。但是因为C++对边界效应不做任何控制，所以它会很难正确应用的。</p>

<p>还有一些误导和混淆是尝试去提供基于任务的并行，使用的是async tasks和非组装的futures（慎重考虑后都会在C++14中不推荐使用）。线程局部变量的标准化也使基于任务的并发很难实现。锁和条件变量也是线程相关的，而不是任务相关的。未来几年标准委员会的当务之急就是这些了：基于任务的并行, communication通道代替futures , 任务取消, 可能还有longer term, data-driven 并行, 包括支持GPU。一个微软PPL和英特尔TBB的衍生可能会被加进标准库（希望不是微软的AMP）。</p>

<p>预测推断所有这些可以在2015年标准化和实现。假如预测成真，我还是不相信人们会用C++实现并行编程。C++是为单线程编程设计的，支持并行编程需要革命而不是改革。四个字：数据竞争，指令型语言没有对此提供保护，可能除了D语言。</p>

<p>在C++中，数据默认是线程共享的、默认是可变的；函数默认是有边界效应的。所有这些指针和引用为数据竞争提供了富饶的土壤。数据结构和函数在竞争上的先天不足使类型系统无法反射。在C++中，假如你有个对象的const引用，但不能保证另一个线程中不会修改它。更糟的是，一个const对象里面的引用默认是可变的。</p>

<p>D语言至少有深度const和不可变的概念（没有线程可以修改一个不可变的数据结构）。D语言朝着并发的另一个改良是可以定义纯函数（pure functions)。在D语言中，可变对象默认不是进程共享的。这是正确的方向，虽然增加了共享对象的运行开销。更重要的想法是，线程不是一个并发编程的好的抽象，所以这种改进在轻量级的任务序列中就不那么有效了。</p>

<p>但是C++对这些都不支持，并且看起来永远都支持不了。</p>

<p>当然，你可能认出了这些并发和并行的特征都是函数式语言具有的，特别是不可变和纯函数。别嫌我烦：Haskell是并发编程上执牛耳者，包括GPU编程。这是为什么我在布道C++技巧数载后轻易转向了haskell。每一个认真对待并发和并行的程序员都应该好好学习haskell看一下它是如何处理这一切的。这里有一本Simon Marlow写的不错的书：<a href="http://www.amazon.cn/gp/product/1449335942/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1449335942&linkCode=as2&tag=bringmeluck-23" rel="external nofollow" title="">Parallel and Concurrent Programming in Haskell</a>，读完它你或者开始在C++中使用函数式编程技术，或者认识到并发编程和指令式编程的分歧而转投Haskell。</p>

<h2>结论</h2>

<p>我认为C++语言和其哲学是和并发编程的需求冲突的。这种冲突导致并发编程在主流软件开发中缓慢前行。因为这过时的编程范式，微处理器、vector units和GPU的巨大能力被业界浪费了。</p>

<p>翻译自：<a href="http://bartoszmilewski.com/2013/09/19/edward-chands/">Edward C++Hands</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Adobe公司的首席科学家和移动数字图像组的架构师<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-常量表达式]]></title>
    <link href="http://towriting.com/blog/2013/09/17/constexpr/"/>
    <updated>2013-09-17T22:39:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/17/constexpr</id>
    <content type="html"><![CDATA[<p>C++11有一些这样的改善，这种改善保证写出的代码比以往任何时候的执行效率都要好。这种改善之一就是生成常量表达式，允许程序利用编译时的计算能力。假如你熟悉模板元编程，你将发现constexpr使这一切变得更加简单。假如你不知道模板元编程，也没什么。constexpr使我们很容易利用上编译时编程的优势。</p>

<p>常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时。需要计算一个编译时已知的常量，比如特定值的sine或cosin？确实你亦可以使用库函数sin或cos，但那样你必须花费运行时的开销。使用constexpr，你可以创建一个编译时的函数，它将为你计算出你需要的数值。用户的电脑将不需要做这些工作。</p>

<h3>constexpr初探</h3>

<p>为了使函数获取编译时计算的能力，你必须指定constexpr关键字到这个函数。</p>

<p>```cpp
constexpr int multiply (int x, int y)
{</p>

<pre><code>return x * y;
</code></pre>

<p>}</p>

<p>// 将在编译时计算
const int val = multiply( 10, 10 );
```
除了编译时计算的性能优化，constexpr的另外一个优势是，它允许函数被应用在以前调用宏的所有场合。例如，你想要一个计算数组size的函数，size是10的倍数。如果不用constexpr，你需要创建一个宏或者使用模板，因为你不能用函数的返回值去声明数组的大小。但是用constexpr，你就可以调用一个constexpr函数去声明一个数组。</p>

<p>```cpp
constexpr int getDefaultArraySize (int multiplier)
{</p>

<pre><code>return 10 * multiplier;
</code></pre>

<p>}</p>

<p>int my_array[ getDefaultArraySize( 3 ) ];
```</p>

<h2>constexpr函数的限制</h2>

<p>一个constexpr有一些必须遵循的严格要求：</p>

<ul>
<li>函数中只能有一个return语句（有极少特例）</li>
<li>只能调用其它constexpr函数</li>
<li>只能使用全局constexpr变量</li>
</ul>


<p>注意递归并不受限制。但只允许一个返回语句，那如何实现递归呢？可以使用三元运算符（?:)。例如，计算n的阶乘：
```cpp
constexpr int factorial (int n)
{</p>

<pre><code>return n &gt; 0 ? n * factorial( n - 1 ) : 1;
</code></pre>

<p>}
```
现在你可以使用factorial(2)，编译器将在编译时计算这个值，这种方式运行更巧妙的计算，与内联截然不同。你无法内联一个递归函数。</p>

<p><strong>constexpr函数还有那些特点？</strong></p>

<p>一个constexpr函数，只允许包含一行可执行代码。但允许包含typedefs、 using declaration &amp;&amp; directives、静态断言等。</p>

<h2>constexpr和运行时</h2>

<p>一个声明为constexpr的函数同样可以在运行时被调用，当这个函数的参数是非常量的：
<code>cpp
int n;
cin &gt;&gt; n;
factorial( n );
</code>
这意味着你不需要分别写运行时和编译时的函数。</p>

<h2>编译时使用对象</h2>

<p>假如你有一个Circle类：
```cpp
class Circle
{</p>

<pre><code>public:
Circle (int x, int y, int radius) : _x( x ), _y( y ), _radius( radius ) {}
double getArea () const
{
    return _radius * _radius * 3.1415926;
}
private:
    int _x;
    int _y;
    int _radius;
</code></pre>

<p>};
<code>
你希望在编译期构造一个Circle接着算出他的面积。
</code>cpp
constexpr Circle c( 0, 0, 10 );
constexpr double area = c.getArea();
<code>
事实证明你可以给Circle类做一些小的修改以完成这件事。首先，我们需要将构造函数声明为constexpr，接着我们需要将getarea函数声明为constexpr。将构造函数声明为constexpr则运行构造函数在编译期运行，只要这个构造函数的参数为常量，且构造函数仅仅包含成员变量的constexpr构造（所以默认构造可以看成constexpr，只要成员变量都有constexpr构造）。
</code>cpp
class Circle
{</p>

<pre><code>public:
constexpr Circle (int x, int y, int radius) : _x( x ), _y( y ), _radius( radius ) {}
constexpr double getArea () 
{
    return _radius * _radius * 3.1415926;
}
private:
    int _x;
    int _y;
    int _radius;
</code></pre>

<p>};
```</p>

<h2>constexpr vs const</h2>

<p>假如你将一个成员函数标记为constexpr，则顺带也将它标记为了const。如果你将一个变量标记为constexpr，则同样它是const的。但相反并不成立，一个const的变量或函数，并不是constexpr的。</p>

<h2>constexpr和浮点数</h2>

<p>到这里我们讲到的constexpr功能都可以通过模板元编程实现。但constexpr支持的一项能力是可以计算浮点型的数据。因为double和float不是有效的模板参数，你不可以轻易的通过模板编译期计算浮点数的值。而constexpr允许编译期计算浮点型数据。</p>

<h2>权衡constexpr</h2>

<p>C++开发者早就深受修改一个头文件则引发重新编译导致编译缓慢的困扰。而constexpr可能引入增加编译时间的风险，但也有一些技术去降低这种风险。首先，因为constexpr函数相同的参数会输出相同的结果，所以它们可以被<a href="http://en.wikipedia.org/wiki/Memoization">memoized</a>，事实上GCC已经支持memoization。</p>

<p>因为可以对constexpr函数memoize,所以用constexpr函数替换模板函数的地方，(编译）性能不会变得更坏，但代码会变得清晰。事实上，替换掉一部分模板实例，编译会显著加快。</p>

<p>最后，标准允许编译器去限制递归函数的级数。这样可以限制深度递归的编译性能损耗。</p>

<h2>编译器支持</h2>

<p>constexpr需要编译器支持编译期的递归，所以也不奇怪支持constexpr的编译器并不多，就我所知只有G++4.7支持这一特性。[注：到我翻译时，intelC++13、Clang3.1也都支持了，不过Vs2013还是不支持]</p>

<p>下一篇：右值引用和移动语义</p>

<p>上一篇：<a href="/blog/2013/08/20/ranged-for-loop/">区间迭代</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-compile-time-processing-with-constexpr.html">Constexpr &ndash; Generalized Constant Expressions in C++11</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[熟悉的陌生人-this指针(1)]]></title>
    <link href="http://towriting.com/blog/2013/09/01/this-pointer/"/>
    <updated>2013-09-01T00:22:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/01/this-pointer</id>
    <content type="html"><![CDATA[<p>this指针想必每个C++程序员都是再熟悉不过的了，我们每天的编程工作都会用到它，我们以为它是最忠实的朋友，不会给我们惹麻烦，但其实它可能不是你想象的样子！</p>

<h2>this指针的偏移 &ndash; 某次强制转化引发的血案</h2>

<p>这是一个真实的案例，发生在12年6月份，让我用简单的例子还原一下现场。假设有一组派生关系的类CBrid继承于CAnimal，我们构造一个CBrid对象并赋值到CAnimal指针，然后由于某些原因需要把这个基类CAnimal指针强制转化成void*(真实情况是Windows下的LPARAM），然后再强制转化回CBrid指针：
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>例1</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CAnimal</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'><span class="n">CAnimal</span><span class="p">(){}</span>
</span><span class='line'><span class="o">~</span><span class="n">CAnimal</span><span class="p">(){}</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'><span class="n">string</span> <span class="n">m_strName</span><span class="p">;</span> <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">CBird</span><span class="o">:</span> <span class="k">public</span> <span class="n">CAnimal</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'><span class="n">CBird</span><span class="p">()</span><span class="o">:</span> <span class="n">m_bCanFly</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">m_strName</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Bird</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">~</span><span class="n">CBird</span><span class="p">(){}</span>
</span><span class='line'><span class="k">virtual</span> <span class="kt">void</span> <span class="n">Fly</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">cout</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="nl">type:</span> <span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">m_strName</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">cout</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">is</span> <span class="nl">fly:</span> <span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">m_bCanFly</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">m_bCanFly</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//主函数</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="n">CAnimal</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pAnimal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CBird</span><span class="p">;</span>
</span><span class='line'> <span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pCmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">pAnimal</span><span class="p">;</span>
</span><span class='line'> <span class="c1">//一些操作</span>
</span><span class='line'> <span class="n">CBird</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pBird</span> <span class="o">=</span> <span class="p">(</span><span class="n">CBird</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">pCmd</span><span class="p">;</span><span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'> <span class="k">if</span> <span class="p">(</span><span class="n">pBird</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>   <span class="n">pBird</span><span class="o">-&gt;</span><span class="n">Fly</span><span class="p">();</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
上面代码36行，pBrid要飞，但没飞起来，在我的开发环境下，程序挂在了这一行。那天是一个刚毕业很聪明的小伙子发现的这个问题，他还尝试过这样调用：
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>例2</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">CAnimal</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pAnimal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CMammal</span><span class="p">;</span>
</span><span class='line'><span class="n">CBird</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pBird</span> <span class="o">=</span> <span class="p">(</span><span class="n">CBird</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">pAnimal</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="n">pBird</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">pBird</span><span class="o">-&gt;</span><span class="n">Fly</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
这样调用确是没有问题的，和第一个例子唯一的差别就是没有中间的Void*转化。
记得当时是我们周会的时间，于是拿出来和大家讨论，惭愧的是我们十几个人，竟然没人能说出其中原因，要知道我们中也有三个工作5年左右的同事。后来我打开调试器，跟踪了一下这两段代码的汇编代码，终于发现了蛛丝马迹：
<code>c
CBird* pBird = (CBird*)pAnimal;
cmp         dword ptr [pAnimal],0  
je          main+1C1h (33F681h)  
mov         eax,dword ptr [pAnimal]  
sub         eax,4  
mov         dword ptr [ebp-178h],eax  
jmp         main+1CBh (33F68Bh)  
mov         dword ptr [ebp-178h],0  
mov         ecx,dword ptr [ebp-178h]  
mov         dword ptr [pBird],ecx  
</code>
猫腻就在第5行，编译器先取基类指针pAnimal的值然后减了4，赋值给了派生类指针pBird，看到这里我才隐隐约约感觉是虚表的问题，CBird有一个虚函数，而基类CAnimal没有。当时我还没看《深度探索C++对象模型》，相信看过这本书的人一眼就能看出端倪，接着我验证一下我的猜想：
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>例3</span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">lass</span> <span class="n">CAnimal</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'><span class="n">CAnimal</span><span class="p">(){}</span>
</span><span class='line'><span class="o">~</span><span class="n">CAnimal</span><span class="p">(){}</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'><span class="n">string</span> <span class="n">m_strName</span><span class="p">;</span> <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">CMammal</span><span class="o">:</span> <span class="k">public</span> <span class="n">CAnimal</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'><span class="n">CMammal</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">m_strName</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Mammal</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">IsEatMeat</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">cout</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="nl">type:</span> <span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">m_strName</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="n">cout</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">is</span> <span class="n">eat</span> <span class="nl">meat:</span> <span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">m_bEatMeat</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">m_bEatMeat</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'> <span class="n">CAnimal</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pAnimal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CMammal</span><span class="p">;</span>
</span><span class='line'> <span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pCmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">pAnimal</span><span class="p">;</span>
</span><span class='line'> <span class="n">CMammal</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">pMammal</span> <span class="o">=</span> <span class="p">(</span><span class="n">CMammal</span><span class="o">*</span><span class="p">)</span><span class="n">pCmd</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="k">if</span> <span class="p">(</span><span class="n">pMammal</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>  <span class="n">pMammal</span><span class="o">-&gt;</span><span class="n">IsEatMeat</span><span class="p">();</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
上面的代码运行正常，和例1的区别就是CMamal没有虚函数，而CBrid有。所以说，<strong>沿着继承链类型转化时，this指针可能会发生偏移，以确保this指针总能指向subobject</strong>。而强转中如果中间有void*这种没有类型信息的东西，会使编译器丢失这种偏移。</p>

<p><strong>this指针说白了就是对象基址，角色是成员变量寻址基址，偏移的目的是为了使成员变量寻址正确</strong>，影响对像内存布局的东西都可能使this指针偏移（具体编译器可能不同）：</p>

<ol>
<li>虚表，子类有而派生类没有</li>
<li>多重继承，子类与第n(n>1)个派生类</li>
<li>虚继承</li>
</ol>


<p>待续：this指针的偏移策略</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[const 二三事]]></title>
    <link href="http://towriting.com/blog/2013/08/21/things-of-const/"/>
    <updated>2013-08-21T23:36:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/21/things-of-const</id>
    <content type="html"><![CDATA[<p>相信任何一个C++程序员都听说并使用过const。const在最初的C语言中是没有的，后来Bjarne Stroustrup和Dennis Ritchie讨论提出了Readonly机制，最初的Readonly机制简单的就是想利用操作系统的能力，提供一种可以使变量是只读的能力。Readonly通过被加进C语言的决议，并命名为const，但可能是标准委员会的官僚导致这项决议迟迟没有执行。后来Bjarne Stroustrup就自己把const加入进C++中（当时还不叫C++），并逐渐演变成现在的样子。</p>

<p>窃以为尽一切可能的使用const是任何一个合格的C++程序员应该遵守的事情，就像开车要系安全带一样。但好像人们并不喜欢用const，在我有限的C++编程生涯中，我接触到的有意识的会尽量用const的，除了我好像只有一人。不喜欢用const的结果同样可能会和开车不系安全带是一样的，希望你不会出事！</p>

<h2>const的作用</h2>

<ul>
<li>避免魔数</li>
</ul>


<p><code>cpp
const int max_path = 260;
char [max_path];
</code>
使用自解释的变量名声明const变量，代替魔数，会增加代码的可维护性，勿以善小而不为呀！</p>

<ul>
<li><p>内存优化 对于POD类型的变量，const往往能将其优化到只读内存存储</p></li>
<li><p>降低API的复杂度</p></li>
</ul>


<p>比如有下面这样一个类
```cpp
class Array
{
  public:</p>

<pre><code>int getCount() const;
</code></pre>

<p>  private:</p>

<pre><code>//etc
</code></pre>

<p>};
```
将成员函数getCount指定为const（const不能修饰非成员函数和static成员函数），可以使调用它的客户端代码相信Array的对象是没有变化的，函数的调用不会产生副作用。</p>

<p>或者：
```cpp
int getMaxValue(const std::vector<int>&amp; srcVec);</p>

<p>void fun()
{</p>

<pre><code>std::vector&lt;int&gt; vec;
vec.push_back(1);
vec.push_back(2);
vec.push_back(3);

int maxVal = getMaxValue(vec);    

//继续使用vec
auto size = vec.size();
</code></pre>

<p>}
```
参数使用const修饰，可以逻辑上保证参数不会被调用的函数修改，一样是降低复杂度</p>

<ul>
<li>防止错误的发生</li>
</ul>


<p>看下面的例子：
```cpp
int getMaxVal()
{</p>

<pre><code>const int maxVal = getMaxVal();
int maxCacheVal = 0;
if (NeedFetchCache())
{
    //etc
    maxVal = getCacheMaxVal();//拼写错误，本来该是maxCacheVal
}

return max(maxCacheVal, maxVal);
</code></pre>

<p>}
```</p>

<p>如果不用const，例子里拼写错误导致的bug只能留待自测、QA或用户来发现了，如果maxVal是const，那编译器不会让你通过的，这样const帮助我们将这种错误绞杀于萌芽。</p>

<h2>两种const</h2>

<ul>
<li>物理const</li>
</ul>


<p>物理const是Bjarne Stroustrup最初想要实现的Readonly。目的是把POD类型的变量存储进只读存储区，比如：
<code>cpp
 const int i = 200;
</code>
i将被优化进只读内存，效果相当于C语言中的宏。</p>

<ul>
<li>逻辑const</li>
</ul>


<p>逻辑const，一般修饰成员函数，表明调用函数不用引起对象逻辑上的变化：
```cpp
class Array
{
  public:</p>

<pre><code>size_t size() const
{
    ++m_calledCount;//无法修改
    return m_size;    
}
</code></pre>

<p>  private:</p>

<pre><code>size_t m_size;
int m_calledCount;
</code></pre>

<p>};
```
上面例子中的size()函数修饰为const，则表明调用它的过程中，对象一般是不能变化的，所以无法改变成员变量的值。</p>

<p>逻辑const也指修饰非POD类型的变量，主要帮助编译器做语法检测：
<code>cpp
const std::string str1 = "towriting.com";
auto size = str1.size();
str1.push_back("!"); //无法调用非const成员函数
</code>
const的对象只能调用const版的成员函数。例子中的str1调用了非const函数push_back会引起编译错误，因为const对象不应该改变对象的“值"。</p>

<h2>鲜为人知的特性</h2>

<ul>
<li>内部链接</li>
</ul>


<p>大家知道全局变量的定义必须是唯一的，但const修饰的变量具有内部链接的属性，比如有两个编译单元文件test_const_one.cpp和test_const_ohter.cpp分别定义了全局变量g_var：
```cpp
//test_const_one.cpp</p>

<p>const int g_var = 1;
int main()
{
  //something
}</p>

<p>//test_const_other.cpp
const int g_var = 2;
int testconst
{
  //something
}</p>

<p><code>
但编译是没有问题的，因为g_var只在本编译单元可见
</code>cpp
towriting.com@debian:~/workspace/snippets/cpp$g++ test_const_one.cpp test_const_other.cpp
```</p>

<ul>
<li>影响虚函数的覆盖</li>
</ul>


<p>比如有两个类，CSuperButton继承CButton，并且子类“重写”了基类的GetWidth()函数：
```cpp
class CButton
{
  public:
   virtual int GetWidth() const {return 100;}
};</p>

<p>class CSuperButton: public CButton
{
  public:
   virtual int GetWidth() {return 0;}
};</p>

<p>int main()
{
  CButton *pBtn = new CSuperButton();
  std::cout&lt;&lt;pBtn->GetWidth()&lt;&lt;std::endl;
  return 0;
}
```</p>

<p>如果这是一道面试题，问输出的结果是多少时，我相性不少人会答错。不卖关子，结果是100，因为子类的GetWidth没有用const修饰而基类使用了const，所以无法覆盖。</p>

<ul>
<li>影响函数的重载</li>
</ul>


<p>影响函数的重载有两种，一种是通过const修饰成员函数，比如：</p>

<p><code>cpp
class CIntArray
{
public:
  int&amp; At(int index);
  const int&amp; At(int index) const;
};
</code>
CIntArray原本提供了一个非const的At函数用于获取内容，并且可以通过引用的返回值修改对象。但同时也要提供一个const版的At供const对象使用（如果返回成员变量，返回值也要用const）。</p>

<p>另一种影响重载的是，通过修饰参数，比如：
<code>cpp
void doSomething(int i);
void doSomething(const int&amp; i);
</code></p>

<ul>
<li>&ldquo;浅"const</li>
</ul>


<p>我们前面讲了成员const函数无法修改成员变量，但指针的成员变量为什么好像会被修改？
```cpp
class CObj
{
public:
  void doSomething() const
  {</p>

<pre><code> *m_pointer = 1;
</code></pre>

<p>  }
private:
  int *m_pointer;
};
```
上面的代码编译是没有问题的，const的成员函数doSomething好像"修改"了成员变量的值。指针的成员变量有什么特殊的吗，为什么可以这样？原因很简单，doSomething并没有修改m_pointer的值，m_pointer是指针，只是修改了指针指向的内容而已。</p>
]]></content>
  </entry>
  
</feed>
