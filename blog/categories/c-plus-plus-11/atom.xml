<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++11 | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/c-plus-plus-11/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2013-08-11T12:25:03+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++11系列-改进的类型推导：auto、decltype和新的函数语法]]></title>
    <link href="http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11/"/>
    <updated>2013-08-08T00:18:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/08/improved-type-inference-in-cpp11</id>
    <content type="html"><![CDATA[<p>C++11引入了一些新的实用的类型推导能力，这意味着你可以花费更少的时间去写那些编译器已经知道的东西。当然有些时候你需要帮助编译器或者你的编程伙伴。但是C++11，你可以在一些乏味的东西上花更少的时间，而多去关注逻辑本身。</p>

<h2>auto之乐</h2>

<p>我们先快速回顾一下auto，万一你没有读<a href="/blog/2013/08/01/what-is-cpp11/">第一篇C++11文章</a>中关于auto的部分。在C++11中，如果编译器在定义一个变量的时候可以推断出变量的类型，不用写变量的类型，你只需写auto即可。
<code>cpp
int x = 4;
</code>
现在可以这样写：
<code>cpp
auto x = 4;
</code>
这当然不是auto预期的用途！它会在模板和迭代器的配合使用中闪耀光芒：
<code>cpp
vector&lt;int&gt; vec;
auto itr = vec.iterator();
</code>
其它时候auto也会非常有用。比如，你有一些下面格式的代码：
```cpp
template <typename BuiltType, typename Builder>
void
makeAndProcessObject (const Builder&amp; builder)
{</p>

<pre><code>BuiltType val = builder.makeObject();
// do stuff with val
</code></pre>

<p>}
<code>
上面的代码，我们看到这里需要两个模板参数：一个是Builder对象的类型，另一个是Builder创建出的对象的类型。糟糕的是创建出的类型无法被推导出，所以每次你必须这样调用：
</code>cpp
MyObjBuilder builder;
makeAndProcessObject<MyObj>( builder );
<code>
但是auto立即将丑陋的代码一扫无余，当Builder创建对象时不用写特殊代码了，你可以让C++帮你做：
</code>cpp
template <typename Builder>
void
makeAndProcessObject (const Builder&amp; builder)
{</p>

<pre><code>auto val = builder.makeObject();
// do stuff with val
</code></pre>

<p>}
<code>
现在你仅需一个模板参数，而且这个参数可以在函数调用的时候轻松推导：
</code>cpp
MyObjBuilder builder;
makeAndProcessObject( builder );
```
这样更易调用了，并且没丢失可读性，却更清晰了。</p>

<h2>decltype和新的返回值语法</h2>

<p>现在你可能会说auto就这样吗，假如我想返回Builder创建的对象怎么办？我还是需要提供一个模板参数作为返回值的类型。好！这充分证明了标准委员有一群聪明的家伙，对这个问题他们早想好了一个完美的解决方案。这个方案由两部分组成：decltype和新的返回值语法。</p>

<h3>新的返回值语法</h3>

<p>让我们讲一下新的返回值语法，这个语法还能看到auto的另一个用处。在以前版本的C和C++中，返回值的类型必须写在函数的前面：
<code>cpp
int multiply(int x, int y);
</code>
在C++11中，你可以把返回类型放在函数声明的后面，用auto代替前面的返回类型，像这样：
<code>cpp
auto multiply(int x, int y) -&gt; int;
</code>
但是为什么我要这样用？让我们看一个证明这个语法好处的例子。一个包含枚举的类：
```cpp
class Person
{
public:</p>

<pre><code>enum PersonType { ADULT, CHILD, SENIOR };
void setPersonType (PersonType person_type);
PersonType getPersonType ();
</code></pre>

<p>private:</p>

<pre><code>PersonType _person_type;
</code></pre>

<p>};
<code>
我们写了一个简单的类，里面有一个类型PersonType表明Person是小孩、成人和老人。不做特殊考虑，我们定义这些成员方法时会发生什么？
第一个设置方法，很简单，你可以使用枚举类型PersonType而不会有错误：
</code>cpp
void Person::setPersonType (PersonType person_type)
{</p>

<pre><code>_person_type = person_type;
</code></pre>

<p>}
<code>
而第二个方法却是一团糟。简单的代码却编译不过：
</code>cpp
// 编译器不知道PersonType是什么，因为PersonType会在Person类之外使用
PersonType Person::getPersonType ()
{</p>

<pre><code>return _person_type;
</code></pre>

<p>}
<code>
你必须要这样写，才能使返回值正常工作
</code>cpp
Person::PersonType Person::getPersonType ()
{</p>

<pre><code>return _person_type;
</code></pre>

<p>}
```
这可能不算大问题，不过会容易出错，尤其是牵连进模板的时候。</p>

<p>这就是新的返回值语法引进的原因。因为函数的返回值出现在函数的最后，而不是前面，你不需要补全类作用域。当编译器解析到返回值的时候，它已经知道返回值属于Person类，所以它也知道PersonType是什么。
```cpp
auto Person::getPersonType () &ndash;> PersonType
{</p>

<pre><code>return _person_type;
</code></pre>

<p>}
```
好，这确实不错，但它真的能帮助我们什么吗？我们还不能使用新的返回值语法去解决我们之前的问题，我们能吗？不能，让我们介绍新的概念：decltype。</p>

<h2>decltype</h2>

<p>decltype是auto的反面兄弟。auto让你声明了一个指定类型的变量，decltype让你从一个变量（或表达式）中得到类型。我说的是什么？
<code>cpp
int x = 3;
decltype(x) y = x; // 相当于 auto y = x;
</code>
可以对基本上任何类型使用decltype，包括函数的返回值。嗯，听起来像个熟悉的问题，假如我们这样写：
<code>cpp
decltype( builder.makeObject() )
</code>
我们将得到makeObject的返回值类型，这能让我们指定makeAndProcessObject的返回类型。我们可以整合进新的返回值语法：
```cpp
template <typename Builder>
auto
makeAndProcessObject (const Builder&amp; builder) &ndash;> decltype( builder.makeObject() )
{</p>

<pre><code>auto val = builder.makeObject();
// do stuff with val
return val;
</code></pre>

<p>}
```
这仅适用于新的返回值语法，因为旧的语法下，我们在声明函数返回值的时候无法引用函数参数，而新语法，所有的参数都是可访问的。</p>

<h2>auto：引用、指针和常量</h2>

<p>下面要确定的一个问题是auto如何处理引用：
```cpp
int&amp; foo();</p>

<p>auto bar = foo(); // int&amp; or int?
<code>
答案是在C++11中，auto处理引用时默认是值类型，所以下面的代码bar是int。不过你可以指定&amp;作为修饰符强制它作为引用：
</code>cpp
int&amp; foo();</p>

<p>auto bar = foo(); // int
auto&amp; baz = foo(); // int&amp;
<code>
不过，假如你有一个指针auto则自动获取指针类型：
</code>cpp
int* foo();</p>

<p>auto p_bar = foo(); // int<em>
<code>
但是你也可以显式指定表明变量是一个指针：
</code>cpp
int</em> foo();
auto <em>p_baz = foo(); // int</em>
<code>
当处理引用时，你一样可以标记const，如果需要的话：
</code>cpp
int&amp; foo();</p>

<p>const auto&amp; baz = foo(); // const int&amp;
<code>
或者指针：
</code>cpp
int<em> foo();
const int</em> const_foo();
const auto<em> p_bar = foo(); // const int</em>
auto p_bar = const_foo(); // const int*
```
所有这些都很自然，并且这遵循C++模板中类型推导的规则。</p>

<p>下一篇：Lambda表达式简明教程</p>

<p>上一篇：<a href="/blog/2013/08/01/what-is-cpp11/">什么是C++11</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html">C++11 &ndash; Auto, Decltype and return values after functions &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-什么是C++11]]></title>
    <link href="http://towriting.com/blog/2013/08/01/what-is-cpp11/"/>
    <updated>2013-08-01T20:32:00+08:00</updated>
    <id>http://towriting.com/blog/2013/08/01/what-is-cpp11</id>
    <content type="html"><![CDATA[<h2>什么是C++0x?</h2>

<p>C++0x是C++最新标准标准化过程中的曾用名，在这一系列文章中我们将介绍最新标准添加的一系列新的语言特性。在2011年9月份，C++0x正式由官方发布并命名C++11，现在很多编译器已经支持了部分C++11特性。</p>

<p>C++11包括大量的新特性：主要特征像<a href="http://en.cppreference.com/w/cpp/language/lambda">lambda</a>表达式和移动语义，实用的类型推导关键字auto，更简单的容器遍历方法，和大量使模板更容易使用的改进。这一系列教程将包含所以以上特性。</p>

<h2>你该关注C++11吗？</h2>

<p>很明显，C++11为C++带来了大量的新特性。C++11将修复大量缺陷和降低代码拖沓，比如lambda表达式的支持将使代码更简洁。像移动语义这种特性会提高语言内核的基础效率，使你可以写出更快的代码。对模板系统的优化可以使你更容易写出泛型的代码。</p>

<p>新的标准库同时也会包含新的特性，包括对多线程的支持和优化智能指针，后者将给那些还没用类似于<a href="http://www.boost.org/doc/libs/1_46_1/libs/smart_ptr/shared_ptr.htm">boost::shared_ptr</a>的人提供更简单的内存管理方法。</p>

<p>我已经开始使用新的C++11特性，并且非常喜欢：新的auto关键字，对模板">>&ldquo;写法的支持，lambda表达式和新的函数定义语法。</p>

<h2>C++11是如何开发出来的？</h2>

<p>C++11的出现，首先要感谢C++标准委员会的辛勤工作，一群来自学术界和工业界的专家，他们的多次会晤攻克难题，终于设计出了一种跨平台，被多种编译器支持，可以生成高效易维护代码的语言。而C++11新标准，就像对灵活强大的C++的一次不可思议的扩展。</p>

<h2>C++11包括什么？</h2>

<h4>更易用的语言</h4>

<p>使用过C++11后，我发现它提供了大量的基础方法使C++变成了一种更易使用的语言。这不是说它变成了简单的语言&mdash;这里有大量的新特性&mdash;提供了大量的方法使编程更容易。让我们看一个例子，auto关键字。在C++11中，假如编译器可以从变量的初始化中得到它的类型，那么你不必要指定类型。比如，你可以这样写：
<code>cpp
int x = 3;
auto y = x;
</code>
编译器可以推导出y的类型是int。当然，这不是一个证明auto有用的一个闪亮的例子。当使用模板特别是STL时auto很好用。为什么这么说，想象使用一个迭代器(iterator):
<code>cpp
map&lt;string, string&gt; address_book;
address_book["Alex"] = "webmaster@towriting.com";
//add a bunch of people to address_book
</code>
现在你想遍历address_book中的元素，要这样做，你需要一个迭代器：
<code>cpp
map&lt;string, string&gt;::iterator iter = address_book.begin();
</code>
这是一个恐怖的长类型声明，当你已经知道这个类型的时候。这样是不是简洁多了：
<code>cpp
auto iter = address_book.begin();
</code>
代码变得更简单明了，我觉得可读性也更高了，因为模板语法使这一行其它内容变模糊了。这是我特别喜欢的一个特性，我发现它消除了许多头疼和难以追踪的编译错误，节省了时间而没有丢掉表达式的意思。</p>

<h4>区间迭代（range-based for loop)</h4>

<p>下面迭代器的例子是C++11提供的一种处理迭代的更好方法，有些人叫做区间迭代（基本上所有的现代语言都支持）。这个例子足够证明这种语法是多么优雅：
```cpp
vector<int> vec;
vec.push_back(10);
vec.push_back(20);</p>

<p>for (int &amp;i: vec)
{</p>

<pre><code>cout&lt;&lt;i;
</code></pre>

<p>}
<code>
你需要做的就是给出一个变量和要迭代的区间。但是如果你想迭代一个map怎么办？你怎么设置map中值的类型？你知道vector值的类型是int。但map的值类型是pair，通过.first和.second给你提供键和值。但是用auto，你根本无需关心确切类型，你可以简单的写成：
</code>cpp
for (auto address_entry: address_book)
{</p>

<pre><code>cout&lt;&lt;address_entry.first&lt;&lt;" "&lt;address_entry.second&lt;&lt;endl;
</code></pre>

<p>}
<code>
这将打印出：
</code>bash
Alex <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#119;&#x65;&#98;&#x6d;&#x61;&#115;&#116;&#101;&#114;&#x40;&#116;&#x6f;&#119;&#x72;&#x69;&#x74;&#105;&#110;&#103;&#46;&#99;&#x6f;&#109;">&#x77;&#x65;&#98;&#x6d;&#97;&#x73;&#116;&#101;&#x72;&#x40;&#116;&#x6f;&#x77;&#114;&#x69;&#x74;&#105;&#110;&#x67;&#x2e;&#99;&#111;&#x6d;</a>
```
这是一个不错的C++11新特性组合用法吧？</p>

<h4>>>(right angle brackets)</h4>

<p>我这里还有更易用的优化&mdash;在以前的C++标准中，假如你写一个含有其他模板类型的模板：
<code>cpp
vector&lt;vector&lt;int&gt; &gt; vector_of_int_vectors;
</code>
你必须在结束的两个'>&lsquo;之间添加空格。这不仅烦人，而且当你写成>>而没有空格时，你将得到困惑和误导的编译错误信息。产生这种行为的原因是C++词法分析的最大匹配原则（<a href="http://en.wikipedia.org/wiki/Maximal_munch">maximal munch rule</a>)。一个好消息是从今往后，你再也不用担心了：
<code>cpp
vector&lt;vector&lt;int&gt;&gt; vector_of_int_vectors;
</code>
对，这确实是个小东西，不过却是人工代码克服机器工具的胜利。另外，这样写就不那么丑了。</p>

<h4>多线程</h4>

<p>这是第一次，C++11将包含一种内存模型和对应的多线程库，这意味着你将可以编写符合标准的多线程代码。新标准将提供所有的通用线程方法，比如线程、线程局部存储和原子操作。它也提供了一系列有趣的特性：futures和promises。futures和promises的主要思想是，你可以编写代码表示，“这个对象，一个future代码还没计算完的结果"，它将可以在后台计算结果。当这个值需要的时候，你向future发请求，假如这个值准备好了，那就可以得到它，要不然继续等待。</p>

<p>我将在后续的文章中深入探讨多线程。</p>

<h4>还有好多其他的东西</h4>

<p>C++11特性的数量是客观的。你可以阅读维基百科里的<a href="http://en.wikipedia.org/wiki/C%2B%2B0x">C++11</a>页面，而我计划在这一系列文章中深入探索这些特性，包括：</p>

<ul>
<li><a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></li>
<li>Lambda表达式</li>
<li>区间迭代</li>
<li>静态表达式</li>
<li>右值引用和移动语义</li>
<li>nullptr和强类型的枚举</li>
</ul>


<h3>C++11的编译器支持</h3>

<p>当然，如果无法使用再好的语言特性又有什么用，好消息是大量的编译器已经开始支持C++11。Apache基金会整理了一个列表，列出了C++11的语言特性和编译器的支持情况：<a href="http://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport">支持C++11的编译器</a>。假如你对GCC感兴趣，这里有<a href="http://gcc.gnu.org/gcc-4.7/cxx0x_status.html">GCC4.7支持C++11</a>。</p>

<p>有些编译器，比如GCC，不会默认支持这些新特性&mdash;例如，为了支持C++11特性，编译时必须指定 -std=c++0x。当然这也是很有用的，你可以在你的项目中选择编译器和语言集。</p>

<p>下一篇：<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/what-is-c++0x.html">What is C++0x? &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
</feed>
