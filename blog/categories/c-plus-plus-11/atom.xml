<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++11 | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/c-plus-plus-11/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2015-10-27T00:15:51+00:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Boost.Lambda与C++11.Lambda的用法对比]]></title>
    <link href="http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda/"/>
    <updated>2013-12-13T22:38:00+00:00</updated>
    <id>http://towriting.com/blog/2013/12/13/boost-lambda-vs-stand-lambda</id>
    <content type="html"><![CDATA[<p>我们知道C++11已经支持了Lambda表达式，大部分新的编译器都已支持Lambda。但boost里面的Lambda还是有存在的必要，因为并不是每个人都有选择自己编译环境的权利。</p>

<p>让我们通过几个例子对比C++11.Lambda来学习一下boost.Lambda的用法，详细的C++11.Lambda用法可以看这里：<a href="/blog/2013/08/11/lambda-closures/">C++11系列-Lambda表达式</a></p>

<h3>1.a boost.Lambda：构造一个functor</h3>

<p>boost.Lambda的使用是基于placeholder: <code>boost::Lambda::_1</code>,<code>boost::Lambda::_2</code>,<code>boost::Lambda::_3</code>可以理解为Lambda表达式的第一、第二、第三个参数。Lambda的出现利索地解决了STL算法库函数的使用不便。让我们首先看一个最简单的boost.Lambda与std::for_each结合的例子:</p>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin values in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;&ldquo;,&rdquo;);
std::cout&lt;&lt;std::endl;
```</p>

<p>上面的例子，使用std::for_each遍历vector中的元素并打印内容。boost::Lambda::_1这个占位符表示for_each遍历时传进来的第一个参数，<code>std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;","</code>可以理解为临时创建出来的匿名函数，函数的定义是<code>void(int)</code>。</p>

<p>让我们对比一下C++11标准的写法:</p>

<h3>1.b C++11.Lambda：构造一个functor</h3>

<p>```cpp
std::vector<int> vecIn;
vecIn.push_back(1);
vecIn.push_back(2);
vecIn.push_back(3);</p>

<p>std::cout&lt;&lt;&ldquo;the orgin value in vecIn：&rdquo;&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), <a href="const%20int%20&amp;%20val"></a>
{
std::cout&lt;&lt;val&lt;&lt;&ldquo;,&rdquo;;
});
std::cout&lt;&lt;std::endl;
```
一眼望去竟是boost的Lambda用法简洁。</p>

<h3>2.a boost.Lambda：修改参数的内容</h3>

<p>上面的例子，我们使用Lambda表达式，借助于for_each，对vector中的元素进行了访问，那我们可以修改vector的内容吗？</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), boost::Lambda::_1 *= boost::Lambda::_1);
std::for_each(vecIn.begin(), vecIn.end(), std::cout&lt;&lt;boost::Lambda::_1&lt;&lt;",");//打印
std::cout&lt;&lt;std::endl;
</code>
上面的例子，功能是对vecIn中的值求平方。占位符boost::Lambda::_1直接用引用的方式得到了传入的参数（vecIn的元素），结果直接改写进了vecIn。</p>

<h3>2.b C++11.Lambda：修改参数的内容</h3>

<p>修改1.b函数定义为引用即可</p>

<p><code>cpp
std::cout&lt;&lt;"the values in vecIn after Square："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [](int &amp; val)
{
val *= val;
});
//打印：
std::for_each(vecIn.begin(), vecIn.end(), [](const int &amp; val)
{
std::cout&lt;&lt;val&lt;&lt;",";
});
std::cout&lt;&lt;std::endl;
</code></p>

<h3>3.a boost.Lambda：变量捕获</h3>

<p>boost.Lambda可以很方便的以引用的方式捕获local变量，看例子：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), sum += boost::Lambda::_1);
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>3.b C++11.Lambda：变量捕获</h3>

<p>C++11捕获变量，可控性更强，我们可以指定捕获方式：</p>

<p><code>cpp
int sum = 0;
std::cout&lt;&lt;"the sum of values in vecIn："&lt;&lt;std::endl;
std::for_each(vecIn.begin(), vecIn.end(), [&amp;sum](int &amp; val)
{
sum += val;
});
std::cout&lt;&lt;sum&lt;&lt;std::endl;
</code></p>

<h3>4.a boost.Lambda：返回值</h3>

<p>有时需要匿名函数返回结果，比如作为std::find_if类似函数的Predicate函数时，这种能力boost.Lambda当然也是胜任的，整个Lambda表达式的结果，即是函数的返回值。</p>

<p>```cpp
boost::function&lt;bool(int)> IsOdd = boost::Lambda::_1 % 2 != 0;</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```
上面的例子创建了一个检测参数是否是奇数的匿名函数，并保存到IsOdd对象中，然后对其进行了调用。例子同样演示了如何将一个boost.Lambda表达式存储起来，后续使用的方法。</p>

<h3>4.b C++11.Lambda：返回值</h3>

<p>C++11的返回值，必须使用return语句，返回值的类型有些时候也需要显示指定。
```cpp
std::function&lt;bool(int)> IsOdd = (std::function&lt;bool(int)>)<a href="int%20val"></a>{return val % 2 != 0;};</p>

<p>std::cout&lt;&lt;&ldquo;100 is Odd？ &rdquo;&lt;&lt;std::boolalpha&lt;&lt;IsOdd(100)&lt;&lt;std::endl;
```</p>

<h3>5. 上面四个例子的运行结果</h3>

<pre><code>the orgin values in vecIn：
1,2,3,
the values in vecIn after Square：
1,4,9,
the sum of values in vecIn：
14
100 is Odd？ false
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Safe bool惯用法到explicit标识符]]></title>
    <link href="http://towriting.com/blog/2013/11/01/safe-bool-idiom/"/>
    <updated>2013-11-01T22:52:00+00:00</updated>
    <id>http://towriting.com/blog/2013/11/01/safe-bool-idiom</id>
    <content type="html"><![CDATA[<blockquote><p>C++是一个学语法都能让人入迷的奇葩语言，有各种的奇技淫巧。比如这里的许多的惯用法：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms">More C++ Idioms</a>，虽凝聚了C++程序员的聪明才智，但都是特定时期的产物，
相信都会被冲到C++语言演化长河的河滩上，仅供后人瞻仰（或者是C++本身）。让我们从Safe bool idiom说起。</p></blockquote>

<h2>Safe bool idiom</h2>

<p>什么是safe bool idiom？就是为自定义类型（class）提供检测真假的能力，而又不会带来副作用。</p>

<h3>为类(Class)提供检测真假的能力</h3>

<p>方法有二，第一种简单直白，提供一个返回bool类型的函数，比如下面的isValid成员函数：
<code>cpp
class CData
{
 public:
  bool IsValid() const;
};
int main()
{
  CData data;
  if (data.IsValid())
  {
   //dosomething
  }
}
</code>
这是直观而不易出错的。但多多少少有些强迫症的人会说，如果能像检测内置bool类型一样检测data对象不是更好的保证了代码的语法一致性？
<code>cpp
int main()
{
  CData data;
  if (data)
  {
   //dosomething
  }
}
</code>
同时他又急于向人们展示，"我会使用操作符重载哦“。于是第二种方法出来了，重载bool类型转化操作符：
<code>cpp
class CData
{
 public:
  operator bool() const;
};
int main()
{
  CData data;
  if (data)
  {
   //dosomething
  }
}
</code>
漂亮的外表后面的东西可能是有毒的，比如毒蘑菇、巫婆的毒苹果和传说中的红颜祸水们。软件开发也概莫能外，这个漂亮的解决方案后面有问题。</p>

<h3>bool操作符的副作用</h3>

<p>假使有一个简单的指针外敷类：
```cpp
template<typename T>
class CPtr
{
  T *ptr;
  public:
   operator bool() const
   {</p>

<pre><code>return ptr != nullptr;
</code></pre>

<p>   }
};</p>

<p>int main()
{
  CPtr<float> p1;
  CPtr<int>   p2;</p>

<p>  if (p1 == p2)
  {
   //天知道会怎样
   //something
  }</p>

<p>}</p>

<p>```
有人不小心拿两个不同类型的类对象来比较，不幸的是编译器并没有报错，因为17行隐式调用了operator==(bool,bool)，后面的结果真真天知道。
这可如何是好？C++社区里最不缺人才，很快有人想出解决方案：</p>

<h3>Safe bool实现</h3>

<p>Safe Bool正式的提出是这里：<a href="http://www.artima.com/cppsource/safebool.html">The Safe Bool Idiom</a>，方法就是写一个类型转化操作符，这个操作符返回一个可以进行 <strong>if</strong> 判断的特有类型：
```cpp
class Testable
{</p>

<pre><code>bool ok_;
typedef void (Testable::*bool_type)() const;
void this_type_does_not_support_comparisons() const {}
</code></pre>

<p>  public:</p>

<pre><code>explicit Testable(bool b=true):ok_(b) {}

operator bool_type() const {
  return ok_==true ? 
    &amp;Testable::this_type_does_not_support_comparisons : 0;
}
</code></pre>

<p>};</p>

<p>class TestableOther
{</p>

<pre><code>bool ok_;
typedef void (TestableOther::*bool_type)() const;
void this_type_does_not_support_comparisons() const {}
</code></pre>

<p>  public:</p>

<pre><code>explicit TestableOther(bool b=true):ok_(b) {}

operator bool_type() const {
  return ok_==true ? 
    &amp;Testable::this_type_does_not_support_comparisons : 0;
}
</code></pre>

<p>};</p>

<p>int main()
{
  Testable testable;
  TestableOther testableother;
  if (testable)
  {</p>

<pre><code>//something
</code></pre>

<p>  }
  if (testable == testableother) //编译错误
  {</p>

<p>  }</p>

<p>}</p>

<p>```
上面代码，利用的是bool_type是函数指针类型，所以可以进行 <strong>if</strong> 判断，且不同类的bool_type是不同的，直接比较会编译错误。
这就是safe bool Idiom，详细的代码可以参看这里：<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/">More C++ Idioms/Safe bool</a>。
但我认为这个方案是顾此失彼，会引发新的问题，比如类中重载operator int操作符怎么办？</p>

<h2>C++11的做法</h2>

<p>C++11的基因支持safe bool，方法就是使用<a href="http://en.cppreference.com/w/cpp/language/explicit">explicit</a>修饰operator：
```cpp
struct Testable
{</p>

<pre><code>explicit operator bool() const {
      return false;
}
</code></pre>

<p>};</p>

<p>int main()
{
  Testable a, b;
  if (a)      { /<em>do something</em>/ }<br/>
  if (a == b) { /<em>do something</em>/ }  // 编译错误
}
```
<strong>explicit</strong> 在C++11以前是只能用于修饰构造函数，但在C++11中可以用来修饰操作符，上面代码中的operator bool（）加上<strong>explicit</strong>表式其无法隐式转化为bool。
这个解决方案，干净漂亮，无副作用。</p>

<h2>总结</h2>

<p>C++11前后的两种Safe Bool的解决方案比较，优劣立现。站在实用的角度上，C++11出现后，C++中好多“高端技术”已经不需要学习，比如StackOver上列出的这些：<a href="http://stackoverflow.com/questions/9299101/what-c-idioms-are-deprecated-in-c11">what C++ idioms are deprecated in C++11</a>。这些东西就像毛笔字一样，可以仅供专家与爱好者把玩了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-常量表达式]]></title>
    <link href="http://towriting.com/blog/2013/09/17/constexpr/"/>
    <updated>2013-09-17T22:39:00+00:00</updated>
    <id>http://towriting.com/blog/2013/09/17/constexpr</id>
    <content type="html"><![CDATA[<p>C++11有一些这样的改善，这种改善保证写出的代码比以往任何时候的执行效率都要好。这种改善之一就是生成常量表达式，允许程序利用编译时的计算能力。假如你熟悉模板元编程，你将发现constexpr使这一切变得更加简单。假如你不知道模板元编程，也没什么。constexpr使我们很容易利用上编译时编程的优势。</p>

<p>常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时。需要计算一个编译时已知的常量，比如特定值的sine或cosin？确实你亦可以使用库函数sin或cos，但那样你必须花费运行时的开销。使用constexpr，你可以创建一个编译时的函数，它将为你计算出你需要的数值。用户的电脑将不需要做这些工作。</p>

<h3>constexpr初探</h3>

<p>为了使函数获取编译时计算的能力，你必须指定constexpr关键字到这个函数。</p>

<p>```cpp
constexpr int multiply (int x, int y)
{</p>

<pre><code>return x * y;
</code></pre>

<p>}</p>

<p>// 将在编译时计算
const int val = multiply( 10, 10 );
```
除了编译时计算的性能优化，constexpr的另外一个优势是，它允许函数被应用在以前调用宏的所有场合。例如，你想要一个计算数组size的函数，size是10的倍数。如果不用constexpr，你需要创建一个宏或者使用模板，因为你不能用函数的返回值去声明数组的大小。但是用constexpr，你就可以调用一个constexpr函数去声明一个数组。</p>

<p>```cpp
constexpr int getDefaultArraySize (int multiplier)
{</p>

<pre><code>return 10 * multiplier;
</code></pre>

<p>}</p>

<p>int my_array[ getDefaultArraySize( 3 ) ];
```</p>

<h2>constexpr函数的限制</h2>

<p>一个constexpr有一些必须遵循的严格要求：</p>

<ul>
<li>函数中只能有一个return语句（有极少特例）</li>
<li>只能调用其它constexpr函数</li>
<li>只能使用全局constexpr变量</li>
</ul>


<p>注意递归并不受限制。但只允许一个返回语句，那如何实现递归呢？可以使用三元运算符（?:)。例如，计算n的阶乘：
```cpp
constexpr int factorial (int n)
{</p>

<pre><code>return n &gt; 0 ? n * factorial( n - 1 ) : 1;
</code></pre>

<p>}
```
现在你可以使用factorial(2)，编译器将在编译时计算这个值，这种方式运行更巧妙的计算，与内联截然不同。你无法内联一个递归函数。</p>

<p><strong>constexpr函数还有那些特点？</strong></p>

<p>一个constexpr函数，只允许包含一行可执行代码。但允许包含typedefs、 using declaration &amp;&amp; directives、静态断言等。</p>

<h2>constexpr和运行时</h2>

<p>一个声明为constexpr的函数同样可以在运行时被调用，当这个函数的参数是非常量的：
<code>cpp
int n;
cin &gt;&gt; n;
factorial( n );
</code>
这意味着你不需要分别写运行时和编译时的函数。</p>

<h2>编译时使用对象</h2>

<p>假如你有一个Circle类：
```cpp
class Circle
{</p>

<pre><code>public:
Circle (int x, int y, int radius) : _x( x ), _y( y ), _radius( radius ) {}
double getArea () const
{
    return _radius * _radius * 3.1415926;
}
private:
    int _x;
    int _y;
    int _radius;
</code></pre>

<p>};
<code>
你希望在编译期构造一个Circle接着算出他的面积。
</code>cpp
constexpr Circle c( 0, 0, 10 );
constexpr double area = c.getArea();
<code>
事实证明你可以给Circle类做一些小的修改以完成这件事。首先，我们需要将构造函数声明为constexpr，接着我们需要将getarea函数声明为constexpr。将构造函数声明为constexpr则运行构造函数在编译期运行，只要这个构造函数的参数为常量，且构造函数仅仅包含成员变量的constexpr构造（所以默认构造可以看成constexpr，只要成员变量都有constexpr构造）。
</code>cpp
class Circle
{</p>

<pre><code>public:
constexpr Circle (int x, int y, int radius) : _x( x ), _y( y ), _radius( radius ) {}
constexpr double getArea () 
{
    return _radius * _radius * 3.1415926;
}
private:
    int _x;
    int _y;
    int _radius;
</code></pre>

<p>};
```</p>

<h2>constexpr vs const</h2>

<p>假如你将一个成员函数标记为constexpr，则顺带也将它标记为了const。如果你将一个变量标记为constexpr，则同样它是const的。但相反并不成立，一个const的变量或函数，并不是constexpr的。</p>

<h2>constexpr和浮点数</h2>

<p>到这里我们讲到的constexpr功能都可以通过模板元编程实现。但constexpr支持的一项能力是可以计算浮点型的数据。因为double和float不是有效的模板参数，你不可以轻易的通过模板编译期计算浮点数的值。而constexpr允许编译期计算浮点型数据。</p>

<h2>权衡constexpr</h2>

<p>C++开发者早就深受修改一个头文件则引发重新编译导致编译缓慢的困扰。而constexpr可能引入增加编译时间的风险，但也有一些技术去降低这种风险。首先，因为constexpr函数相同的参数会输出相同的结果，所以它们可以被<a href="http://en.wikipedia.org/wiki/Memoization">memoized</a>，事实上GCC已经支持memoization。</p>

<p>因为可以对constexpr函数memoize,所以用constexpr函数替换模板函数的地方，(编译）性能不会变得更坏，但代码会变得清晰。事实上，替换掉一部分模板实例，编译会显著加快。</p>

<p>最后，标准允许编译器去限制递归函数的级数。这样可以限制深度递归的编译性能损耗。</p>

<h2>编译器支持</h2>

<p>constexpr需要编译器支持编译期的递归，所以也不奇怪支持constexpr的编译器并不多，就我所知只有G++4.7支持这一特性。[注：到我翻译时，intelC++13、Clang3.1也都支持了，不过Vs2013还是不支持]</p>

<p>下一篇：右值引用和移动语义</p>

<p>上一篇：<a href="/blog/2013/08/20/ranged-for-loop/">区间迭代</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-compile-time-processing-with-constexpr.html">Constexpr &ndash; Generalized Constant Expressions in C++11</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-区间迭代]]></title>
    <link href="http://towriting.com/blog/2013/08/20/ranged-for-loop/"/>
    <updated>2013-08-20T22:50:00+00:00</updated>
    <id>http://towriting.com/blog/2013/08/20/ranged-for-loop</id>
    <content type="html"><![CDATA[<p>在我前面<a href="/blog/2013/08/01/what-is-cpp11/">介绍C++11</a>的文章中，我提到C++11将会带来一些实用的改进。我的意思是它将移除一些不必要的打字和其它影响快速编码的壁垒。我前面讲过的<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">auto关键字</a>就是一个例子；现在我想讲一下区间迭代（range-based for loop）。</p>

<h2>区间迭代的基本语法</h2>

<p>近来，基本上所有现代编程语言都有一种对一个区间写for循环的便捷方式。最终，C++也有了相同的概念；你可以给循环提供一个容器，它帮你迭代。前面我们已经在<a href="/blog/2013/08/01/what-is-cpp11/">什么是C++11</a>中看到了一些简单的例子。让我们回忆一下区间迭代的样子：
```cpp
vector<int> vec;
vec.push_back( 10 );
vec.push_back( 20 );</p>

<p>for (int i : vec )
{</p>

<pre><code>cout &lt;&lt; i;
</code></pre>

<p>}
<code>
上面代码打印一个名叫vec的vector的内容，用i去捕获vector里面的值，直至vector的最后。你也可以用auto代替类型便利的迭代复杂的数据结构。例如，迭代一个map:
</code>cpp
map&lt;string, string> address_book;
for ( auto address_entry : address_book )
{</p>

<pre><code>        cout  &lt;&lt; address_entry.first &lt;&lt; " &lt; " &lt;&lt; address_entry.second &lt;&lt; "&gt;" &lt;&lt; endl;
</code></pre>

<p>}
```</p>

<h2>修改vector的值</h2>

<p>假如你想修改你正在迭代的容器的值，或者你想避免拷贝大对象，你可以用引用的变量遍历。比如，下面的迭代对一个整形vector中每个元素的值加1。
```cpp
vector<int> vec;
vec.push_back( 1 );
vec.push_back( 2 );</p>

<p>for (int&amp; i : vec )
{</p>

<pre><code>i++; // increments the value in the vector
</code></pre>

<p>}
for (int i : vec )
{</p>

<pre><code>// show that the values are updated
cout &lt;&lt; i &lt;&lt; endl;
</code></pre>

<p>}
```</p>

<h2>区间意味着什么？</h2>

<p>Strings,arrays,和所有的STL容器可以被新的区间迭代方式迭代。但是如果你想让你自己的数据结构使用这个新语法怎么办？</p>

<p>为了使这个数据结构可迭代，它必须类似于STL迭代器。</p>

<ul>
<li>这个数据结构必须要有begin和end方法，成员方法和独立函数都行，这两个方法分别返回开始和结束的迭代器</li>
<li>迭代器支持*操作符、!=操作符、++方法（前缀形式，成员函数和独立函数都行）</li>
</ul>


<p>就这些！实现这五个函数，你就可以有一个支持区间迭代的数据结构。因为begin、end可以是非成员函数，你甚至可以适配现有数据结构而不用实现STL风格的迭代器。所有你要做的是创建你自己的支持*、前缀++和!=的迭代器，并且定义好自己的begin、end。</p>

<p>区间迭代如此NICE。所以我怀疑大部分还不支持STL迭代模型的容器都会想添加某种适配方式以支持区间迭代。这里有一个小程序演示创建一个支持区间迭代的迭代器。这个例子里，我创建了一个固定Size是100的IntVector，并且可以被一个叫做Iter的类迭代。
```cpp</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>class IntVector;</p>

<p>class Iter
{</p>

<pre><code>public:
Iter (const IntVector* p_vec, int pos)
    : _pos( pos )
    , _p_vec( p_vec )
{ }

// 这三个方法组成支持区间迭代的迭代器的基础
bool
operator!= (const Iter&amp; other) const
{
    return _pos != other._pos;
}

int operator* () const;

const Iter&amp; operator++ ()
{
    ++_pos;
    return *this;
}

private:
int _pos;
const IntVector *_p_vec;
</code></pre>

<p>};</p>

<p>class IntVector
{</p>

<pre><code>public:
IntVector ()
{
}

int get (int col) const
{
    return _data[ col ];
}
Iter begin () const
{
    return Iter( this, 0 );
}

Iter end () const
{
    return Iter( this, 100 );
}

void set (int index, int val)
{
    _data[ index ] = val;
}

private:
</code></pre>

<p>   int _data[ 100 ];
};</p>

<p>int
Iter::operator* () const
{</p>

<pre><code> return _p_vec-&gt;get( _pos );
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>IntVector v;
for ( int i = 0; i &lt; 100; i++ )
{
    v.set( i , i );
}
for ( int i : v ) { cout &lt;&lt; i &lt;&lt; endl; }
</code></pre>

<p>}
```
注意这段代码中区间迭代时，不允许以引用修改IntVector中的元素。这是为了不使代码变长而影响代码的主要结构，所以并没添加返回引用类型的函数。</p>

<h2>区间迭代提升性能？</h2>

<p>在我使用GCC4.6的有限的测试中，我并没看到区间迭代相对于标准STL迭代的性能提升，但好像可以和STL中的for_each拥有同样的性能。</p>

<h2>编译器支持</h2>

<p>不幸的是，区间迭代的编译器支持的不好。MSVC11以后开始支持，GCC是4.6以后支持。</p>

<p>下一篇：<a href="/blog/2013/09/17/constexpr/">常量表达式</a></p>

<p>上一篇：<a href="/blog/2013/08/11/lambda-closures/">lambda表达式</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-ranged-for-loop.html">Range-Based For Loops in C++11 &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11系列-lambda函数]]></title>
    <link href="http://towriting.com/blog/2013/08/11/lambda-closures/"/>
    <updated>2013-08-11T22:45:00+00:00</updated>
    <id>http://towriting.com/blog/2013/08/11/lambda-closures</id>
    <content type="html"><![CDATA[<p><img class="pull-left" src="/images/posts/lambda-closures/lambda.png" width="66" height="90" title="&lsquo;lambda&rsquo;" >
C++11一个最激动人心的特性是支持创建lambda函数（有时称为闭包）。这意味着什么？一个Lambda函数是一个可以内联写在你代码中的函数（通常也会传递给另外的函数，类似于仿函数或函数指针）。使用Lambda，创建机动函数会更简单，而以前你必须创建一个有名函数。在这篇文章中，我先用一些例子解释为什么lambda很酷，然后我会讲解可能会用到的关于lambda的所有细节。</p>

<h2>为什么Lambda很酷</h2>

<p>想象你有一个地址簿类，并且你想要提供一个可供检索的函数。你可能会提供一个简单的函数，接受一个字符串然后返回满足所有字符串的地址。有时有些用户可能希望这样。不过假如他们只是想检索域名或者检索用户名并且忽略域名结果；或者检索出现在其他列表中的所有Email地址。这里可能有许多可能的检索方式。除了类中集成所有这些搜索选项，提供一个通用的查找方法，这个方法接受一个查找规则的函数，这样不是更好些吗？让我们叫这个函数findMatchingAddresses，它接受一个函数或仿函数对象。
```cpp</p>

<h1>include <string></h1>

<h1>include <vector></h1>

<p>class AddressBook
{</p>

<pre><code>public:
// 使用模板可以是我们忽略函数、仿函数和Lambda的不同
template&lt;typename Func&gt;
std::vector&lt;std::string&gt; findMatchingAddresses (Func func)
{ 
    std::vector&lt;std::string&gt; results;
    for ( auto itr = _addresses.begin(), end = _addresses.end(); itr != end; ++itr )
    {
        // 调用传递到findMatchingAddresses的函数并检测是否匹配规则
        if ( func( *itr ) )
        {
            results.push_back( *itr );
        }
    }
    return results;
}

private:
std::vector&lt;std::string&gt; _addresses;
</code></pre>

<p>};
```
任何人可以传递一个包含地址查找逻辑的函数给findMatchingAddresses。假如这个函数返回真，则得到相应的地址，地址将被返回。这种方式在以前的C++中一样支持，不过却遭遇一个致命缺陷：创建函数非常不方便。你必须先在其他地方定义好函数，你才能使用它。这就是Lambda出现的原因。</p>

<h2>基本Lambda语法</h2>

<p>在我们解决这个问题之前，让我们看一下真实的lambda基本语法。
```cpp</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>int main()
{</p>

<pre><code>auto func = [] () { cout &lt;&lt; "Hello world"; };
func(); // now call the function
</code></pre>

<p>}
```
好，你找到lambda了吗？它以[]开始。这个标识，叫做捕获指定器，它告诉编译器我们要创建一个lambda表达式。你将看到[](或者里面有变量）在每一个lambda函数的开始。</p>

<p>接着，像其他函数一样，我们需要一个参数列表：()。返回值呢？答案是我们不需要指定。在C++11中，假如编译器可以推导lambda函数的返回值，它将帮你做这件事而不需你显式指定。在这个例子里，编译器知道函数没有返回值。我们只是有一个打印“hello world"的函数体。这一行事实上不会触发关于打印的任何事：我们仅仅是创建了一个函数在这里。基本上相当于定义了一个普通函数。</p>

<p>我们在下面一行调用了这个lambda函数：func()，像调用其它普通函数一样。顺便看到，配合auto做这些事情是多么简单！你不用担心函数指针的丑陋语法。</p>

<h2>在我们的例子中应用Lambda</h2>

<p>让我们看看怎样将lambda应用到我们地址簿例子里，首先我们创建一个查找包含“.org"的email地址的简单函数。
```cpp
AddressBook global_address_book;</p>

<p>vector<string> findAddressesFromOrgs ()
{</p>

<pre><code>return global_address_book.findMatchingAddresses( 
    // we're declaring a lambda here; the [] signals the start
    [] (const string&amp; addr) { return addr.find( ".org" ) != string::npos; } 
);
</code></pre>

<p>}
```</p>

<!-- more -->


<p>再一次，我们以捕获指示符[]开始，但这一次我们有一个参数：地址，并且我们检测地址中是否含有“.org"。再一次说明，lambda的函数体并没有在这里执行；它只会在函数findMatchingAddresses内，当函数变量被使用时，lambda中的代码才会执行。换句话说，findMatchingAddresses的每个循环中会调用lambda函数，并传给它一个地址作为参数，然后这个函数检测地址是否包含“.org"。</p>

<h2>变量捕获</h2>

<p>虽然这些简单的lambda用法也不错，但变量捕获才是成就lambda卓越的秘方。假如你想创建一个查找包含指定名字的短函数。如果可以写出这样的代码是不是非常不错？
```cpp
// read in the name from a user, which we want to search
string name;
cin>> name;
return global_address_book.findMatchingAddresses(</p>

<pre><code>// 注意lambda函数使用了变量 'name'
[&amp;] (const string&amp; addr) { return addr.find( name ) != string::npos; } 
</code></pre>

<p>);
```
可以证明示例代码是合法的，并且它展现了lambda函数的价值。我们可以获取声明在lambda函数之外的变量(name)，并在lambda之内使用。当findMatchingAddresses调用我们的lambda函数，函数体会被执行，当addr.find被调用，它处理用户代码传进的name。为了使这可以运行的唯一要做的事是捕获变量。我用[&amp;]捕获指示做这件事，而不是用[]。[]是告诉编译器不捕获任何变量，而[&amp;]是告诉编译器去捕获变量。</p>

<p>是不是不可思议？我们创建了一个简单的可以捕获变量的函数，并将它传给find函数，所有这些只用了几行代码。如果不用C++11实现这些，我们需要创建一个仿函数或者给AddressBook类添加一个特殊方法。用C++11，我们可以轻易实现一个简单的接口函数，但支持各种检索的功能。</p>

<p>只是好玩，我们想查找email地址小于某个特殊长度的地址。我们可以再一次轻松实现：
<code>cpp
int min_len = 0;
cin &gt;&gt; min_len;
return global_address_book.find( [&amp;] (const string&amp; addr) { return addr.length() &gt;= min_len; } );
</code>
你将习惯于"})&ldquo;，这是lambda结束的标准语法，你开始阅读lambda相关代码或在你自己的代码中使用lambda越多，你将越多的看到这个小的代码片段。</p>

<h2>Lambda和STL</h2>

<p>毋庸质疑，lambda最大的一个优势是在使用STL中的算法(algorithms)库时。以前使用像for_each这样的算法是个体力活。然而现在使用for_each或其他STL算法就好像自己写普通循环一样。对比一下：
```cpp
vector<int> v;
v.push_back( 1 );
v.push_back( 2 );
//&hellip;
for ( auto itr = v.begin(), end = v.end(); itr != end; itr++ )
{</p>

<pre><code>cout &lt;&lt; *itr;
</code></pre>

<p>}
<code>
和：
</code>cpp
vector<int> v;
v.push_back( 1 );
v.push_back( 2 );
//&hellip;
for_each( v.begin(), v.end(), [] (int val)
{</p>

<pre><code>cout &lt;&lt; val;
</code></pre>

<p>} );
```
要我说后一种代码更漂亮，好在它的可读性和结构，也像个普通循环，并且可以利用上for_each可以提供的普通循环没有的一些优势，比如保证你有正确的结束条件。现在你可能会想，这会不会影响性能？意想不到的结论是for_each和普通循环有一样的性能，有时甚至更快（原因是循环展开）。</p>

<p>我希望STL的例子告诉你lambda不仅仅是创建函数的一种简便方式，它创造了一种新的编码方式，当你的代码作为数据处理函数时，你可以抽象处理特殊数据结构的方式。for_each适用于List，但是如果有处理“树”的类似函数是不是很酷？所有你要做的只是写处理每个节点的代码，而无需关心遍历算法。这种一个函数管理数据，将具体的数据处理过程委托到另一个函数的分解方式很有用。使用lambda，C++允许我们这种新的编程方式。这是我们以前没有的，但for_each不是新的，只不过以前我们不想用罢了。</p>

<h2>继续新的lambda语法</h2>

<p>其实参数列表像返回值一样都是可选的，如果你想创建一个不带参数的函数的话。或许最短的lambda是这样的：
<code>cpp
[]{}
</code>
这是一个即没有参数又什么也不干的函数。一个稍有内容的函数：
```cpp
using namespace std;</p>

<h1>include <iostream></h1>

<p>int main()
{</p>

<pre><code>[] { cout &lt;&lt; "Hello, my Greek friends"; }();
</code></pre>

<p>}
```
个人来讲，我不认可省略参数列表的价值。我认为[]和()的组合结构帮助lambda函数在代码上更出色。</p>

<h3>返回值</h3>

<p>如果你的lambda函数没有return语句，则默认返回void。假如你有一个简单的返回语句，编译器将推导返回值的类型：
<code>cpp
[](){return 1;} //编译器知道这是返回一个整型
</code>
假如你写一个更复杂些的lambda函数，不止一个返回值，你应该指定返回类型（有些编译器，像GCC，即使你有多于一个返回值也不需要你这样做，但标准不保证这一点）。
Lambda函数利用<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">C++11可选的新返回值语法</a>将返回值放在函数的后边。事实上假如你想指定返回类型，你一定要这样做。这里有一个显式指定返回值类型的简单例子：
<code>cpp
[] () -&gt; int { return 1; } // 现在你告诉编译器你想要什么
</code></p>

<h3>抛异常指示（throw)</h3>

<p>虽然C++标准委员会决定不赞成使用throw指示符，但throw还没被移除C++。这里有许多检测throw指示符的静态代码检测工具，像PC link。假如你使用这些工具中的一个去进行编译时异常检测，你肯定想知道你的lambda函数会抛出什么异常。这样做的主要原因可能是当你传递一个lambda函数到另一个函数中，而这个函数期望你的lambda只能抛出指定的异常。给你的lambda函数添加一个异常指示，将允许PC link这样的工具去帮你检测。如果你想这样做是可以的。这有一个无参且不抛出异常的lambda函数：
<code>cpp
[] () throw () { /* 你不希望抛出异常*/ }
</code></p>

<h2>Lambda函数是如何实现的？</h2>

<p>变量捕获的魔法是如何运作的？其实lambda实现的方法是创建一个简略的类。这个类重载了operator()，所以表现的像个普通函数。一个lambda函数是这个类的实例。当这个类构造的时候，所有捕获的变量被传送到类中并保存为成员变量。事实上这类似于以前就支持的functor。C++11的优势是这一切都变得非常简单。你可以在任意时候使用它，而不仅仅是极少的特殊场合去写一整个的类。</p>

<p>C++为性能计，实际上提供了好几种灵活的捕捉变量的方式，所有这些都是靠捕捉指示控制的[]。你已经看到了两种情况，[]中什么也没有则不捕获变量，用&amp;则变量以引用捕获。如果你创建了一个空[]的lambda函数，C++将创建一个普通的函数而不是类。这里有完整的捕获选项：</p>

<pre><code>[]  不捕获任何变量
[&amp;] 以引用方式捕获所有变量
[=] 用值的方式捕获所有变量（可能被编译器优化为const &amp;)
[=, &amp;foo] 以引用捕获foo, 但其余变量都靠值捕获
[bar] 以值方式捕获bar; 不捕获其它变量
[this] 捕获所在类的this指针
</code></pre>

<p>注意最后一个捕获选项，如果你已经指定了一个默认的捕获（=或者&amp;）那么也包含this。但是能捕获this指针的能力非常重要，这意味着写函数时你不需要区分局部变量和类属性的不同，两者都可以获取到。酷的是你不需显式指定this指针。它真的像你在写一个内联函数。
```cpp
class Foo
{
public:</p>

<pre><code>Foo () : _x( 3 ) {}
void func ()
{
    // a very silly, but illustrative way of printing out the value of _x
    [this] () { cout &lt;&lt; _x; } ();
}
</code></pre>

<p>private:</p>

<pre><code>    int _x;
</code></pre>

<p>};</p>

<p>int main()
{</p>

<pre><code>Foo f;
f.func();
</code></pre>

<p>}
```</p>

<h3>捕获引用的优缺点</h3>

<p>以引用捕获变量时，可以在lambda函数内修改局部变量的值。这也意味着从一个函数中返回一个lambda函数，你不能以引用捕获变量，因为引用的值在函数返回时已经无效了。</p>

<h2>lambda函数的类型是什么？</h2>

<p>创建lambda函数的一个原因是有些人创建了一个希望接受lambda函数的函数。我们已经看到了我们使用模板去接收lambda函数作为参数，并且使用auto去接这个lambda函数作为一个局部变量。但是你如何命名指定的lambda函数？因为像前面看到的一样，每一个lambda函数都实现为一个独立的类，所以即使是拥有相同类型和返回值的lambda函数也是不同的类型。但C++11提供了一个便捷的外敷类去存储任何类型的函数，lambda函数、仿函数和函数指针。</p>

<h3>std::function</h3>

<p>新的std::function是传递lambda函数的最好的方式，不管是传递参数还是返回值。它允许你在模板中指定参数列表和返回值的确切类型。这里有AddressBook的例子，这次我们使用std::function代替模板。注意我们用到了'functional'头文件。
```cpp</p>

<h1>include <functional></h1>

<h1>include <vector></h1>

<p>class AddressBook
{</p>

<pre><code>public:
std::vector&lt;string&gt; findMatchingAddresses (std::function&lt;bool (const string&amp;)&gt; func)
{ 
    std::vector&lt;string&gt; results;
    for ( auto itr = _addresses.begin(), end = _addresses.end(); itr != end; ++itr )
    {
        // 调用传递到findMatchingAddresses的函数并检测是否匹配规则
        if ( func( *itr ) )
        {
            results.push_back( *itr );
        }
    }
    return results;
}

private:
std::vector&lt;string&gt; _addresses;
</code></pre>

<p>};
```
std::function较模板的一大优势是，使用模板你必须将整个函数放到头文件中，而std::function则不用。当你的代码变化频繁并且被好多代码文件引用时，这会非常有用。</p>

<p>假如你想检测std::function是否含有一个有效的函数，把它当作boolean就可以了：
```cpp
std::function<int ()> func;
// 检测是否包含函数
if ( func )
{</p>

<pre><code>// if we did have a function, call it
func();
</code></pre>

<p>}
```</p>

<h3>关于函数指针的提示</h3>

<p>在最终的C++11标准中，假如你有一个指定空捕获列表的lambda函数，那它将像普通函数一样并可以被赋值到一个函数指针。这有一个作为指针使用空捕获列表lambda的例子：
<code>cpp
typedef int (*func)();
func f = [] () -&gt; int { return 2; };
f();
</code>
这样是可以的，因为lambda函数没有捕获组，那也就不需要自己的类。它可以被编译成普通函数，运行被传递给普通函数。不幸的是这个特性没有被包含到MSVC10中，它被加入到标准的时间太晚了。</p>

<h2>使用Lambda实现委托</h2>

<p>让我们在看一个lambda函数的例子，这次我们创建一个委托。当调用一个普通函数时，你只需要知道这个函数。而调用类的成员函数时，你需要知道两件东西：成员函数和类对象。这是func()和obj.method()的不同。要调用一个成员方法，你需要两者，仅仅将函数地址传进去是不够的，你需要一个对象去调用这个函数。</p>

<p>让我们看一个例子：
```cpp</p>

<h1>include <functional></h1>

<h1>include <string></h1>

<p>class EmailProcessor
{
public:</p>

<pre><code>void receiveMessage (const std::string&amp; message)
{
    if ( _handler_func ) 
    {
        _handler_func( message );
    }
    // other processing
}
void setHandlerFunc (std::function&lt;void (const std::string&amp;)&gt; handler_func)
{
    _handler_func = handler_func;
}
</code></pre>

<p>private:</p>

<pre><code>    std::function&lt;void (const std::string&amp;)&gt; _handler_func;
</code></pre>

<p>};
<code>
这是注册回调函数到类里的很典型的模式，当感兴趣的事情发生时会调用回调函数。接着我们希望另一个类负责跟踪最长的消息（为什么这么做，或许你是一个无聊的管理员）。总之我们创建了如下的类：
</code>cpp</p>

<h1>include <string></h1>

<p>class MessageSizeStore
{</p>

<pre><code>MessageSizeStore () : _max_size( 0 ) {}
void checkMessage (const std::string&amp; message ) 
{
    const int size = message.length();
    if ( size &gt; _max_size )
    {
        _max_size = size;
    }
}
int getSize ()
{
    return _max_size;
}
</code></pre>

<p>private:</p>

<pre><code>int _max_size;
</code></pre>

<p>};
<code>
如果我们想让checkMessage在消息来时被调用，我们该怎么做？我们不能只传进checkMessage自己。它是个成员方法，所以它需要一个对象。
</code>cpp
EmailProcessor processor;
MessageSizeStore size_store;
processor.setHandlerFunc( checkMessage ); // 这行不通
<code>
我们需要绑定setHandleFunc和size_store变量的方法。恩，听起来是lambda的拿手好戏！
</code>cpp
EmailProcessor processor;
MessageSizeStore size_store;
processor.setHandlerFunc(</p>

<pre><code>    [&amp;] (const std::string&amp; message) { size_store.checkMessage( message ); } 
</code></pre>

<p>);
```
够酷吧，我们这里把lambda使成了胶水代码，允许我们传递普通函数到setHandleFunc，实际上调用的还是委托类的成员函数。</p>

<h2>总结</h2>

<p>lambda函数会不会出现在C++代码的各种地方？我觉得会。我开始使用lambda函数在更富生产力的代码中，它们出现在所有的地方：一些为精简代码、一些为支持单元测试、一些代替以前用宏实现的代码。Year，我想lambda比其它希腊字母要酷。</p>

<p>下一篇：<a href="/blog/2013/08/20/ranged-for-loop/">区间迭代</a></p>

<p>上一篇：<a href="/blog/2013/08/08/improved-type-inference-in-cpp11/">如何用auto、decltype和新的函数语法编写更好的代码</a></p>

<p>译者：<a href="/">toWriting.com</a>；翻译自：<a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html">C++11 &ndash; Lambda Closures, the Definitive Guide &ndash; Cprogramming.com</a></p>
]]></content>
  </entry>
  
</feed>
