<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 程序人生 | 书写|记下人生痕迹]]></title>
  <link href="http://towriting.com/blog/categories/cheng-xu-ren-sheng/atom.xml" rel="self"/>
  <link href="http://towriting.com/"/>
  <updated>2013-12-18T00:16:34+08:00</updated>
  <id>http://towriting.com/</id>
  <author>
    <name><![CDATA[ToWriting]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我为什么从同花顺离职]]></title>
    <link href="http://towriting.com/blog/2013/12/16/why-i-quit-ths-job/"/>
    <updated>2013-12-16T23:42:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/16/why-i-quit-ths-job</id>
    <content type="html"><![CDATA[<p>  最近知乎上很流行的一个问题是<a href="http://www.zhihu.com/topic/19909711">为什么从 X 离职</a>，倒退一年快到自己决定离职的日子了，趁热闹，也说说自己为什么离职。</p>

<p>  首先，照例发自肺腑的感谢一下同花顺，同花顺的日子是我C++进步最快的一段时间，在这里我接触到了正规的开发流程，并且遇到了一个很棒的团队，那时的日子每天都很开心。</p>

<hr />

<p>  切入正题，我为什么离开同花顺：</p>

<h3>待遇认知的分歧</h3>

<p>　员工离职的理由千万条，但薪水待遇肯定是大部分人选择离开的最重要的原因，不过大部分人不肯承认罢了。离职的导火索就是公司的年终奖，入职Offer上明确写明是3-6个月，可实际发到手的一月左右。我表明了自己的不满，公司领导以程序员不是钟点工，薪水是靠产品的收益决定的来“开导”我。这种观点不错，但是却是站在创业者的角度看的。自己作为一个打工者，站在打工者的角度上讲，程序员的待遇在市场经济条件下，是由供求关系决定的，并上下浮动于程序员个体的能力和工作产出。何况公司远没到揭不开锅的程度，你可以不按约定给我应有的Money，但不能忽悠我。</p>

<h3>人为什么要工作？</h3>

<p>　马斯洛总结了人的<a href="http://en.wikipedia.org/wiki/Maslow's_hierarchy_of_needs">五种需求</a>。</p>

<p>　刚毕业时囊空如洗，一头扎进工作中，完全是为了实现人的第一种需求-生理（存）需求。自己前两年的工作确实是为了实现生存需求，但当工作两三年，衣食无虞，现在仍然工作的原因好像是上一阶段的惯性。有些人可能为了实现“昂贵”的生理需求（车房等）而工作一辈子，但对我而言这种动力不足以使我能持续激情的工作。</p>

<p>　顺着马斯洛的需求金子塔往上看，塔顶是自我实现的需求，这是人的最高级的需求。</p>

<p>　是否可以提高自己的能力，是我衡量一份工作是否适合自己的重要指标。以前从没有在内心中将自我能力的提高作为工作的一个直接原因，觉得能力提高（自我实现需求）不过是为了能挣更多钱（生理需求），觉得后者才是工作的直接原因。看来我错了，自我能力的提高属于自我实现的需求，完全是促使我们工作的高级原因。而可贵的是，高级的需求好像兼容低级的需求，就是你在实现了自我实现的需求后，生理需求自然可以满足了。并且生理需求容易满足，自我实现需求难以满足，而自我实现的满足可以给人带来持久且真正的满足。在我看来，工作中的自我实现包括两点：自我能力提高和我（们）创造了有价值的东西。</p>

<p>  而同花顺，据观察感知是无法满足我这两种需求的，尤其第二种，我的判断是错误的吗？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你们是勤劳还是懒惰的程序员？]]></title>
    <link href="http://towriting.com/blog/2013/12/15/are-your-programmers-working-hard-or-are-they-lazy/"/>
    <updated>2013-12-15T17:17:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/15/are-your-programmers-working-hard-or-are-they-lazy</id>
    <content type="html"><![CDATA[<p><img class="pull-right" src="/images/posts/working-hard/work-smart-not-hard.jpg">
当人们从事体力劳动时，很容易判断他们的努力程度。你可以看到肢体运动和汗水。并且可以看到他们的劳动成果：高楼拔地，稻谷归仓&hellip;。承认和褒奖辛勤的劳作是人的一种本能，是体力运动迷人的一个原因。然而当管理创造性技术员工时，褒扬辛勤劳作的本能就有问题了。高效的员工有时候看起来并没有非常努力的工作。</p>

<p>时光回到2004年，那时我在一家有线电视公司的收费和服务开通系统项目部做初级工程师。这个系统很大，像所有大系统一样，它由一些小的独立的组件构成，每个组件由一些人或小的团队开发。模拟和数字开通系统是几乎毫无关联的系统，由不同的团队分别开发。</p>

<p>模拟电视组计划基于Microsoft Biztalk的一个早期版本开发他们的系统。由我们四名员工和一个微软的团队来开发这个系统和进行生产运行。他们看起来都工作的很辛苦。经常听说他们在晚上和周末加班。一旦出现任何运行故障，每个人都必须放下手头的工作，围在一个人的桌子前，讨论并提出解决意见。正如我们看到的，他们的队伍凝成了一条绳，并且每个成员都非常的努力。</p>

<p>而数字电视组的风貌则截然不同了。初期所有的代码几乎都是一个叫做Dave的家伙写的，我作为初级程序员主要负责一些维护工作。最初我对这些代码很费解，明明一个函数可以搞定的事情，却用好多只有几行代码的类来实现，一些同事也抱怨Dave把事情搞复杂了。但Dave建议我读一些面向对象的书籍，并给我讲解设计模式、<a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID原则</a>、单元测试。于是这些代码在我脑中生动起来，深入看过这些代码之后，不得不赞叹其设计的优雅：改变一些代码非常简单，实现新功能根本没什么难的，有单元测试意味着甚少有BUG。</p>

<p>结果是我们看起来工作的很随意。每天下午五点半回家，周末从不加班，从来不会挤在一个人的桌子边胡乱猜测系统的哪个部分出问题了。外人肯定以为我们接到的工作要比模拟电视团队的轻松许多。事实上是，需求差不多，我们只是有更好的设计和单元测试等的基础支撑。</p>

<p>加薪时，公司宣布以表现作为评定的标准。轮到我和老板对话时，老板讲到给那些辛勤工作的人加更多的薪水是很公平的，我们的团队并不以公司事情为己任，比不上那些牺牲了自己晚上和周末时间的英雄们。</p>

<p>公司应该做个实验，观察对比良好设计和团队表现这两个因素的效果。大部分组织是不会做这个对比的。很难判断一个挥洒汗水、废寝忘食、日夜待命的人是否有胜任复杂系统开发的能力。也很难说朝九晚五，上班淘宝的家伙是高质量代码的编程好手，还是仅仅分配到简单的任务？但常人看到的只是第一种人努力工作，而第二种没有。勤快是好的，懒惰就是坏的吗？</p>

<p>我必须说困苦工作是失败的前兆。软件开发在压力、中断的环境中不会进行的很好。工作很长时间不是个好主意。有时解决一个难题的方法是停止想它，出去溜一圈，甚至睡一大觉让潜意识去解决掉它。我最喜欢的一本书是20世纪著名的数学家哈代写的<a href='http://www.amazon.cn/gp/product/B0011F7ORK/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011F7ORK&linkCode=as2&tag=bringmeluck-23' rel='external nofollow' target='_blank'>一个数学家的辩白</a>。书中提到哈代自己的作息是这样的：早上四个小时的工作然后下午看板球。他提到超过四个小时的连续脑力工作是徒劳和无意义的。</p>

<p>我想对管理者说，要以结果以可以工作的软件来衡量人，而不是以人工作时的辛苦程度。你应该衡量员工的产出，而不是坐在他们旁边观察他们不自在的操作着IDE，抑或是围在一块儿相互“帮助”。</p>

<p>由Towriting.com翻译自：<a href="http://mikehadlow.blogspot.com/2013/12/are-your-programmers-working-hard-or.html">Code rant: Are Your Programmers Working Hard, Or Are They Lazy?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[整洁代码之上]]></title>
    <link href="http://towriting.com/blog/2013/12/03/beyond-clean-code/"/>
    <updated>2013-12-03T23:09:00+08:00</updated>
    <id>http://towriting.com/blog/2013/12/03/beyond-clean-code</id>
    <content type="html"><![CDATA[<h2>什么是整洁代码（What Is Clean Code）</h2>

<p>当你拿这个问题问不同的人，或采用不同的语气，你可能会得到不同的答案。但通常无外乎这些评判标准：</p>

<ul>
<li>自解释的命名</li>
<li>一致的代码风格</li>
<li>合适的抽象</li>
<li>可读性良好</li>
<li>清晰的代码流程</li>
<li>良好的架构</li>
<li>复杂任务使用库实现</li>
<li>使用工业级的解决方案</li>
<li>没有安全漏洞</li>
<li>函数短小</li>
<li>函数复杂度小</li>
</ul>


<p>不一而足，当然你也有自己评判整洁代码的标尺&hellip;</p>

<h2>如何写出整洁的代码(How To Write Clean Code)</h2>

<p>这是经久不衰的热议话题。我认为下面这幅画可以精辟地诠释如何写出整洁的代码：</p>

<p><img src="/images/posts/beyond-clean-code/towriting.png" title="" ></p>

<p>当然这有一点无厘头，但这是真的。大部分程序员没有写出整洁代码的时间。就此我们无可奈何！</p>

<h2>切换视角（Change The Premise)</h2>

<p>我打算在这说点可能稍具争议、离经叛道的想法：</p>

<blockquote><p>这里只有两种代码。一种具有商业价值，另一种没有！</p></blockquote>

<p>在工业界，我们看中的是“漂亮”的代码，我们看好的是可读性好、行为正确的代码。但因为某些原因，我们从来没有谈论过代码必须要有商用价值。再整洁的代码没有商业价值也是“贱货”。</p>

<p>所以，我们把“具有商业价值”整合进整洁代码的评判标尺，我们得到四种代码：</p>

<table border="1">
<tr><th></th><th>良好的商业价值</th><th>贫乏的商业价值</th></tr>
<tr><th>整洁代码</th><td>出色的代码</td><td>坏代码</td></tr>
<tr><th>丑陋代码</th><td>良好的代码</td><td>垃圾代码</td></tr>
</table>


<p>很明显使代码具有商业价值比使其“整洁”更划算。专注于“整洁”最多可以得到“坏代码”，而专注于"商业价值"，则最差得到“良好的代码”..</p>

<p>所以，怎样才能专注于商业价值呢？</p>

<h2>DIRTI方法（The DIRTI Method)</h2>

<p>我靠写DIRTI<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的代码来使代码专注于商业价值:</p>

<ol>
<li><strong>Develop</strong> &ndash; 为解决某个（商业）问题而快速开发（Develop)出哪怕很烂的代码。不要担心代码格式、抽象及其他任何问题。就是要完成它。</li>
<li><strong>Isolate</strong> &ndash; 分离（Isolate)上一步实现的功能，整理出抽象模块。这些将成为重构的点。</li>
<li><strong>Refactor</strong> &ndash; 重构(Refactor)这些模块，开始整理代码。</li>
<li><strong>Test</strong> &ndash; 当这些模块整理合理后，开始写测试(Test)用例（单元测试）。</li>
<li><strong>Integrate</strong> &ndash; 一旦这些模块通过测试就可以把它们集成(Integrate)进你的程序（要有集成测试）。</li>
</ol>


<p>妙的是，这一系列步骤假定你开始的时候并不知你的代码抽象的样子。但你一旦你开始写代码，它会逐渐帮助你明白你要解决的问题（方案）。</p>

<p>与TDD（测试驱动开发）截然不同的是，TDD期望你在你开始动手写代码前明白你要写的代码。</p>

<p>这确实会把我们带到一个美妙的境地。使用DIRTI方法会有两个主要的阶段：不停的DIR和不停的RTI。</p>

<p>当你最终明白方案之前，你将一遍遍的开发，分离，重构。而一旦顿悟以后，你将花费更多的时间到下一阶段（重构，测试，集成）。</p>

<h2>为什么这有效（Why This Works)</h2>

<p>为什么我坐在这里给你讲DIRTI方法？因为它行之有效。DIRTI方法确实会帮助你知道你要写的代码。它会帮助你指出要解决的问题。</p>

<p>更重要的是，它为你能做出英明决断提供力量和武器。你一定记得，具有商业价值的代码是好的代码。所以当你离开开发阶段，你的代码已经具有了商业价值，因为它已经可以解决最初要解决的问题。</p>

<p>整个进程是迭代的。你可以不停的分离、重构、分离、重构，直到你对代码满意。但这个过程中，你是在可以工作的代码上进行的。这非常酷！这样允许你责问自己，”是否代码已经足够好了“。一旦你对代码满意了，就进入下一阶段。</p>

<p>这会让你关注于最重要的东西：商业价值，而代码质量上的关注度是可以动态选择的。</p>

<h2>不是方案，仅仅是工具（Not A Solution, A Tool)</h2>

<p>必须要澄清的是：不是要你替换掉TDD、结对编程或其它你已经采用了的方法。DIRTI只会是你工具箱里的又一件工具。针对不同的问题要采用不同的工具：</p>

<p>如果你明白你要写的东西，那就用TDD。如果你仅仅知道问题，而不知解决方案（最佳），那就用DIRTI吧。</p>

<p>===================================================================================</p>

<p>翻译自：<a href="http://blog.ircmaxell.com/2013/11/beyond-clean-code.html">Beyond Clean Code</a></p>

<p>图片来自：<a href="http://www.aqee.net/how-to-write-good-code/">如何写出好代码</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>发音同Dirty<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跳槽的好处]]></title>
    <link href="http://towriting.com/blog/2013/11/10/job-hopping/"/>
    <updated>2013-11-10T21:39:00+08:00</updated>
    <id>http://towriting.com/blog/2013/11/10/job-hopping</id>
    <content type="html"><![CDATA[<p>前两天和一个一年半多没联系过的前同事通了个电话，聊了个把小时。我对他现在的工作状态很感兴趣，因为他的工作状态就是我不离开那家公司的可能的状态。</p>

<p>通过他的描述，我感觉他的状态可能与一年半前差别不大。我离开时，推荐他们使用的SVN，到现在还是没有用起来，没有版本控制就没有协作。他讲到他遇到问题会通过Baidu+CSDN找答案，我问他怎么不用Google+Stackoverflow，Stackoverflow我离开前也是向他推荐过的。他知道学，也不排斥技术，现在主要的开发工具是VC6和Delphi6，用C++但没听说过C++11。知道开源，去过SourceForge，但没听说过Github。听说但没有使用过设计模式。</p>

<p>通话最后，本着交流与分享，我向他推荐了以下内容：</p>

<ul>
<li>网站：Github、Stackoverflow、Reddit\r\cpp、HackerNews</li>
<li>书籍：代码大全、程序员修炼之道、The C++ Programming Language、深度探索对象模型、禅与摩托车维修艺术</li>
</ul>


<p>我与他工作年限相仿，技术起点一致，唯一不同的是，我离开了那家公司，所以<strong>有机会学到或接触更多的技术知识，这可能就是跳槽的好处</strong>。</p>

<p>简单梳理一下两次跳槽期间的收获，第一次：
<img class="pull-right" src="/images/posts/job-hopping/brid.jpg" title="&lsquo;良禽择木而栖&rsquo;" ></p>

<ul>
<li>正规的软件开发流程</li>
<li>Bug跟踪系统</li>
<li>静态源码检测系统</li>
<li>自动编译系统</li>
<li>开始正式使用设计模式</li>
<li>GitHub</li>
<li>第一次翻译技术文章</li>
<li>十数本计算机书籍</li>
<li>WBS任务分解</li>
<li>金融知识</li>
<li>Python自动测试</li>
<li>心理学</li>
</ul>


<p>第二次（到现在2013.11)：</p>

<ul>
<li>TFS</li>
<li>项目中大规模使用C++11</li>
<li>Windbg</li>
<li>GDI+</li>
<li>UAC</li>
<li>HackerNews</li>
<li>Reddit</li>
<li>罗辑思维（罗胖）</li>
<li>IPC</li>
<li>Octopress建立博客</li>
<li>wordPress建站</li>
<li>amazon云主机</li>
<li>openshift</li>
<li>手机驱动知识</li>
</ul>


<p>上面纯技术相关的点大部分和跳槽直接相关，因为新公司新气象。其他点或多或少也和跳槽沾边，槽变人变，不同的人可能会给你不同的启发，比如《罗辑思维》这个节目就是一个同事力荐的。</p>

<p>讲到了我自己经历的跳槽的收获，那是不是跳槽一定是利好的？答案是否定的。我曾遇到过一个35岁左右，编程数年的人，有几年中，平均两个月换一份工作，聊天中发现其竟不知很基础的编程知识，使用C++但从没断点调试过。</p>

<p>所以，我以为<strong>好奇心和追求良质<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>是提高技术广度和深度的内部原因、好的项目与工作伙伴是外部原因，而跳槽不过增加了外部原因的刺激而已</strong>。</p>

<p>注：以上是技术提高的角度看跳槽之我见。站在职业发展的角度，最好不要频繁跳槽，站在职业道德与产品责任的角度，更不要轻易跳槽。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>良质，《禅与摩托车维修艺术》中的说法，从现有哲学体系看，良质是唯心的。良质存乎心中，指个人感受到某样东西的好，但无法量化衡量。比如，对比两段相同功能的代码，你可能就觉得其中一段“好”，而说不出原因，这种"好"就是良质。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[神级程序员的神话]]></title>
    <link href="http://towriting.com/blog/2013/09/30/the-myth-of-the-rockstar-programmer/"/>
    <updated>2013-09-30T12:20:00+08:00</updated>
    <id>http://towriting.com/blog/2013/09/30/the-myth-of-the-rockstar-programmer</id>
    <content type="html"><![CDATA[<p>神级程序员<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的神话不过就是个，神话！它是由一些可悲的原因形成的神话：</p>

<ul>
<li>给普通人设置难以实现的预期</li>
<li>宣扬虚无的神级程序员打压团队</li>
<li>告诉某人是神级的并使其相信这一说法</li>
</ul>


<p>现实总是正态分布的。大量的程序员是普通水平的，一些大牛已属异类，神级程序员只是传说中有（其实一些也很烂）。</p>

<p><blockquote><p>落后的项目增加人手,只会导致进度更加落后</p><footer><strong>Brooks&rsquo;s law <a href="http://en.wikipedia.org/wiki/Brooks%27s_law">http://en.wikipedia.org/wiki/Brooks%27s_law</a> 维基百科</strong></footer></blockquote></p>

<h2>神级程序员只是个神话</h2>

<p>人们总是津津乐道神级程序员可以做10个普通开发者的工作。天方夜谭！10个孕妇不会只用一个月生出小孩，10个“神级”程序员也无法代替100个普通程序员。</p>

<ul>
<li>助理工程师 &ndash; 简单的问题复杂的解决方案</li>
<li>工程师 &ndash; 简单的问题简单的解决方案</li>
<li>高级工程师 &ndash; 复杂的问题简单的解决方案</li>
<li>神级工程师 &ndash; 消灭复杂的问题于无形</li>
</ul>


<p>我算是神级的吗？我自信自己是一个高级程序员，也小有名气。过去的20年我参加了很多成功的项目，但我从不是坊间最聪明的人。</p>

<blockquote><p>高级 + 耀眼 != 神级</p></blockquote>

<p>按我的理解：</p>

<blockquote><p>高级 + 思想 == 神级</p></blockquote>

<p>这和有没有名气并没有任何关系。不能因为某某人写博客、书或者善于演讲就说他是个好开发。</p>

<p>神级程序员关心代码行数吗？不，好的开发关注的是解决问题。他们解决问题而不是抱怨问题。</p>

<h2>神级的团队是现实存在的</h2>

<p>事实上，团队想法和经验的某些特质成就了神级团队，这肯定是你关心的。深思与实效的组织架构加上激情积极好学的开发者必能有所成就。假如你坚持叫某些人“大神”，他可能是团队的老师或指导者。</p>

<p>John Galloway曾说过：</p>

<blockquote><p>“三思而后行”+“代码追求良质”是成就好团队的良方</p></blockquote>

<p>建造一只聪明个性的团队。创建<strong>神级团队</strong>。</p>

<p><strong>翻译自</strong>：<a href="http://www.hanselman.com/blog/TheMythOfTheRockstarProgrammer.aspx">The Myth of the Rockstar Programmer</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>神级程序员(Rockstar Programmer)是指技术能力很强、经验丰富还必须要有以一敌十的工作效能的程序员。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
